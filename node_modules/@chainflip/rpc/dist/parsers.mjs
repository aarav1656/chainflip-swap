// src/parsers.ts
import { isNotNullish } from "@chainflip/utils/guard";
import { isHex } from "@chainflip/utils/string";
import { z } from "zod";
var hexString = z.string().refine(isHex, { message: "Invalid hex string" });
var u256 = hexString.transform((value) => BigInt(value));
var numberOrHex = z.union([z.number().transform((n) => BigInt(n)), u256]);
var chainAssetMapFactory = (parser, defaultValue) => z.object({
  Bitcoin: z.object({ BTC: parser }),
  Ethereum: z.object({ ETH: parser, USDC: parser, FLIP: parser, USDT: parser }),
  Polkadot: z.object({ DOT: parser }),
  Arbitrum: z.object({ ETH: parser.default(defaultValue), USDC: parser.default(defaultValue) }).default({ ETH: defaultValue, USDC: defaultValue })
  // Solana: z.object({ SOL: parser.default(defaultValue) }),
});
var chainBaseAssetMapFactory = (parser, defaultValue) => z.object({
  Bitcoin: z.object({ BTC: parser }),
  Ethereum: z.object({ ETH: parser, FLIP: parser, USDT: parser }),
  Polkadot: z.object({ DOT: parser }),
  Arbitrum: z.object({ ETH: parser.default(defaultValue), USDC: parser.default(defaultValue) }).default({ ETH: defaultValue, USDC: defaultValue })
  // Solana: z.object({ SOL: parser.default(defaultValue) }),
});
var chainMapFactory = (parser, defaultValue) => z.object({
  Bitcoin: parser,
  Ethereum: parser,
  Polkadot: parser,
  Arbitrum: parser.default(defaultValue)
  // Solana: parser.default(defaultValue),
});
var rpcAssetSchema = z.union([
  z.object({ chain: z.literal("Bitcoin"), asset: z.literal("BTC") }),
  z.object({ chain: z.literal("Polkadot"), asset: z.literal("DOT") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("FLIP") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("ETH") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDC") }),
  z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDT") }),
  z.object({ chain: z.literal("Arbitrum"), asset: z.literal("ETH") }),
  z.object({ chain: z.literal("Arbitrum"), asset: z.literal("USDC") })
]);
var rename = (mapping) => (obj) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [
    key in mapping ? mapping[key] : key,
    value
  ])
);
var rpcBaseResponse = z.object({
  id: z.union([z.string(), z.number()]),
  jsonrpc: z.literal("2.0")
});
var nonNullish = z.any().refine(isNotNullish, { message: "Value must not be null or undefined" });
var rpcSuccessResponse = rpcBaseResponse.extend({ result: nonNullish });
var rpcErrorResponse = rpcBaseResponse.extend({
  error: z.object({ code: z.number(), message: z.string() })
});
var rpcResponse = z.union([rpcSuccessResponse, rpcErrorResponse]);
var cfSwapRate = z.object({
  intermediary: numberOrHex.nullable(),
  output: numberOrHex
});
var fee = z.intersection(rpcAssetSchema, z.object({ amount: numberOrHex }));
var cfSwapRateV2 = z.object({
  egress_fee: fee,
  ingress_fee: fee,
  intermediary: u256.nullable(),
  network_fee: fee,
  output: u256
});
var chainGetBlockHash = hexString;
var stateGetMetadata = hexString;
var stateGetRuntimeVersion = z.object({
  specName: z.string(),
  implName: z.string(),
  authoringVersion: z.number(),
  specVersion: z.number(),
  implVersion: z.number(),
  apis: z.array(z.tuple([hexString, z.number()])),
  transactionVersion: z.number(),
  stateVersion: z.number()
});
var cfIngressEgressEnvironment = z.object({
  minimum_deposit_amounts: chainAssetMapFactory(numberOrHex, 0),
  ingress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  egress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  witness_safety_margins: chainMapFactory(z.number().nullable(), null),
  egress_dust_limits: chainAssetMapFactory(numberOrHex, 0),
  channel_opening_fees: chainMapFactory(numberOrHex, 0)
}).transform(rename({ egress_dust_limits: "minimum_egress_amounts" }));
var cfSwappingEnvironment = z.object({
  maximum_swap_amounts: chainAssetMapFactory(numberOrHex.nullable(), null),
  network_fee_hundredth_pips: z.number()
});
var cfFundingEnvironment = z.object({
  redemption_tax: numberOrHex,
  minimum_funding_amount: numberOrHex
});
var cfPoolsEnvironment = z.object({
  fees: chainBaseAssetMapFactory(
    z.object({
      limit_order_fee_hundredth_pips: z.number(),
      range_order_fee_hundredth_pips: z.number(),
      range_order_total_fees_earned: z.object({ base: u256, quote: u256 }),
      limit_order_total_fees_earned: z.object({ base: u256, quote: u256 }),
      range_total_swap_inputs: z.object({ base: u256, quote: u256 }),
      limit_total_swap_inputs: z.object({ base: u256, quote: u256 }),
      quote_asset: z.object({ chain: z.literal("Ethereum"), asset: z.literal("USDC") })
    }),
    {
      limit_order_fee_hundredth_pips: 0,
      range_order_fee_hundredth_pips: 0,
      range_order_total_fees_earned: { base: "0x0", quote: "0x0" },
      limit_order_total_fees_earned: { base: "0x0", quote: "0x0" },
      range_total_swap_inputs: { base: "0x0", quote: "0x0" },
      limit_total_swap_inputs: { base: "0x0", quote: "0x0" },
      quote_asset: { chain: "Ethereum", asset: "USDC" }
    }
  )
});
var cfEnvironment = z.object({
  ingress_egress: cfIngressEgressEnvironment,
  swapping: cfSwappingEnvironment,
  funding: cfFundingEnvironment,
  pools: cfPoolsEnvironment
});
var cfBoostPoolsDepth = z.array(
  z.intersection(rpcAssetSchema, z.object({ tier: z.number(), available_amount: u256 }))
);
var cfSupportedAsssets = z.array(z.object({ chain: z.string(), asset: z.string() })).transform(
  (assets) => assets.filter((asset) => rpcAssetSchema.safeParse(asset).success)
);
var brokerRequestSwapDepositAddress = z.object({
  address: z.string(),
  issued_block: z.number(),
  channel_id: z.number(),
  source_chain_expiry_block: numberOrHex,
  channel_opening_fee: u256
});
var unregistered = z.object({
  role: z.literal("unregistered"),
  flip_balance: numberOrHex
});
var broker = z.object({
  role: z.literal("broker"),
  flip_balance: numberOrHex,
  earned_fees: chainAssetMapFactory(numberOrHex, 0)
});
var liquidityProvider = z.object({
  role: z.literal("liquidity_provider"),
  balances: chainAssetMapFactory(numberOrHex, "0x0"),
  refund_addresses: chainMapFactory(z.string().nullable(), null),
  flip_balance: numberOrHex,
  earned_fees: chainAssetMapFactory(numberOrHex, 0)
});
var validator = z.object({
  role: z.literal("validator"),
  flip_balance: numberOrHex,
  bond: numberOrHex,
  last_heartbeat: z.number(),
  reputation_points: z.number(),
  keyholder_epochs: z.array(z.number()),
  is_current_authority: z.boolean(),
  is_current_backup: z.boolean(),
  is_qualified: z.boolean(),
  is_online: z.boolean(),
  is_bidding: z.boolean(),
  bound_redeem_address: hexString.nullable(),
  apy_bp: z.number().nullable(),
  restricted_balances: z.record(hexString, numberOrHex)
});
var cfAccountInfo = z.union([unregistered, broker, liquidityProvider, validator]);
var cfPoolPriceV2 = z.object({
  sell: numberOrHex.nullable(),
  buy: numberOrHex.nullable(),
  range_order: numberOrHex,
  base_asset: rpcAssetSchema,
  quote_asset: rpcAssetSchema
});
var orderId = numberOrHex.transform((n) => String(n));
var limitOrder = z.object({
  id: orderId,
  tick: z.number(),
  sell_amount: numberOrHex,
  fees_earned: numberOrHex,
  original_sell_amount: numberOrHex,
  lp: z.string()
});
var ask = limitOrder.transform((order) => ({
  ...order,
  type: "ask"
}));
var bid = limitOrder.transform((order) => ({
  ...order,
  type: "bid"
}));
var rangeOrder = z.object({
  id: orderId,
  range: z.object({ start: z.number(), end: z.number() }),
  liquidity: numberOrHex,
  fees_earned: z.object({ base: numberOrHex, quote: numberOrHex }),
  lp: z.string()
}).transform((order) => ({ ...order, type: "range" }));
var cfPoolOrders = z.object({
  limit_orders: z.object({
    asks: z.array(ask),
    bids: z.array(bid)
  }),
  range_orders: z.array(rangeOrder)
});
var boostPoolAmount = z.object({
  account_id: z.string(),
  amount: u256
});
var cfBoostPoolDetails = z.array(
  z.intersection(
    rpcAssetSchema,
    z.object({
      fee_tier: z.number(),
      available_amounts: z.array(boostPoolAmount),
      deposits_pending_finalization: z.array(
        z.object({
          deposit_id: z.number().transform(BigInt),
          owed_amounts: z.array(boostPoolAmount)
        })
      ),
      pending_withdrawals: z.array(
        z.object({
          account_id: z.string(),
          pending_deposits: z.array(z.bigint())
        })
      )
    })
  )
);
var cfBoostPoolPendingFees = z.array(
  z.intersection(
    rpcAssetSchema,
    z.object({
      fee_tier: z.number(),
      pending_fees: z.array(
        z.object({
          deposit_id: z.number().transform(BigInt),
          fees: z.array(boostPoolAmount)
        })
      )
    })
  )
);
export {
  broker,
  brokerRequestSwapDepositAddress,
  cfAccountInfo,
  cfBoostPoolDetails,
  cfBoostPoolPendingFees,
  cfBoostPoolsDepth,
  cfEnvironment,
  cfFundingEnvironment,
  cfIngressEgressEnvironment,
  cfPoolOrders,
  cfPoolPriceV2,
  cfPoolsEnvironment,
  cfSupportedAsssets,
  cfSwapRate,
  cfSwapRateV2,
  cfSwappingEnvironment,
  chainGetBlockHash,
  hexString,
  liquidityProvider,
  numberOrHex,
  rpcResponse,
  stateGetMetadata,
  stateGetRuntimeVersion,
  u256,
  unregistered,
  validator
};
