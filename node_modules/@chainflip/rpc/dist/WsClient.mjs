// src/WsClient.ts
import { deferredPromise, once, sleep } from "@chainflip/utils/async";
import { randomUUID } from "crypto";
import Client from "./Client.mjs";
import { rpcResponse } from "./common.mjs";
var READY = "READY";
var DISCONNECT = "DISCONNECT";
var WsClient = class extends Client {
  constructor(url, WebSocket = globalThis.WebSocket) {
    super(url);
    this.WebSocket = WebSocket;
  }
  ws;
  reconnectAttempts = 0;
  emitter = new EventTarget();
  requestMap = /* @__PURE__ */ new Map();
  getRequestId() {
    return randomUUID();
  }
  async close() {
    await this.handleClose();
  }
  async handleClose() {
    if (!this.ws)
      return;
    this.ws.removeEventListener("close", this.handleDisconnect);
    this.ws.close();
    if (this.ws.readyState !== this.WebSocket.CLOSED) {
      await once(this.ws, "close");
    }
  }
  async connectionReady() {
    if (!this.ws) {
      return this.connect();
    }
    if (this.ws.readyState !== this.WebSocket.OPEN) {
      await once(this.emitter, READY, { timeout: 3e4 });
    }
    return this.ws;
  }
  handleDisconnect = async () => {
    this.emitter.dispatchEvent(new Event(DISCONNECT));
    this.requestMap.forEach((request) => {
      request.reject(new Error("disconnected"));
    });
    this.requestMap.clear();
    const backoff = 250 * 2 ** this.reconnectAttempts;
    await sleep(backoff);
    await this.connect().catch(() => {
      this.reconnectAttempts = Math.min(this.reconnectAttempts + 1, 6);
    });
  };
  handleMessage = (data) => {
    const parsedData = JSON.parse(data.data);
    const response = rpcResponse.safeParse(parsedData);
    if (!response.success)
      return;
    const { id } = response.data;
    this.requestMap.get(id)?.resolve(response.data);
  };
  async connect() {
    const socket = new this.WebSocket(this.url);
    this.ws = socket;
    this.ws.addEventListener("message", this.handleMessage);
    this.ws.addEventListener("close", this.handleDisconnect, { once: true });
    await once(this.ws, "open", { timeout: 3e4 });
    this.ws.addEventListener("error", () => {
      socket.close();
    });
    this.emitter.dispatchEvent(new Event(READY));
    this.reconnectAttempts = 0;
    return socket;
  }
  async send(data) {
    let requestId = data.id;
    for (let i = 0; i < 5; i += 1) {
      let socket;
      try {
        socket = await this.connectionReady();
      } catch (err) {
        continue;
      }
      socket.send(JSON.stringify({ ...data, id: requestId }));
      const request = deferredPromise();
      this.requestMap.set(requestId, request);
      const controller = new AbortController();
      const result = await Promise.race([
        sleep(3e4, { signal: controller.signal }).then(
          () => ({ success: false, retry: false, error: new Error("timeout") })
        ),
        request.promise.then(
          (result2) => ({ success: true, result: result2 }),
          (error) => ({ success: false, error, retry: true })
        )
      ]).finally(() => {
        this.requestMap.delete(requestId);
        controller.abort();
      });
      if (result.success || !result.retry)
        return result;
      requestId = this.getRequestId();
    }
    return { success: false, error: new Error("max retries exceeded") };
  }
};
export {
  WsClient as default
};
