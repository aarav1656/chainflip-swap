"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;// src/WsClient.ts
var _async = require('@chainflip/utils/async');
var _crypto = require('crypto');
var _Clientcjs = require('./Client.cjs'); var _Clientcjs2 = _interopRequireDefault(_Clientcjs);
var _commoncjs = require('./common.cjs');
var READY = "READY";
var DISCONNECT = "DISCONNECT";
var WsClient = (_class = class extends _Clientcjs2.default {
  constructor(url, WebSocket = globalThis.WebSocket) {
    super(url);_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);_class.prototype.__init5.call(this);;
    this.WebSocket = WebSocket;
  }
  
  __init() {this.reconnectAttempts = 0}
  __init2() {this.emitter = new EventTarget()}
  __init3() {this.requestMap = /* @__PURE__ */ new Map()}
  getRequestId() {
    return _crypto.randomUUID.call(void 0, );
  }
  async close() {
    await this.handleClose();
  }
  async handleClose() {
    if (!this.ws)
      return;
    this.ws.removeEventListener("close", this.handleDisconnect);
    this.ws.close();
    if (this.ws.readyState !== this.WebSocket.CLOSED) {
      await _async.once.call(void 0, this.ws, "close");
    }
  }
  async connectionReady() {
    if (!this.ws) {
      return this.connect();
    }
    if (this.ws.readyState !== this.WebSocket.OPEN) {
      await _async.once.call(void 0, this.emitter, READY, { timeout: 3e4 });
    }
    return this.ws;
  }
  __init4() {this.handleDisconnect = async () => {
    this.emitter.dispatchEvent(new Event(DISCONNECT));
    this.requestMap.forEach((request) => {
      request.reject(new Error("disconnected"));
    });
    this.requestMap.clear();
    const backoff = 250 * 2 ** this.reconnectAttempts;
    await _async.sleep.call(void 0, backoff);
    await this.connect().catch(() => {
      this.reconnectAttempts = Math.min(this.reconnectAttempts + 1, 6);
    });
  }}
  __init5() {this.handleMessage = (data) => {
    const parsedData = JSON.parse(data.data);
    const response = _commoncjs.rpcResponse.safeParse(parsedData);
    if (!response.success)
      return;
    const { id } = response.data;
    _optionalChain([this, 'access', _6 => _6.requestMap, 'access', _7 => _7.get, 'call', _8 => _8(id), 'optionalAccess', _9 => _9.resolve, 'call', _10 => _10(response.data)]);
  }}
  async connect() {
    const socket = new this.WebSocket(this.url);
    this.ws = socket;
    this.ws.addEventListener("message", this.handleMessage);
    this.ws.addEventListener("close", this.handleDisconnect, { once: true });
    await _async.once.call(void 0, this.ws, "open", { timeout: 3e4 });
    this.ws.addEventListener("error", () => {
      socket.close();
    });
    this.emitter.dispatchEvent(new Event(READY));
    this.reconnectAttempts = 0;
    return socket;
  }
  async send(data) {
    let requestId = data.id;
    for (let i = 0; i < 5; i += 1) {
      let socket;
      try {
        socket = await this.connectionReady();
      } catch (err) {
        continue;
      }
      socket.send(JSON.stringify({ ...data, id: requestId }));
      const request = _async.deferredPromise.call(void 0, );
      this.requestMap.set(requestId, request);
      const controller = new AbortController();
      const result = await Promise.race([
        _async.sleep.call(void 0, 3e4, { signal: controller.signal }).then(
          () => ({ success: false, retry: false, error: new Error("timeout") })
        ),
        request.promise.then(
          (result2) => ({ success: true, result: result2 }),
          (error) => ({ success: false, error, retry: true })
        )
      ]).finally(() => {
        this.requestMap.delete(requestId);
        controller.abort();
      });
      if (result.success || !result.retry)
        return result;
      requestId = this.getRequestId();
    }
    return { success: false, error: new Error("max retries exceeded") };
  }
}, _class);


exports.default = WsClient;
