"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/parsers.ts
var _guard = require('@chainflip/utils/guard');
var _string = require('@chainflip/utils/string');
var _zod = require('zod');
var hexString = _zod.z.string().refine(_string.isHex, { message: "Invalid hex string" });
var u256 = hexString.transform((value) => BigInt(value));
var numberOrHex = _zod.z.union([_zod.z.number().transform((n) => BigInt(n)), u256]);
var chainAssetMapFactory = (parser, defaultValue) => _zod.z.object({
  Bitcoin: _zod.z.object({ BTC: parser }),
  Ethereum: _zod.z.object({ ETH: parser, USDC: parser, FLIP: parser, USDT: parser }),
  Polkadot: _zod.z.object({ DOT: parser }),
  Arbitrum: _zod.z.object({ ETH: parser.default(defaultValue), USDC: parser.default(defaultValue) }).default({ ETH: defaultValue, USDC: defaultValue })
  // Solana: z.object({ SOL: parser.default(defaultValue) }),
});
var chainBaseAssetMapFactory = (parser, defaultValue) => _zod.z.object({
  Bitcoin: _zod.z.object({ BTC: parser }),
  Ethereum: _zod.z.object({ ETH: parser, FLIP: parser, USDT: parser }),
  Polkadot: _zod.z.object({ DOT: parser }),
  Arbitrum: _zod.z.object({ ETH: parser.default(defaultValue), USDC: parser.default(defaultValue) }).default({ ETH: defaultValue, USDC: defaultValue })
  // Solana: z.object({ SOL: parser.default(defaultValue) }),
});
var chainMapFactory = (parser, defaultValue) => _zod.z.object({
  Bitcoin: parser,
  Ethereum: parser,
  Polkadot: parser,
  Arbitrum: parser.default(defaultValue)
  // Solana: parser.default(defaultValue),
});
var rpcAssetSchema = _zod.z.union([
  _zod.z.object({ chain: _zod.z.literal("Bitcoin"), asset: _zod.z.literal("BTC") }),
  _zod.z.object({ chain: _zod.z.literal("Polkadot"), asset: _zod.z.literal("DOT") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("FLIP") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("ETH") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDC") }),
  _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDT") }),
  _zod.z.object({ chain: _zod.z.literal("Arbitrum"), asset: _zod.z.literal("ETH") }),
  _zod.z.object({ chain: _zod.z.literal("Arbitrum"), asset: _zod.z.literal("USDC") })
]);
var rename = (mapping) => (obj) => Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [
    key in mapping ? mapping[key] : key,
    value
  ])
);
var rpcBaseResponse = _zod.z.object({
  id: _zod.z.union([_zod.z.string(), _zod.z.number()]),
  jsonrpc: _zod.z.literal("2.0")
});
var nonNullish = _zod.z.any().refine(_guard.isNotNullish, { message: "Value must not be null or undefined" });
var rpcSuccessResponse = rpcBaseResponse.extend({ result: nonNullish });
var rpcErrorResponse = rpcBaseResponse.extend({
  error: _zod.z.object({ code: _zod.z.number(), message: _zod.z.string() })
});
var rpcResponse = _zod.z.union([rpcSuccessResponse, rpcErrorResponse]);
var cfSwapRate = _zod.z.object({
  intermediary: numberOrHex.nullable(),
  output: numberOrHex
});
var fee = _zod.z.intersection(rpcAssetSchema, _zod.z.object({ amount: numberOrHex }));
var cfSwapRateV2 = _zod.z.object({
  egress_fee: fee,
  ingress_fee: fee,
  intermediary: u256.nullable(),
  network_fee: fee,
  output: u256
});
var chainGetBlockHash = hexString;
var stateGetMetadata = hexString;
var stateGetRuntimeVersion = _zod.z.object({
  specName: _zod.z.string(),
  implName: _zod.z.string(),
  authoringVersion: _zod.z.number(),
  specVersion: _zod.z.number(),
  implVersion: _zod.z.number(),
  apis: _zod.z.array(_zod.z.tuple([hexString, _zod.z.number()])),
  transactionVersion: _zod.z.number(),
  stateVersion: _zod.z.number()
});
var cfIngressEgressEnvironment = _zod.z.object({
  minimum_deposit_amounts: chainAssetMapFactory(numberOrHex, 0),
  ingress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  egress_fees: chainAssetMapFactory(numberOrHex.nullable(), null),
  witness_safety_margins: chainMapFactory(_zod.z.number().nullable(), null),
  egress_dust_limits: chainAssetMapFactory(numberOrHex, 0),
  channel_opening_fees: chainMapFactory(numberOrHex, 0)
}).transform(rename({ egress_dust_limits: "minimum_egress_amounts" }));
var cfSwappingEnvironment = _zod.z.object({
  maximum_swap_amounts: chainAssetMapFactory(numberOrHex.nullable(), null),
  network_fee_hundredth_pips: _zod.z.number()
});
var cfFundingEnvironment = _zod.z.object({
  redemption_tax: numberOrHex,
  minimum_funding_amount: numberOrHex
});
var cfPoolsEnvironment = _zod.z.object({
  fees: chainBaseAssetMapFactory(
    _zod.z.object({
      limit_order_fee_hundredth_pips: _zod.z.number(),
      range_order_fee_hundredth_pips: _zod.z.number(),
      range_order_total_fees_earned: _zod.z.object({ base: u256, quote: u256 }),
      limit_order_total_fees_earned: _zod.z.object({ base: u256, quote: u256 }),
      range_total_swap_inputs: _zod.z.object({ base: u256, quote: u256 }),
      limit_total_swap_inputs: _zod.z.object({ base: u256, quote: u256 }),
      quote_asset: _zod.z.object({ chain: _zod.z.literal("Ethereum"), asset: _zod.z.literal("USDC") })
    }),
    {
      limit_order_fee_hundredth_pips: 0,
      range_order_fee_hundredth_pips: 0,
      range_order_total_fees_earned: { base: "0x0", quote: "0x0" },
      limit_order_total_fees_earned: { base: "0x0", quote: "0x0" },
      range_total_swap_inputs: { base: "0x0", quote: "0x0" },
      limit_total_swap_inputs: { base: "0x0", quote: "0x0" },
      quote_asset: { chain: "Ethereum", asset: "USDC" }
    }
  )
});
var cfEnvironment = _zod.z.object({
  ingress_egress: cfIngressEgressEnvironment,
  swapping: cfSwappingEnvironment,
  funding: cfFundingEnvironment,
  pools: cfPoolsEnvironment
});
var cfBoostPoolsDepth = _zod.z.array(
  _zod.z.intersection(rpcAssetSchema, _zod.z.object({ tier: _zod.z.number(), available_amount: u256 }))
);
var cfSupportedAsssets = _zod.z.array(_zod.z.object({ chain: _zod.z.string(), asset: _zod.z.string() })).transform(
  (assets) => assets.filter((asset) => rpcAssetSchema.safeParse(asset).success)
);
var brokerRequestSwapDepositAddress = _zod.z.object({
  address: _zod.z.string(),
  issued_block: _zod.z.number(),
  channel_id: _zod.z.number(),
  source_chain_expiry_block: numberOrHex,
  channel_opening_fee: u256
});
var unregistered = _zod.z.object({
  role: _zod.z.literal("unregistered"),
  flip_balance: numberOrHex
});
var broker = _zod.z.object({
  role: _zod.z.literal("broker"),
  flip_balance: numberOrHex,
  earned_fees: chainAssetMapFactory(numberOrHex, 0)
});
var liquidityProvider = _zod.z.object({
  role: _zod.z.literal("liquidity_provider"),
  balances: chainAssetMapFactory(numberOrHex, "0x0"),
  refund_addresses: chainMapFactory(_zod.z.string().nullable(), null),
  flip_balance: numberOrHex,
  earned_fees: chainAssetMapFactory(numberOrHex, 0)
});
var validator = _zod.z.object({
  role: _zod.z.literal("validator"),
  flip_balance: numberOrHex,
  bond: numberOrHex,
  last_heartbeat: _zod.z.number(),
  reputation_points: _zod.z.number(),
  keyholder_epochs: _zod.z.array(_zod.z.number()),
  is_current_authority: _zod.z.boolean(),
  is_current_backup: _zod.z.boolean(),
  is_qualified: _zod.z.boolean(),
  is_online: _zod.z.boolean(),
  is_bidding: _zod.z.boolean(),
  bound_redeem_address: hexString.nullable(),
  apy_bp: _zod.z.number().nullable(),
  restricted_balances: _zod.z.record(hexString, numberOrHex)
});
var cfAccountInfo = _zod.z.union([unregistered, broker, liquidityProvider, validator]);
var cfPoolPriceV2 = _zod.z.object({
  sell: numberOrHex.nullable(),
  buy: numberOrHex.nullable(),
  range_order: numberOrHex,
  base_asset: rpcAssetSchema,
  quote_asset: rpcAssetSchema
});
var orderId = numberOrHex.transform((n) => String(n));
var limitOrder = _zod.z.object({
  id: orderId,
  tick: _zod.z.number(),
  sell_amount: numberOrHex,
  fees_earned: numberOrHex,
  original_sell_amount: numberOrHex,
  lp: _zod.z.string()
});
var ask = limitOrder.transform((order) => ({
  ...order,
  type: "ask"
}));
var bid = limitOrder.transform((order) => ({
  ...order,
  type: "bid"
}));
var rangeOrder = _zod.z.object({
  id: orderId,
  range: _zod.z.object({ start: _zod.z.number(), end: _zod.z.number() }),
  liquidity: numberOrHex,
  fees_earned: _zod.z.object({ base: numberOrHex, quote: numberOrHex }),
  lp: _zod.z.string()
}).transform((order) => ({ ...order, type: "range" }));
var cfPoolOrders = _zod.z.object({
  limit_orders: _zod.z.object({
    asks: _zod.z.array(ask),
    bids: _zod.z.array(bid)
  }),
  range_orders: _zod.z.array(rangeOrder)
});
var boostPoolAmount = _zod.z.object({
  account_id: _zod.z.string(),
  amount: u256
});
var cfBoostPoolDetails = _zod.z.array(
  _zod.z.intersection(
    rpcAssetSchema,
    _zod.z.object({
      fee_tier: _zod.z.number(),
      available_amounts: _zod.z.array(boostPoolAmount),
      deposits_pending_finalization: _zod.z.array(
        _zod.z.object({
          deposit_id: _zod.z.number().transform(BigInt),
          owed_amounts: _zod.z.array(boostPoolAmount)
        })
      ),
      pending_withdrawals: _zod.z.array(
        _zod.z.object({
          account_id: _zod.z.string(),
          pending_deposits: _zod.z.array(_zod.z.bigint())
        })
      )
    })
  )
);
var cfBoostPoolPendingFees = _zod.z.array(
  _zod.z.intersection(
    rpcAssetSchema,
    _zod.z.object({
      fee_tier: _zod.z.number(),
      pending_fees: _zod.z.array(
        _zod.z.object({
          deposit_id: _zod.z.number().transform(BigInt),
          fees: _zod.z.array(boostPoolAmount)
        })
      )
    })
  )
);



























exports.broker = broker; exports.brokerRequestSwapDepositAddress = brokerRequestSwapDepositAddress; exports.cfAccountInfo = cfAccountInfo; exports.cfBoostPoolDetails = cfBoostPoolDetails; exports.cfBoostPoolPendingFees = cfBoostPoolPendingFees; exports.cfBoostPoolsDepth = cfBoostPoolsDepth; exports.cfEnvironment = cfEnvironment; exports.cfFundingEnvironment = cfFundingEnvironment; exports.cfIngressEgressEnvironment = cfIngressEgressEnvironment; exports.cfPoolOrders = cfPoolOrders; exports.cfPoolPriceV2 = cfPoolPriceV2; exports.cfPoolsEnvironment = cfPoolsEnvironment; exports.cfSupportedAsssets = cfSupportedAsssets; exports.cfSwapRate = cfSwapRate; exports.cfSwapRateV2 = cfSwapRateV2; exports.cfSwappingEnvironment = cfSwappingEnvironment; exports.chainGetBlockHash = chainGetBlockHash; exports.hexString = hexString; exports.liquidityProvider = liquidityProvider; exports.numberOrHex = numberOrHex; exports.rpcResponse = rpcResponse; exports.stateGetMetadata = stateGetMetadata; exports.stateGetRuntimeVersion = stateGetRuntimeVersion; exports.u256 = u256; exports.unregistered = unregistered; exports.validator = validator;
