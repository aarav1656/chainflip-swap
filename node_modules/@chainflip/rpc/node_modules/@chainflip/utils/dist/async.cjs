"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/async.ts
var async_exports = {};
__export(async_exports, {
  Queue: () => Queue,
  RateLimiter: () => RateLimiter,
  deferredPromise: () => deferredPromise,
  once: () => once,
  sleep: () => sleep
});
module.exports = __toCommonJS(async_exports);
var deferredPromise = () => {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var sleep = (ms, { signal } = {}) => {
  const deferred = deferredPromise();
  const timeout = setTimeout(deferred.resolve, ms);
  if (signal) {
    const abort = () => {
      clearTimeout(timeout);
      deferred.resolve();
    };
    signal.addEventListener("abort", abort);
    deferred.promise = deferred.promise.finally(() => {
      signal.removeEventListener("abort", abort);
    });
  }
  return deferred.promise;
};
var Queue = class {
  constructor(debounce) {
    this.debounce = debounce;
  }
  promise = Promise.resolve();
  enqueue(fn, ...args) {
    return new Promise((resolve, reject) => {
      this.promise = this.promise.then(async () => {
        const sleepPromise = this.debounce ? sleep(this.debounce) : Promise.resolve();
        await Promise.all([fn(...args).then(resolve, reject), sleepPromise]);
      });
    });
  }
};
var RateLimiter = class {
  fn;
  debounce;
  queues;
  index = 0;
  constructor(opts) {
    this.fn = opts.fn;
    this.debounce = opts.debounce;
    this.queues = Array.from({ length: opts.maxConcurrency }, () => new Queue(this.debounce));
  }
  request(...args) {
    const nextIndex = this.index;
    this.index = (this.index + 1) % this.queues.length;
    return this.queues[nextIndex].enqueue(this.fn, ...args);
  }
};
var once = async (target, event, opts) => {
  const deferred = deferredPromise();
  const onSuccess = () => {
    target.removeEventListener("error", onError);
    deferred.resolve();
  };
  const onError = () => {
    target.removeEventListener(event, onSuccess);
    deferred.reject(new Error("error"));
  };
  target.addEventListener(event, onSuccess, { once: true, signal: opts?.signal });
  target.addEventListener("error", onError, { once: true, signal: opts?.signal });
  if (opts?.signal) {
    const signal = opts.signal;
    const abort = () => {
      deferred.reject(new Error("aborted"));
    };
    signal.addEventListener("abort", abort);
    deferred.promise = deferred.promise.finally(() => {
      signal.removeEventListener("abort", abort);
    });
  }
  if (opts?.timeout) {
    const timer = setTimeout(() => {
      deferred.reject(new Error("timeout"));
    }, opts.timeout);
    deferred.promise = deferred.promise.finally(() => {
      clearTimeout(timer);
    });
  }
  await deferred.promise;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Queue,
  RateLimiter,
  deferredPromise,
  once,
  sleep
});
