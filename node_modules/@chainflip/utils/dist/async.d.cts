declare const deferredPromise: <T>() => {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (error: Error) => void;
};
type DeferredPromise<T> = ReturnType<typeof deferredPromise<T>>;
declare const sleep: (ms: number, { signal }?: {
    signal?: AbortSignal;
}) => Promise<void>;
declare class Queue {
    private readonly debounce?;
    private promise;
    constructor(debounce?: number | undefined);
    enqueue<T, Args extends unknown[]>(fn: (...args: Args) => Promise<T>, ...args: Args): Promise<T>;
}
declare class RateLimiter<T, Args extends unknown[]> {
    fn: (...args: Args) => Promise<T>;
    debounce: number;
    queues: Queue[];
    index: number;
    constructor(opts: {
        fn: (...args: Args) => Promise<T>;
        debounce: number;
        maxConcurrency: number;
    });
    request(...args: Args): Promise<T>;
}
declare const once: <T extends EventTarget, K extends string>(target: T, event: K, opts?: {
    signal?: AbortSignal;
    timeout?: number;
}) => Promise<void>;

export { type DeferredPromise, Queue, RateLimiter, deferredPromise, once, sleep };
