import { getEnvironment, getSupportedAssets, getAllBoostPoolsDepth, getVaultContractAddress, approve, getTokenContractAddress, getEvmChainId, checkAllowance, extractOverrides, Vault__factory } from './chunk-M32JHS3U.mjs';
import { assertValidAddress, ccmMetadataSchema, dotAddress } from './chunk-JHVSTX24.mjs';
import { __name, ChainflipNetworks, __publicField, Chains, assetConstants, getInternalAsset, isNotNullish, assert, getAssetAndChain, readChainAssetValue, isTestnet, chainConstants, getInternalAssets } from './chunk-3V7QJANN.mjs';
export { Assets, InternalAssets as ChainflipIds, ChainflipNetworks, Chains, getInternalAsset as getChainflipId } from './chunk-3V7QJANN.mjs';
import { bytesToHex } from '@chainflip/utils/bytes';
import * as ss58 from '@chainflip/utils/ss58';
import axios from 'axios';

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x) {
  return x;
}
__name(identity, "identity");
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return /* @__PURE__ */ __name(function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  }, "piped");
}
__name(pipeFromArray, "pipeFromArray");
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      __name(unsubscribe, "unsubscribe");
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer.next?.(value);
        },
        error(err) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.error?.(err);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self);
    }
  };
  return self;
}
__name(observable, "observable");

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer of observers) {
            observer.next?.(value);
          }
        },
        error(error) {
          for (const observer of observers) {
            observer.error?.(error);
          }
        },
        complete() {
          for (const observer of observers) {
            observer.complete?.();
          }
        }
      });
    }
    __name(startIfNeeded, "startIfNeeded");
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    __name(resetIfNeeded, "resetIfNeeded");
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v) => v === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
__name(share, "share");
var _ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
__name(_ObservableAbortError, "ObservableAbortError");
var ObservableAbortError = _ObservableAbortError;
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    __name(onDone, "onDone");
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}
__name(observableToPromise, "observableToPromise");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    __name(execute, "execute");
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
__name(createChain, "createChain");

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/codes-c924c3db.mjs
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v = obj[key];
    newObj[v] = key;
  }
  return newObj;
}
__name(invert, "invert");
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
invert(TRPC_ERROR_CODES_BY_KEY);

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/index-f91d720c.mjs
invert(TRPC_ERROR_CODES_BY_KEY);
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path[path.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path.slice(0, -1) : path
      });
    }
  });
  return proxy;
}
__name(createInnerProxy, "createInnerProxy");
var createRecursiveProxy = /* @__PURE__ */ __name((callback) => createInnerProxy(callback, []), "createRecursiveProxy");
var createFlatProxy = /* @__PURE__ */ __name((callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
}, "createFlatProxy");

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/getCauseFromUnknown-2d66414a.mjs
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
__name(isObject, "isObject");
var _UnknownCauseError = class _UnknownCauseError extends Error {
};
__name(_UnknownCauseError, "UnknownCauseError");
var UnknownCauseError = _UnknownCauseError;
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type = typeof cause;
  if (type === "undefined" || type === "function" || cause === null) {
    return void 0;
  }
  if (type !== "object") {
    return new Error(String(cause));
  }
  if (isObject(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
__name(getCauseFromUnknown, "getCauseFromUnknown");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/transformResult-ace864b8.mjs
function isObject2(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
__name(isObject2, "isObject");
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
__name(transformResultInner, "transformResultInner");
var _TransformResultError = class _TransformResultError extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
__name(_TransformResultError, "TransformResultError");
var TransformResultError = _TransformResultError;
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject2(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject2(result.result)) {
    throw new TransformResultError();
  }
  return result;
}
__name(transformResult, "transformResult");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/TRPCClientError-38f9a32a.mjs
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
__name(isTRPCClientError, "isTRPCClientError");
function isTRPCErrorResponse(obj) {
  return isObject2(obj) && isObject2(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
}
__name(isTRPCErrorResponse, "isTRPCErrorResponse");
var _TRPCClientError = class _TRPCClientError extends Error {
  static from(_cause, opts = {}) {
    const cause = _cause;
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    if (isTRPCErrorResponse(cause)) {
      return new _TRPCClientError(cause.error.message, {
        ...opts,
        result: cause
      });
    }
    if (!(cause instanceof Error)) {
      return new _TRPCClientError("Unknown error", {
        ...opts,
        cause
      });
    }
    return new _TRPCClientError(cause.message, {
      ...opts,
      cause: getCauseFromUnknown(cause)
    });
  }
  constructor(message, opts) {
    const cause = opts?.cause;
    super(message, {
      cause
    });
    this.meta = opts?.meta;
    this.cause = cause;
    this.shape = opts?.result?.error;
    this.data = opts?.result?.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};
__name(_TRPCClientError, "TRPCClientError");
var TRPCClientError = _TRPCClientError;

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/httpUtils-b9d0cb48.mjs
var isFunction = /* @__PURE__ */ __name((fn) => typeof fn === "function", "isFunction");
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
__name(getFetch, "getFetch");
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
__name(getAbortController, "getAbortController");
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url.toString().replace(/\/$/, ""),
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
__name(resolveHTTPLinkOptions, "resolveHTTPLinkOptions");
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
__name(arrayToDict, "arrayToDict");
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
__name(getInput, "getInput");
var getUrl = /* @__PURE__ */ __name((opts) => {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
}, "getUrl");
var getBody = /* @__PURE__ */ __name((opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
}, "getBody");
var jsonHttpRequester = /* @__PURE__ */ __name((opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
}, "jsonHttpRequester");
async function fetchHTTPResponse(opts, ac) {
  const url = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type } = opts;
  const resolvedHeaders = await opts.headers();
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url, {
    method: METHOD[type],
    signal: ac?.signal,
    body,
    headers
  });
}
__name(fetchHTTPResponse, "fetchHTTPResponse");
function httpRequest(opts) {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  let done = false;
  const promise = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts, ac).then((_res) => {
      meta.response = _res;
      done = true;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      done = true;
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = /* @__PURE__ */ __name(() => {
    if (!done) {
      ac?.abort();
    }
  }, "cancel");
  return {
    promise,
    cancel
  };
}
__name(httpRequest, "httpRequest");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/httpBatchLink-d0f9eac9.mjs
var throwFatalError = /* @__PURE__ */ __name(() => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
}, "throwFatalError");
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = /* @__PURE__ */ __name(() => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  }, "destroyTimerAndPendingItems");
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index++;
        continue;
      }
      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  __name(groupItems, "groupItems");
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = /* @__PURE__ */ __name((index, value) => {
        const item = batch.items[index];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      }, "unitResolver");
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise.then((result) => {
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          unitResolver(i, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  __name(dispatch, "dispatch");
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = /* @__PURE__ */ __name(() => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    }, "cancel");
    return {
      promise,
      cancel
    };
  }
  __name(load, "load");
  return {
    load
  };
}
__name(dataLoader, "dataLoader");
function createHTTPBatchLink(requester) {
  return /* @__PURE__ */ __name(function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = /* @__PURE__ */ __name((type) => {
        const validate = /* @__PURE__ */ __name((batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path,
            inputs
          });
          return url.length <= maxURLLength;
        }, "validate");
        const fetch = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts
        });
        return {
          validate,
          fetch
        };
      }, "batchLoader");
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise, cancel } = loader.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  }, "httpBatchLink");
}
__name(createHTTPBatchLink, "createHTTPBatchLink");
var batchRequester = /* @__PURE__ */ __name((requesterOpts) => {
  return (batchOps) => {
    const path = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
}, "batchRequester");
var httpBatchLink = createHTTPBatchLink(batchRequester);

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer) => {
      const { path, input, type } = op;
      const { promise, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type,
        path,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer.next({
          context: res.meta,
          result: transformed.result
        });
        observer.complete();
      }).catch((cause) => {
        observer.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
__name(httpLinkFactory, "httpLinkFactory");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/index.mjs
var _TRPCUntypedClient = class _TRPCUntypedClient {
  $request({ type, input, path, context = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path,
        input,
        context
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      opts.signal?.addEventListener("abort", abort);
      promise.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  mutation(path, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  subscription(path, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path,
      input,
      context: opts?.context
    });
    return observable$.subscribe({
      next(envelope) {
        if (envelope.result.type === "started") {
          opts.onStarted?.();
        } else if (envelope.result.type === "stopped") {
          opts.onStopped?.();
        } else {
          opts.onData?.(envelope.result.data);
        }
      },
      error(err) {
        opts.onError?.(err);
      },
      complete() {
        opts.onComplete?.();
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: /* @__PURE__ */ __name((data) => data, "serialize"),
            deserialize: /* @__PURE__ */ __name((data) => data, "deserialize")
          },
          output: {
            serialize: /* @__PURE__ */ __name((data) => data, "serialize"),
            deserialize: /* @__PURE__ */ __name((data) => data, "deserialize")
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: /* @__PURE__ */ __name((data) => combinedTransformer.input.serialize(data), "serialize"),
        deserialize: /* @__PURE__ */ __name((data) => combinedTransformer.output.deserialize(data), "deserialize")
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
__name(_TRPCUntypedClient, "TRPCUntypedClient");
var TRPCUntypedClient = _TRPCUntypedClient;
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var clientCallTypeToProcedureType = /* @__PURE__ */ __name((clientCallType) => {
  return clientCallTypeMap[clientCallType];
}, "clientCallTypeToProcedureType");
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    if (key === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
__name(createTRPCClientProxy, "createTRPCClientProxy");
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
__name(createTRPCProxyClient, "createTRPCProxyClient");
function getTextDecoder(customTextDecoder) {
  if (customTextDecoder) {
    return customTextDecoder;
  }
  if (typeof window !== "undefined" && window.TextDecoder) {
    return new window.TextDecoder();
  }
  if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
    return new globalThis.TextDecoder();
  }
  throw new Error("No TextDecoder implementation found");
}
__name(getTextDecoder, "getTextDecoder");
async function parseJSONStream(opts) {
  const parse2 = opts.parse ?? JSON.parse;
  const onLine = /* @__PURE__ */ __name((line) => {
    if (opts.signal?.aborted) return;
    if (!line || line === "}") {
      return;
    }
    const indexOfColon = line.indexOf(":");
    const indexAsStr = line.substring(2, indexOfColon - 1);
    const text = line.substring(indexOfColon + 1);
    opts.onSingle(Number(indexAsStr), parse2(text));
  }, "onLine");
  await readLines(opts.readableStream, onLine, opts.textDecoder);
}
__name(parseJSONStream, "parseJSONStream");
async function readLines(readableStream, onLine, textDecoder) {
  let partOfLine = "";
  const onChunk = /* @__PURE__ */ __name((chunk) => {
    const chunkText = textDecoder.decode(chunk);
    const chunkLines = chunkText.split("\n");
    if (chunkLines.length === 1) {
      partOfLine += chunkLines[0];
    } else if (chunkLines.length > 1) {
      onLine(partOfLine + chunkLines[0]);
      for (let i = 1; i < chunkLines.length - 1; i++) {
        onLine(chunkLines[i]);
      }
      partOfLine = chunkLines[chunkLines.length - 1];
    }
  }, "onChunk");
  if ("getReader" in readableStream) {
    await readStandardChunks(readableStream, onChunk);
  } else {
    await readNodeChunks(readableStream, onChunk);
  }
  onLine(partOfLine);
}
__name(readLines, "readLines");
function readNodeChunks(stream, onChunk) {
  return new Promise((resolve) => {
    stream.on("data", onChunk);
    stream.on("end", resolve);
  });
}
__name(readNodeChunks, "readNodeChunks");
async function readStandardChunks(stream, onChunk) {
  const reader = stream.getReader();
  let readResult = await reader.read();
  while (!readResult.done) {
    onChunk(readResult.value);
    readResult = await reader.read();
  }
}
__name(readStandardChunks, "readStandardChunks");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/double-indexed-kv.js
var DoubleIndexedKV = (
  /** @class */
  function() {
    function DoubleIndexedKV2() {
      this.keyToValue = /* @__PURE__ */ new Map();
      this.valueToKey = /* @__PURE__ */ new Map();
    }
    __name(DoubleIndexedKV2, "DoubleIndexedKV");
    DoubleIndexedKV2.prototype.set = function(key, value) {
      this.keyToValue.set(key, value);
      this.valueToKey.set(value, key);
    };
    DoubleIndexedKV2.prototype.getByKey = function(key) {
      return this.keyToValue.get(key);
    };
    DoubleIndexedKV2.prototype.getByValue = function(value) {
      return this.valueToKey.get(value);
    };
    DoubleIndexedKV2.prototype.clear = function() {
      this.keyToValue.clear();
      this.valueToKey.clear();
    };
    return DoubleIndexedKV2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/registry.js
var Registry = (
  /** @class */
  function() {
    function Registry2(generateIdentifier) {
      this.generateIdentifier = generateIdentifier;
      this.kv = new DoubleIndexedKV();
    }
    __name(Registry2, "Registry");
    Registry2.prototype.register = function(value, identifier) {
      if (this.kv.getByValue(value)) {
        return;
      }
      if (!identifier) {
        identifier = this.generateIdentifier(value);
      }
      this.kv.set(identifier, value);
    };
    Registry2.prototype.clear = function() {
      this.kv.clear();
    };
    Registry2.prototype.getIdentifier = function(value) {
      return this.kv.getByValue(value);
    };
    Registry2.prototype.getValue = function(identifier) {
      return this.kv.getByKey(identifier);
    };
    return Registry2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/class-registry.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = /* @__PURE__ */ __name(function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  }, "extendStatics");
  return function(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    __name(__, "__");
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ClassRegistry = (
  /** @class */
  function(_super) {
    __extends(ClassRegistry2, _super);
    function ClassRegistry2() {
      var _this = _super.call(this, function(c) {
        return c.name;
      }) || this;
      _this.classToAllowedProps = /* @__PURE__ */ new Map();
      return _this;
    }
    __name(ClassRegistry2, "ClassRegistry");
    ClassRegistry2.prototype.register = function(value, options) {
      if (typeof options === "object") {
        if (options.allowProps) {
          this.classToAllowedProps.set(value, options.allowProps);
        }
        _super.prototype.register.call(this, value, options.identifier);
      } else {
        _super.prototype.register.call(this, value, options);
      }
    };
    ClassRegistry2.prototype.getAllowedProps = function(value) {
      return this.classToAllowedProps.get(value);
    };
    return ClassRegistry2;
  }(Registry)
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/util.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  var values = [];
  for (var key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
__name(valuesOfObj, "valuesOfObj");
function find(record, predicate) {
  var values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  var valuesNotNever = values;
  for (var i = 0; i < valuesNotNever.length; i++) {
    var value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
__name(find, "find");
function forEach(record, run) {
  Object.entries(record).forEach(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    return run(value, key);
  });
}
__name(forEach, "forEach");
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
__name(includes, "includes");
function findArr(record, predicate) {
  for (var i = 0; i < record.length; i++) {
    var value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
__name(findArr, "findArr");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/custom-transformer-registry.js
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function CustomTransformerRegistry2() {
      this.transfomers = {};
    }
    __name(CustomTransformerRegistry2, "CustomTransformerRegistry");
    CustomTransformerRegistry2.prototype.register = function(transformer) {
      this.transfomers[transformer.name] = transformer;
    };
    CustomTransformerRegistry2.prototype.findApplicable = function(v) {
      return find(this.transfomers, function(transformer) {
        return transformer.isApplicable(v);
      });
    };
    CustomTransformerRegistry2.prototype.findByName = function(name) {
      return this.transfomers[name];
    };
    return CustomTransformerRegistry2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/is.js
var getType = /* @__PURE__ */ __name(function(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}, "getType");
var isUndefined = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "undefined";
}, "isUndefined");
var isNull = /* @__PURE__ */ __name(function(payload) {
  return payload === null;
}, "isNull");
var isPlainObject = /* @__PURE__ */ __name(function(payload) {
  if (typeof payload !== "object" || payload === null) return false;
  if (payload === Object.prototype) return false;
  if (Object.getPrototypeOf(payload) === null) return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
}, "isPlainObject");
var isEmptyObject = /* @__PURE__ */ __name(function(payload) {
  return isPlainObject(payload) && Object.keys(payload).length === 0;
}, "isEmptyObject");
var isArray = /* @__PURE__ */ __name(function(payload) {
  return Array.isArray(payload);
}, "isArray");
var isString = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "string";
}, "isString");
var isNumber = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "number" && !isNaN(payload);
}, "isNumber");
var isBoolean = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "boolean";
}, "isBoolean");
var isRegExp = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof RegExp;
}, "isRegExp");
var isMap = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Map;
}, "isMap");
var isSet = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Set;
}, "isSet");
var isSymbol = /* @__PURE__ */ __name(function(payload) {
  return getType(payload) === "Symbol";
}, "isSymbol");
var isDate = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Date && !isNaN(payload.valueOf());
}, "isDate");
var isError = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Error;
}, "isError");
var isNaNValue = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "number" && isNaN(payload);
}, "isNaNValue");
var isPrimitive = /* @__PURE__ */ __name(function(payload) {
  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
}, "isPrimitive");
var isBigint = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "bigint";
}, "isBigint");
var isInfinite = /* @__PURE__ */ __name(function(payload) {
  return payload === Infinity || payload === -Infinity;
}, "isInfinite");
var isTypedArray = /* @__PURE__ */ __name(function(payload) {
  return ArrayBuffer.isView(payload) && !(payload instanceof DataView);
}, "isTypedArray");
var isURL = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof URL;
}, "isURL");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/pathstringifier.js
var escapeKey = /* @__PURE__ */ __name(function(key) {
  return key.replace(/\./g, "\\.");
}, "escapeKey");
var stringifyPath = /* @__PURE__ */ __name(function(path) {
  return path.map(String).map(escapeKey).join(".");
}, "stringifyPath");
var parsePath = /* @__PURE__ */ __name(function(string) {
  var result = [];
  var segment = "";
  for (var i = 0; i < string.length; i++) {
    var char = string.charAt(i);
    var isEscapedDot = char === "\\" && string.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    var isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  var lastSegment = segment;
  result.push(lastSegment);
  return result;
}, "parsePath");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/transformer.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
};
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
__name(simpleTransformation, "simpleTransformation");
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", function() {
    return null;
  }, function() {
    return void 0;
  }),
  simpleTransformation(isBigint, "bigint", function(v) {
    return v.toString();
  }, function(v) {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", function(v) {
    return v.toISOString();
  }, function(v) {
    return new Date(v);
  }),
  simpleTransformation(isError, "Error", function(v, superJson) {
    var baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach(function(prop) {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, function(v, superJson) {
    var e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach(function(prop) {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", function(v) {
    return "" + v;
  }, function(regex) {
    var body = regex.slice(1, regex.lastIndexOf("/"));
    var flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(v) {
      return __spreadArray([], __read2(v.values()));
    },
    function(v) {
      return new Set(v);
    }
  ),
  simpleTransformation(isMap, "map", function(v) {
    return __spreadArray([], __read2(v.entries()));
  }, function(v) {
    return new Map(v);
  }),
  simpleTransformation(function(v) {
    return isNaNValue(v) || isInfinite(v);
  }, "number", function(v) {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation(function(v) {
    return v === 0 && 1 / v === -Infinity;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(v) {
    return v.toString();
  }, function(v) {
    return new URL(v);
  })
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
__name(compositeTransformation, "compositeTransformation");
var symbolRule = compositeTransformation(function(s, superJson) {
  if (isSymbol(s)) {
    var isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, function(s, superJson) {
  var identifier = superJson.symbolRegistry.getIdentifier(s);
  return [
    "symbol",
    identifier
  ];
}, function(v) {
  return v.description;
}, function(_, a, superJson) {
  var value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(obj, ctor) {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, function(v) {
  return [
    "typed-array",
    v.constructor.name
  ];
}, function(v) {
  return __spreadArray([], __read2(v));
}, function(v, a) {
  var ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {
    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
__name(isInstanceOfRegisteredClass, "isInstanceOfRegisteredClass");
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(clazz, superJson) {
  var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return [
    "class",
    identifier
  ];
}, function(clazz, superJson) {
  var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return __assign({}, clazz);
  }
  var result = {};
  allowedProps.forEach(function(prop) {
    result[prop] = clazz[prop];
  });
  return result;
}, function(v, a, superJson) {
  var clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation(function(value, superJson) {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return [
    "custom",
    transformer.name
  ];
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, function(v, a, superJson) {
  var transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [
  classRule,
  symbolRule,
  customRule,
  typedArrayRule
];
var transformValue = /* @__PURE__ */ __name(function(value, superJson) {
  var applicableCompositeRule = findArr(compositeRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  var applicableSimpleRule = findArr(simpleRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
}, "transformValue");
var simpleRulesByAnnotation = {};
simpleRules.forEach(function(rule) {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = /* @__PURE__ */ __name(function(json, type, superJson) {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    var transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
}, "untransformValue");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/accessDeep.js
var getNthKey = /* @__PURE__ */ __name(function(value, n) {
  var keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
}, "getNthKey");
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
__name(validatePath, "validatePath");
var getDeep = /* @__PURE__ */ __name(function(object, path) {
  validatePath(path);
  for (var i = 0; i < path.length; i++) {
    var key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      var row = +key;
      var type = +path[++i] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
}, "getDeep");
var setDeep = /* @__PURE__ */ __name(function(object, path, mapper) {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  var parent = object;
  for (var i = 0; i < path.length - 1; i++) {
    var key = path[i];
    if (isArray(parent)) {
      var index = +key;
      parent = parent[index];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      var row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      var isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      var row = +key;
      var type = +path[++i] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  var lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    var oldValue = getNthKey(parent, +lastKey);
    var newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent["delete"](oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    var row = +path[path.length - 2];
    var keyToRow = getNthKey(parent, row);
    var type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        var newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent["delete"](keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
}, "setDeep");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/plainer.js
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
};
function traverse(tree, walker2, origin) {
  if (origin === void 0) {
    origin = [];
  }
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, function(subtree, key) {
      return traverse(subtree, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
    return;
  }
  var _a = __read3(tree, 2), nodeValue = _a[0], children = _a[1];
  if (children) {
    forEach(children, function(child, key) {
      traverse(child, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
  }
  walker2(nodeValue, origin);
}
__name(traverse, "traverse");
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, function(type, path) {
    plain = setDeep(plain, path, function(v) {
      return untransformValue(v, type, superJson);
    });
  });
  return plain;
}
__name(applyValueAnnotations, "applyValueAnnotations");
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    var object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach(function(identicalObjectPath) {
      plain = setDeep(plain, identicalObjectPath, function() {
        return object;
      });
    });
  }
  __name(apply, "apply");
  if (isArray(annotations)) {
    var _a = __read3(annotations, 2), root = _a[0], other = _a[1];
    root.forEach(function(identicalPath) {
      plain = setDeep(plain, parsePath(identicalPath), function() {
        return plain;
      });
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
__name(applyReferentialEqualityAnnotations, "applyReferentialEqualityAnnotations");
var isDeep = /* @__PURE__ */ __name(function(object, superJson) {
  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
}, "isDeep");
function addIdentity(object, path, identities) {
  var existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [
      path
    ]);
  }
}
__name(addIdentity, "addIdentity");
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  var result = {};
  var rootEqualityPaths = void 0;
  identitites.forEach(function(paths) {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map(function(path) {
        return path.map(String);
      }).sort(function(a, b) {
        return a.length - b.length;
      });
    }
    var _a = __read3(paths), representativePath = _a[0], identicalPaths = _a.slice(1);
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [
        rootEqualityPaths
      ];
    } else {
      return [
        rootEqualityPaths,
        result
      ];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
__name(generateReferentialEqualityAnnotations, "generateReferentialEqualityAnnotations");
var walker = /* @__PURE__ */ __name(function(object, identities, superJson, dedupe, path, objectsInThisPath, seenObjects) {
  var _a;
  if (path === void 0) {
    path = [];
  }
  if (objectsInThisPath === void 0) {
    objectsInThisPath = [];
  }
  if (seenObjects === void 0) {
    seenObjects = /* @__PURE__ */ new Map();
  }
  var primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    var seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    var transformed_1 = transformValue(object, superJson);
    var result_1 = transformed_1 ? {
      transformedValue: transformed_1.value,
      annotations: [
        transformed_1.type
      ]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result_1);
    }
    return result_1;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  var transformationResult = transformValue(object, superJson);
  var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;
  var transformedValue = isArray(transformed) ? [] : {};
  var innerAnnotations = {};
  forEach(transformed, function(value, index) {
    var recursiveResult = walker(value, identities, superJson, dedupe, __spreadArray2(__spreadArray2([], __read3(path)), [
      index
    ]), __spreadArray2(__spreadArray2([], __read3(objectsInThisPath)), [
      object
    ]), seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, function(tree, key) {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  var result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [
      transformationResult.type
    ] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [
      transformationResult.type,
      innerAnnotations
    ] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
}, "walker");

// ../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
__name(getType2, "getType");
function isArray2(payload) {
  return getType2(payload) === "Array";
}
__name(isArray2, "isArray");
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object") return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
__name(isPlainObject2, "isPlainObject");
function isNull2(payload) {
  return getType2(payload) === "Null";
}
__name(isNull2, "isNull");
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}
__name(isOneOf, "isOneOf");
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
__name(isUndefined2, "isUndefined");

// ../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable") carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
__name(assignProp, "assignProp");
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [
    ...props,
    ...symbols
  ].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}
__name(copy, "copy");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
};
var SuperJSON = (
  /** @class */
  function() {
    function SuperJSON2(_a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.dedupe, dedupe = _c === void 0 ? false : _c;
      this.classRegistry = new ClassRegistry();
      this.symbolRegistry = new Registry(function(s) {
        var _a2;
        return (_a2 = s.description) !== null && _a2 !== void 0 ? _a2 : "";
      });
      this.customTransformerRegistry = new CustomTransformerRegistry();
      this.allowedErrorProps = [];
      this.dedupe = dedupe;
    }
    __name(SuperJSON2, "SuperJSON");
    SuperJSON2.prototype.serialize = function(object) {
      var identities = /* @__PURE__ */ new Map();
      var output = walker(object, identities, this, this.dedupe);
      var res = {
        json: output.transformedValue
      };
      if (output.annotations) {
        res.meta = __assign2(__assign2({}, res.meta), {
          values: output.annotations
        });
      }
      var equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
      if (equalityAnnotations) {
        res.meta = __assign2(__assign2({}, res.meta), {
          referentialEqualities: equalityAnnotations
        });
      }
      return res;
    };
    SuperJSON2.prototype.deserialize = function(payload) {
      var json = payload.json, meta = payload.meta;
      var result = copy(json);
      if (meta === null || meta === void 0 ? void 0 : meta.values) {
        result = applyValueAnnotations(result, meta.values, this);
      }
      if (meta === null || meta === void 0 ? void 0 : meta.referentialEqualities) {
        result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
      }
      return result;
    };
    SuperJSON2.prototype.stringify = function(object) {
      return JSON.stringify(this.serialize(object));
    };
    SuperJSON2.prototype.parse = function(string) {
      return this.deserialize(JSON.parse(string));
    };
    SuperJSON2.prototype.registerClass = function(v, options) {
      this.classRegistry.register(v, options);
    };
    SuperJSON2.prototype.registerSymbol = function(v, identifier) {
      this.symbolRegistry.register(v, identifier);
    };
    SuperJSON2.prototype.registerCustom = function(transformer, name) {
      this.customTransformerRegistry.register(__assign2({
        name
      }, transformer));
    };
    SuperJSON2.prototype.allowErrorProps = function() {
      var _a;
      var props = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        props[_i] = arguments[_i];
      }
      (_a = this.allowedErrorProps).push.apply(_a, __spreadArray3([], __read4(props)));
    };
    SuperJSON2.defaultInstance = new SuperJSON2();
    SuperJSON2.serialize = SuperJSON2.defaultInstance.serialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.deserialize = SuperJSON2.defaultInstance.deserialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.stringify = SuperJSON2.defaultInstance.stringify.bind(SuperJSON2.defaultInstance);
    SuperJSON2.parse = SuperJSON2.defaultInstance.parse.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerClass = SuperJSON2.defaultInstance.registerClass.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerSymbol = SuperJSON2.defaultInstance.registerSymbol.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerCustom = SuperJSON2.defaultInstance.registerCustom.bind(SuperJSON2.defaultInstance);
    SuperJSON2.allowErrorProps = SuperJSON2.defaultInstance.allowErrorProps.bind(SuperJSON2.defaultInstance);
    return SuperJSON2;
  }()
);
var esm_default = SuperJSON;
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;

// ../shared/src/rpc/utils.ts
var MAX_SWAP_AMOUNT = 2n ** 128n - 1n;
var validateSwapAmount = /* @__PURE__ */ __name((env, asset, amount) => {
  const minimumAmount = readChainAssetValue(env.ingressEgress.minimumDepositAmounts, asset);
  if (amount < minimumAmount) {
    return {
      success: false,
      reason: `expected amount is below minimum swap amount (${minimumAmount})`
    };
  }
  const maxAmount = readChainAssetValue(env.swapping.maximumSwapAmounts, asset) ?? MAX_SWAP_AMOUNT;
  if (maxAmount != null && amount > maxAmount) {
    return {
      success: false,
      reason: `expected amount is above maximum swap amount (${maxAmount})`
    };
  }
  return {
    success: true
  };
}, "validateSwapAmount");

// ../shared/src/evm.ts
var assertIsEvmChain = /* @__PURE__ */ __name((chain) => {
  const evmChainId = getEvmChainId(chain, ChainflipNetworks.backspin);
  assert(evmChainId, `Chain ${chain} is not an evm chain`);
}, "assertIsEvmChain");
var assertSignerIsConnectedToChain = /* @__PURE__ */ __name(async (opts, chain) => {
  if (opts.network === "localnet") return;
  assert(opts.signer.provider, "Signer has no provider");
  const sourceChainId = getEvmChainId(chain, opts.network);
  assert(sourceChainId, `Chain ${chain} has no evm chain id`);
  const { chainId: signerChainId } = await opts.signer.provider.getNetwork();
  assert(signerChainId === BigInt(sourceChainId), `Signer is connected to unexpected evm chain (expected: ${sourceChainId}, got: ${signerChainId})`);
}, "assertSignerIsConnectedToChain");

// ../shared/src/vault/executeSwap.ts
var encodeAddress = /* @__PURE__ */ __name((chain, address) => {
  if (chain === Chains.Polkadot) return bytesToHex(ss58.decode(dotAddress.parse(address)).data);
  if (chain === Chains.Bitcoin) return `0x${Buffer.from(address).toString("hex")}`;
  if (chain === Chains.Ethereum || chain === Chains.Arbitrum) return address;
  throw new Error(`cannot encode address for chain ${chain}`);
}, "encodeAddress");
var assertIsValidSwap = /* @__PURE__ */ __name((params) => {
  const { srcAsset, destAsset } = getInternalAssets(params);
  assert(srcAsset !== destAsset, "source asset and destination asset cannot be the same");
}, "assertIsValidSwap");
var getVaultContract = /* @__PURE__ */ __name((chain, networkOpts) => {
  const vaultContractAddress = networkOpts.network === "localnet" ? networkOpts.vaultContractAddress : getVaultContractAddress(chain, networkOpts.network);
  return {
    vaultContract: Vault__factory.connect(vaultContractAddress, networkOpts.signer),
    vaultAddress: vaultContractAddress
  };
}, "getVaultContract");
var getErc20Address = /* @__PURE__ */ __name((asset, networkOpts) => {
  const erc20Address = networkOpts.network === "localnet" ? networkOpts.srcTokenContractAddress : getTokenContractAddress(asset, networkOpts.network);
  assert(erc20Address !== void 0, `Missing ERC20 contract address for ${asset}`);
  return erc20Address;
}, "getErc20Address");
var swapNative = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const destAsset = getInternalAsset({
    chain: params.destChain,
    asset: params.destAsset
  });
  const { vaultContract: vault } = getVaultContract(params.srcChain, networkOpts);
  const transaction = await vault.xSwapNative(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, "0x", {
    value: params.amount,
    ...extractOverrides(txOpts)
  });
  await transaction.wait(txOpts.wait);
  return transaction;
}, "swapNative");
var swapToken = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const { srcAsset, destAsset } = getInternalAssets(params);
  const { vaultContract: vault, vaultAddress } = getVaultContract(params.srcChain, networkOpts);
  const erc20Address = getErc20Address(srcAsset, networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(BigInt(params.amount), vaultAddress, erc20Address, networkOpts.signer);
  assert(hasSufficientAllowance, "Swap amount exceeds allowance");
  const transaction = await vault.xSwapToken(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, erc20Address, params.amount, "0x", extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "swapToken");
var callNative = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const destAsset = getInternalAsset({
    chain: params.destChain,
    asset: params.destAsset
  });
  const { vaultContract: vault } = getVaultContract(params.srcChain, networkOpts);
  const transaction = await vault.xCallNative(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, params.ccmMetadata.message, params.ccmMetadata.gasBudget, "0x", {
    value: params.amount,
    ...extractOverrides(txOpts)
  });
  await transaction.wait(txOpts.wait);
  return transaction;
}, "callNative");
var callToken = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const { srcAsset, destAsset } = getInternalAssets(params);
  const { vaultContract: vault, vaultAddress } = getVaultContract(params.srcChain, networkOpts);
  const erc20Address = getErc20Address(srcAsset, networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(BigInt(params.amount), vaultAddress, erc20Address, networkOpts.signer);
  assert(hasSufficientAllowance, "Swap amount exceeds allowance");
  const transaction = await vault.xCallToken(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, params.ccmMetadata.message, params.ccmMetadata.gasBudget, erc20Address, params.amount, "0x", extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "callToken");
var executeSwap = /* @__PURE__ */ __name(async ({ ccmMetadata: unvalidatedCcmMetadata, ...params }, networkOpts, txOpts) => {
  assertIsValidSwap(params);
  assertIsEvmChain(params.srcChain);
  assertValidAddress(params.destChain, params.destAddress, networkOpts.network);
  await assertSignerIsConnectedToChain(networkOpts, params.srcChain);
  if (unvalidatedCcmMetadata) {
    assertIsEvmChain(params.destChain);
    const ccmMetadata = ccmMetadataSchema.parse(unvalidatedCcmMetadata);
    return params.srcAsset === chainConstants[params.srcChain].gasAsset ? callNative({
      ...params,
      ccmMetadata
    }, networkOpts, txOpts) : callToken({
      ...params,
      ccmMetadata
    }, networkOpts, txOpts);
  }
  return params.srcAsset === chainConstants[params.srcChain].gasAsset ? swapNative(params, networkOpts, txOpts) : swapToken(params, networkOpts, txOpts);
}, "executeSwap");
var executeSwap_default = executeSwap;

// ../shared/src/vault/approval.ts
var checkVaultAllowance = /* @__PURE__ */ __name((params, networkOpts) => {
  const erc20Address = networkOpts.network === "localnet" ? networkOpts.srcTokenContractAddress : getTokenContractAddress(getInternalAsset({
    chain: params.srcChain,
    asset: params.srcAsset
  }), networkOpts.network);
  assert(erc20Address !== void 0, "Missing ERC20 contract address");
  const vaultContractAddress = networkOpts.network === "localnet" ? networkOpts.vaultContractAddress : getVaultContractAddress(params.srcChain, networkOpts.network);
  return checkAllowance(BigInt(params.amount), vaultContractAddress, erc20Address, networkOpts.signer);
}, "checkVaultAllowance");
var approveVault = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  await assertSignerIsConnectedToChain(networkOpts, params.srcChain);
  const { hasSufficientAllowance, erc20, allowance } = await checkVaultAllowance(params, networkOpts);
  if (hasSufficientAllowance) return null;
  const vaultContractAddress = networkOpts.network === "localnet" ? networkOpts.vaultContractAddress : getVaultContractAddress(params.srcChain, networkOpts.network);
  return approve(BigInt(params.amount), vaultContractAddress, erc20, allowance, txOpts);
}, "approveVault");

// src/swap/assets.ts
var isGasAsset = /* @__PURE__ */ __name((asset) => {
  const { chain } = assetConstants[asset];
  return assetConstants[asset].asset === chainConstants[chain].gasAsset;
}, "isGasAsset");
var getAssetData = /* @__PURE__ */ __name((asset, network, env) => {
  const assetConstant = assetConstants[asset];
  return {
    chainflipId: asset,
    asset: assetConstant.asset,
    chain: assetConstant.chain,
    contractAddress: !isGasAsset(asset) ? getTokenContractAddress(asset, network) : void 0,
    decimals: assetConstant.decimals,
    name: assetConstant.name,
    symbol: assetConstant.asset,
    isMainnet: !isTestnet(network),
    minimumSwapAmount: readChainAssetValue(env.ingressEgress.minimumDepositAmounts, asset).toString(),
    maximumSwapAmount: readChainAssetValue(env.swapping.maximumSwapAmounts, asset)?.toString() ?? null,
    minimumEgressAmount: readChainAssetValue(env.ingressEgress.minimumEgressAmounts, asset).toString()
  };
}, "getAssetData");

// src/swap/chains.ts
var getChainData = /* @__PURE__ */ __name((chain, network, env) => ({
  chain,
  name: chain,
  evmChainId: getEvmChainId(chain, network),
  isMainnet: !isTestnet(network),
  requiredBlockConfirmations: isNotNullish(env.ingressEgress.witnessSafetyMargins[chain]) ? Number(env.ingressEgress.witnessSafetyMargins[chain]) + 1 : void 0
}), "getChainData");

// src/swap/consts.ts
var BACKEND_SERVICE_URLS = {
  [ChainflipNetworks.backspin]: "https://chainflip-swap-backspin.staging/",
  [ChainflipNetworks.sisyphos]: "https://chainflip-swap.staging/",
  [ChainflipNetworks.perseverance]: "https://chainflip-swap-perseverance.chainflip.io/",
  [ChainflipNetworks.mainnet]: "https://chainflip-swap.chainflip.io/"
};
var getQuote = /* @__PURE__ */ __name(async (baseUrl, quoteRequest, { signal }) => {
  const { brokerCommissionBps, ...returnedRequestData } = quoteRequest;
  const params = {
    amount: returnedRequestData.amount,
    srcChain: returnedRequestData.srcChain,
    srcAsset: returnedRequestData.srcAsset,
    destChain: returnedRequestData.destChain,
    destAsset: returnedRequestData.destAsset,
    ...brokerCommissionBps && {
      brokerCommissionBps: String(brokerCommissionBps)
    }
  };
  const queryParams = new URLSearchParams(params);
  const url = new URL(`/quote?${queryParams.toString()}`, baseUrl).toString();
  const { data } = await axios.get(url, {
    signal
  });
  return {
    ...returnedRequestData,
    quote: data
  };
}, "getQuote");
var getStatus = /* @__PURE__ */ __name(async (baseUrl, { id }, { signal }) => {
  const url = new URL(`/swaps/${id}`, baseUrl).toString();
  const { data } = await axios.get(url, {
    signal
  });
  return data;
}, "getStatus");

// src/swap/sdk.ts
var _SwapSDK = class _SwapSDK {
  constructor(options = {}) {
    __publicField(this, "options");
    __publicField(this, "rpcConfig");
    __publicField(this, "trpc");
    __publicField(this, "stateChainEnvironment");
    __publicField(this, "supportedAssets");
    const network = options.network ?? ChainflipNetworks.perseverance;
    this.options = {
      ...options,
      network,
      backendUrl: options.backendUrl ?? BACKEND_SERVICE_URLS[network]
    };
    this.rpcConfig = options.rpcUrl ? {
      rpcUrl: options.rpcUrl
    } : {
      network
    };
    this.trpc = createTRPCProxyClient({
      transformer: esm_default,
      links: [
        httpBatchLink({
          url: new URL("/trpc", this.options.backendUrl)
        })
      ]
    });
  }
  async getChains(sourceChain) {
    if (sourceChain && !(sourceChain in Chains)) throw new Error(`unsupported source chain "${sourceChain}"`);
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets()
    ]);
    const supportedChains = [
      ...new Set(supportedAssets.map((a) => assetConstants[a].chain))
    ];
    return supportedChains.map((chain) => getChainData(chain, this.options.network, env)).filter((chain) => chain.chain !== sourceChain);
  }
  async getStateChainEnvironment() {
    this.stateChainEnvironment ?? (this.stateChainEnvironment = await getEnvironment(this.rpcConfig));
    return this.stateChainEnvironment;
  }
  async getSupportedAssets() {
    this.supportedAssets ?? (this.supportedAssets = (await getSupportedAssets(this.rpcConfig)).map((asset) => getInternalAsset(asset, false)).filter(isNotNullish));
    return this.supportedAssets;
  }
  async getBoostPoolsDepth() {
    return getAllBoostPoolsDepth(this.rpcConfig);
  }
  async getAssets(chain) {
    if (chain && !(chain in Chains)) throw new Error(`unsupported chain "${chain}"`);
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets()
    ]);
    return supportedAssets.map((asset) => getAssetData(asset, this.options.network, env)).filter((asset) => !chain || asset.chain === chain);
  }
  getQuote(quoteRequest, options = {}) {
    const { brokerCommissionBps, affiliateBrokers, ...remainingRequest } = quoteRequest;
    const submitterBrokerCommissionBps = brokerCommissionBps ?? this.options.broker?.commissionBps ?? 0;
    const affiliateBrokerCommissionBps = affiliateBrokers?.reduce((acc, affiliate) => acc + affiliate.commissionBps, 0) ?? 0;
    return getQuote(this.options.backendUrl, {
      ...remainingRequest,
      brokerCommissionBps: submitterBrokerCommissionBps + affiliateBrokerCommissionBps
    }, options);
  }
  async requestDepositAddress(depositAddressRequest) {
    const { srcChain, srcAsset, amount, brokerCommissionBps, affiliateBrokers } = depositAddressRequest;
    await this.validateSwapAmount({
      chain: srcChain,
      asset: srcAsset
    }, BigInt(amount));
    let response;
    if (this.options.broker !== void 0) {
      const { requestSwapDepositAddress } = await import('./broker-PBJJVRH4.mjs');
      const result = await requestSwapDepositAddress({
        ...depositAddressRequest,
        commissionBps: brokerCommissionBps ?? this.options.broker.commissionBps,
        affiliates: affiliateBrokers
      }, {
        url: this.options.broker.url
      }, this.options.network);
      response = {
        id: `${result.issuedBlock}-${depositAddressRequest.srcChain}-${result.channelId}`,
        depositAddress: result.address,
        brokerCommissionBps: this.options.broker.commissionBps,
        srcChainExpiryBlock: result.sourceChainExpiryBlock,
        maxBoostFeeBps: depositAddressRequest.maxBoostFeeBps,
        channelOpeningFee: result.channelOpeningFee
      };
    } else {
      assert(!depositAddressRequest.brokerCommissionBps, "Broker commission is only supported only when initializing the SDK with a brokerUrl");
      assert(!depositAddressRequest.affiliateBrokers?.length, "Affiliate brokers are supported only when initializing the SDK with a brokerUrl");
      response = await this.trpc.openSwapDepositChannel.mutate(depositAddressRequest);
    }
    return {
      ...depositAddressRequest,
      depositChannelId: response.id,
      depositAddress: response.depositAddress,
      brokerCommissionBps: response.brokerCommissionBps,
      affiliateBrokers: depositAddressRequest.affiliateBrokers ?? [],
      maxBoostFeeBps: Number(response.maxBoostFeeBps) || 0,
      depositChannelExpiryBlock: response.srcChainExpiryBlock,
      estimatedDepositChannelExpiryTime: response.estimatedExpiryTime,
      channelOpeningFee: response.channelOpeningFee
    };
  }
  getStatus(swapStatusRequest, options = {}) {
    return getStatus(this.options.backendUrl, swapStatusRequest, options);
  }
  async executeSwap(params, txOpts = {}) {
    const { srcChain, srcAsset, amount } = params;
    const { signer: optsSigner, ...remainingTxOpts } = txOpts;
    const signer = optsSigner ?? this.options.signer;
    assert(signer, "No signer provided");
    await this.validateSwapAmount({
      chain: srcChain,
      asset: srcAsset
    }, BigInt(amount));
    const tx = await executeSwap_default(params, {
      network: this.options.network,
      signer
    }, remainingTxOpts);
    return tx.hash;
  }
  async approveVault(params, txOpts = {}) {
    const { signer: optsSigner, ...remainingTxOpts } = txOpts;
    const signer = optsSigner ?? this.options.signer;
    assert(signer, "No signer provided");
    const tx = await approveVault(params, {
      signer,
      network: this.options.network
    }, remainingTxOpts);
    return tx ? tx.hash : null;
  }
  async validateSwapAmount(asset, amount) {
    const stateChainEnv = await this.getStateChainEnvironment();
    const internalAsset = getInternalAsset(asset);
    const result = validateSwapAmount(stateChainEnv, internalAsset, amount);
    if (!result.success) throw new Error(result.reason);
  }
  async getSwapLimits() {
    const { swapping: { maximumSwapAmounts }, ingressEgress: { minimumDepositAmounts } } = await this.getStateChainEnvironment();
    return {
      minimumSwapAmounts: minimumDepositAmounts,
      maximumSwapAmounts
    };
  }
  async getRequiredBlockConfirmations() {
    const { ingressEgress: { witnessSafetyMargins } } = await this.getStateChainEnvironment();
    return Object.keys(Chains).reduce((acc, chain) => {
      acc[chain] = witnessSafetyMargins[chain] ? Number(witnessSafetyMargins[chain]) + 1 : null;
      return acc;
    }, {});
  }
  async getChannelOpeningFees() {
    const { ingressEgress: { channelOpeningFees } } = await this.getStateChainEnvironment();
    return channelOpeningFees;
  }
  async getBoostLiquidity({ chainAsset, feeTierBps } = {}) {
    let poolsDepth = await this.getBoostPoolsDepth();
    if (chainAsset) {
      const internalAsset = getInternalAsset(chainAsset);
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.asset === internalAsset).sort((a, b) => b.tier - a.tier);
    }
    if (feeTierBps) {
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.tier === feeTierBps);
    }
    return poolsDepth.map((depth) => ({
      availableAmount: depth.availableAmount,
      feeTierBps: depth.tier,
      ...getAssetAndChain(depth.asset)
    }));
  }
};
__name(_SwapSDK, "SwapSDK");
var SwapSDK = _SwapSDK;
/*! Bundled license information:

@trpc/client/dist/httpUtils-b9d0cb48.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)
*/

export { SwapSDK };
