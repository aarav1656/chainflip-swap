import { __name, isString, InternalAssets, Chains, Assets, ChainflipNetworks, isValidAssetAndChain, getInternalAssets, assert } from './chunk-3V7QJANN.mjs';
import * as ss582 from '@chainflip/utils/ss58';
import '@chainflip/utils/string';
import * as ethers from 'ethers';

// ../../node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  __name(assertIs, "assertIs");
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  __name(assertNever, "assertNever");
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues, "joinValues");
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = /* @__PURE__ */ __name((obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, "quotelessJson");
var _ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
__name(_ZodError, "ZodError");
var ZodError = _ZodError;
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, "errorMap");
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
__name(addIssueToContext, "addIssueToContext");
var _ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
__name(_ParseStatus, "ParseStatus");
var ParseStatus = _ParseStatus;
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
var OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var _ParseInputLazyPath = class _ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
__name(_ParseInputLazyPath, "ParseInputLazyPath");
var ParseInputLazyPath = _ParseInputLazyPath;
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap3, invalid_type_error, required_error, description } = params;
  if (errorMap3 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap3)
    return { errorMap: errorMap3, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var _ZodType = class _ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
__name(_ZodType, "ZodType");
var ZodType = _ZodType;
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
var _ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodString, "ZodString");
var ZodString = _ZodString;
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
__name(floatSafeRemainder, "floatSafeRemainder");
var _ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
__name(_ZodNumber, "ZodNumber");
var ZodNumber = _ZodNumber;
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var _ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
__name(_ZodBigInt, "ZodBigInt");
var ZodBigInt = _ZodBigInt;
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var _ZodBoolean = class _ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(_ZodBoolean, "ZodBoolean");
var ZodBoolean = _ZodBoolean;
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var _ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
__name(_ZodDate, "ZodDate");
var ZodDate = _ZodDate;
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var _ZodSymbol = class _ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(_ZodSymbol, "ZodSymbol");
var ZodSymbol = _ZodSymbol;
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var _ZodUndefined = class _ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(_ZodUndefined, "ZodUndefined");
var ZodUndefined = _ZodUndefined;
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var _ZodNull = class _ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(_ZodNull, "ZodNull");
var ZodNull = _ZodNull;
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var _ZodAny = class _ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
__name(_ZodAny, "ZodAny");
var ZodAny = _ZodAny;
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var _ZodUnknown = class _ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
__name(_ZodUnknown, "ZodUnknown");
var ZodUnknown = _ZodUnknown;
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var _ZodNever = class _ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
__name(_ZodNever, "ZodNever");
var ZodNever = _ZodNever;
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var _ZodVoid = class _ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
__name(_ZodVoid, "ZodVoid");
var ZodVoid = _ZodVoid;
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var _ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
__name(_ZodArray, "ZodArray");
var ZodArray = _ZodArray;
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var _ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
__name(_ZodObject, "ZodObject");
var ZodObject = _ZodObject;
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var _ZodUnion = class _ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
__name(_ZodUnion, "ZodUnion");
var ZodUnion = _ZodUnion;
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var _ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
__name(_ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
var ZodDiscriminatedUnion = _ZodDiscriminatedUnion;
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var _ZodIntersection = class _ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
__name(_ZodIntersection, "ZodIntersection");
var ZodIntersection = _ZodIntersection;
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var _ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
__name(_ZodTuple, "ZodTuple");
var ZodTuple = _ZodTuple;
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var _ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
__name(_ZodRecord, "ZodRecord");
var ZodRecord = _ZodRecord;
var _ZodMap = class _ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
__name(_ZodMap, "ZodMap");
var ZodMap = _ZodMap;
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var _ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
__name(_ZodSet, "ZodSet");
var ZodSet = _ZodSet;
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var _ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
__name(_ZodFunction, "ZodFunction");
var ZodFunction = _ZodFunction;
var _ZodLazy = class _ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
__name(_ZodLazy, "ZodLazy");
var ZodLazy = _ZodLazy;
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var _ZodLiteral = class _ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
__name(_ZodLiteral, "ZodLiteral");
var ZodLiteral = _ZodLiteral;
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var _ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues2 = {};
    for (const val of this._def.values) {
      enumValues2[val] = val;
    }
    return enumValues2;
  }
  get Values() {
    const enumValues2 = {};
    for (const val of this._def.values) {
      enumValues2[val] = val;
    }
    return enumValues2;
  }
  get Enum() {
    const enumValues2 = {};
    for (const val of this._def.values) {
      enumValues2[val] = val;
    }
    return enumValues2;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
__name(_ZodEnum, "ZodEnum");
var ZodEnum = _ZodEnum;
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var _ZodNativeEnum = class _ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
__name(_ZodNativeEnum, "ZodNativeEnum");
var ZodNativeEnum = _ZodNativeEnum;
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var _ZodPromise = class _ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
__name(_ZodPromise, "ZodPromise");
var ZodPromise = _ZodPromise;
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var _ZodEffects = class _ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
__name(_ZodEffects, "ZodEffects");
var ZodEffects = _ZodEffects;
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var _ZodOptional = class _ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodOptional, "ZodOptional");
var ZodOptional = _ZodOptional;
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var _ZodNullable = class _ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodNullable, "ZodNullable");
var ZodNullable = _ZodNullable;
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var _ZodDefault = class _ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
__name(_ZodDefault, "ZodDefault");
var ZodDefault = _ZodDefault;
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var _ZodCatch = class _ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
__name(_ZodCatch, "ZodCatch");
var ZodCatch = _ZodCatch;
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var _ZodNaN = class _ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
__name(_ZodNaN, "ZodNaN");
var ZodNaN = _ZodNaN;
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var _ZodBranded = class _ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
__name(_ZodBranded, "ZodBranded");
var ZodBranded = _ZodBranded;
var _ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
__name(_ZodPipeline, "ZodPipeline");
var ZodPipeline = _ZodPipeline;
var _ZodReadonly = class _ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
__name(_ZodReadonly, "ZodReadonly");
var ZodReadonly = _ZodReadonly;
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
__name(custom, "custom");
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = /* @__PURE__ */ __name((cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), "instanceOfType");
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
var onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
var oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
var coerce = {
  string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
  number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
  boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }), "boolean"),
  bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
  date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../../node_modules/.pnpm/@chainflip+bitcoin@0.2.2/node_modules/@chainflip/bitcoin/dist/index.mjs
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, "__require"), "__commonJS");
var __copyProps = /* @__PURE__ */ __name((to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
}, "__copyProps");
var __toESM = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
)), "__toESM");
var require_bitcoin = __commonJS({
  "wasm:./built/bitcoin.js"(exports, module) {
    var imports = {};
    imports["__wbindgen_placeholder__"] = module.exports;
    var wasm;
    var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    var cachedUint8Memory0 = null;
    function getUint8Memory0() {
      if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8Memory0;
    }
    __name(getUint8Memory0, "getUint8Memory0");
    function getStringFromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }
    __name(getStringFromWasm0, "getStringFromWasm0");
    var heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    var heap_next = heap.length;
    function addHeapObject(obj) {
      if (heap_next === heap.length)
        heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    __name(addHeapObject, "addHeapObject");
    function getObject(idx) {
      return heap[idx];
    }
    __name(getObject, "getObject");
    function dropObject(idx) {
      if (idx < 132)
        return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    __name(dropObject, "dropObject");
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    __name(takeObject, "takeObject");
    var WASM_VECTOR_LEN = 0;
    var cachedTextEncoder = new TextEncoder("utf-8");
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length, 1) >>> 0;
        getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len, 1) >>> 0;
      const mem = getUint8Memory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127)
          break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    __name(passStringToWasm0, "passStringToWasm0");
    var cachedInt32Memory0 = null;
    function getInt32Memory0() {
      if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
      }
      return cachedInt32Memory0;
    }
    __name(getInt32Memory0, "getInt32Memory0");
    module.exports.decode = function(address, encoding, network) {
      let deferred3_0;
      let deferred3_1;
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.decode(retptr, ptr0, len0, encoding, network);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
          ptr2 = 0;
          len2 = 0;
          throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
      }
    };
    module.exports.isValidAddressForNetwork = function(address, network) {
      const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.isValidAddressForNetwork(ptr0, len0, network);
      return ret !== 0;
    };
    module.exports.BitcoinNetwork = Object.freeze({ Mainnet: 0, "0": "Mainnet", Testnet: 1, "1": "Testnet", Regtest: 2, "2": "Regtest" });
    module.exports.AddressEncoding = Object.freeze({ P2WPKH: 0, "0": "P2WPKH", P2SH: 1, "1": "P2SH", P2PKH: 2, "2": "P2PKH", P2WSH: 3, "3": "P2WSH", Taproot: 4, "4": "Taproot" });
    module.exports.__wbindgen_error_new = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    var bytes = (() => {
      const base64 = "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0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyASQfS6+ZUHaiIENgL8AiADIBFBgpyF+QdrIgU2AvgCIAMgD0HZ8o+hBmsiBjYC9AIgAyACQYydkPMDayIHNgLwAiAQIAwgDSAOECAgAyAGNgJ8IAMgBzYCeCADIAQ2AnQgAyAFNgJwIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANB8ABqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIB42AswCIAMgHTYCyAIgAyAcNgLEAiADIBs2AsACIAMgGjYC3AIgAyAZNgLYAiADIBg2AtQCIAMgFzYC0AIgAyAWNgLsAiADIBU2AugCIAMgFDYC5AIgAyATNgLgAiADIBI2AvwCIAMgETYC+AIgAyAPNgL0AiADIAI2AvACIANBsAJqIh8gECAMIA0gDhAeIAMoArACIRsgAygCtAIhHCADKAK4AiEdIAMoArwCIR4gAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgHkG/rJLbAWsiBDYC/AIgAyAdQfrwhoIBayIFNgL4AiADIBxBxruG/gBqIgY2AvQCIAMgG0HMw7KgAmoiBzYC8AIgECAMIA0gDhAgIAMgBjYCjAEgAyAHNgKIASADIAQ2AoQBIAMgBTYCgAEgAygCwAIhBCADKALEAiEFIAMoAsgCIQYgAygCzAIhByADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgBzYC/AIgAyAGNgL4AiADIAU2AvQCIAMgBDYC8AIgDCANIA4gA0GAAWoQICADKALQAiEIIAMoAtQCIQkgAygC2AIhCiADKALcAiELIAMgGjYCzAIgAyAZNgLIAiADIBg2AsQCIAMgFzYCwAIgAyAWNgLcAiADIBU2AtgCIAMgFDYC1AIgAyATNgLQAiADIBI2AuwCIAMgETYC6AIgAyAPNgLkAiADIAI2AuACIAMgHjYC/AIgAyAdNgL4AiADIBw2AvQCIAMgGzYC8AIgHyAQIAwgDSAOEB4gAygCsAIhFyADKAK0AiEYIAMoArgCIRkgAygCvAIhGiADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAaQe/YpO8CaiIENgL8AiADIBlBqonS0wRqIgU2AvgCIAMgGEHc08LlBWoiBjYC9AIgAyAXQdqR5rcHaiIHNgLwAiAQIAwgDSAOECAgAyAGNgKcASADIAc2ApgBIAMgBDYClAEgAyAFNgKQASADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQZABahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyAWNgLMAiADIBU2AsgCIAMgFDYCxAIgAyATNgLAAiADIBI2AtwCIAMgETYC2AIgAyAPNgLUAiADIAI2AtACIAMgHjYC7AIgAyAdNgLoAiADIBw2AuQCIAMgGzYC4AIgAyAaNgL8AiADIBk2AvgCIAMgGDYC9AIgAyAXNgLwAiAfIBAgDCANIA4QHiADKAKwAiETIAMoArQCIRQgAygCuAIhFSADKAK8AiEWIAMgBzYC3AIgAyAGNgLYAiADIAU2AtQCIAMgBDYC0AIgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIBZBrt2GvgZrIgQ2AvwCIAMgFUGT87i+BWsiBTYC+AIgAyAUQbiw8/8EayIGNgL0AiADIBNBuYCahQRrIgc2AvACIBAgDCANIA4QICADIAY2AqwBIAMgBzYCqAEgAyAENgKkASADIAU2AqABIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANBoAFqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIBI2AswCIAMgETYCyAIgAyAPNgLEAiADIAI2AsACIAMgHjYC3AIgAyAdNgLYAiADIBw2AtQCIAMgGzYC0AIgAyAaNgLsAiADIBk2AugCIAMgGDYC5AIgAyAXNgLgAiADIBY2AvwCIAMgFTYC+AIgAyAUNgL0AiADIBM2AvACIB8gECAMIA0gDhAeIAMoArACIQIgAygCtAIhDyADKAK4AiERIAMoArwCIRIgAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgEkGN6P/IA2siBDYC/AIgAyARQbnd4dICayIFNgL4AiADIA9B0capNmoiBjYC9AIgAyACQefSpKEBaiIHNgLwAiAQIAwgDSAOECAgAyAGNgK8ASADIAc2ArgBIAMgBDYCtAEgAyAFNgKwASADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQbABahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyAeNgLMAiADIB02AsgCIAMgHDYCxAIgAyAbNgLAAiADIBo2AtwCIAMgGTYC2AIgAyAYNgLUAiADIBc2AtACIAMgFjYC7AIgAyAVNgLoAiADIBQ2AuQCIAMgEzYC4AIgAyASNgL8AiADIBE2AvgCIAMgDzYC9AIgAyACNgLwAiAfIBAgDCANIA4QHiADKAKwAiEbIAMoArQCIRwgAygCuAIhHSADKAK8AiEeIAMgBzYC3AIgAyAGNgLYAiADIAU2AtQCIAMgBDYC0AIgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIB5BhZXcvQJqIgQ2AvwCIAMgHUG4wuzwAmoiBTYC+AIgAyAcQfzbsekEaiIGNgL0AiADIBtBk5rgmQVqIgc2AvACIBAgDCANIA4QICADIAY2AswBIAMgBzYCyAEgAyAENgLEASADIAU2AsABIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANBwAFqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIBo2AswCIAMgGTYCyAIgAyAYNgLEAiADIBc2AsACIAMgFjYC3AIgAyAVNgLYAiADIBQ2AtQCIAMgEzYC0AIgAyASNgLsAiADIBE2AugCIAMgDzYC5AIgAyACNgLgAiADIB42AvwCIAMgHTYC+AIgAyAcNgL0AiADIBs2AvACIB8gECAMIA0gDhAeIAMoArACIRcgAygCtAIhGCADKAK4AiEZIAMoArwCIRogAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgGkHU5qmoBmoiBDYC/AIgAyAZQbuVqLMHaiIFNgL4AiADIBhB0u308QdrIgY2AvQCIAMgF0H7prfsBmsiBzYC8AIgECAMIA0gDhAgIAMgBjYC3AEgAyAHNgLYASADIAQ2AtQBIAMgBTYC0AEgAygCwAIhBCADKALEAiEFIAMoAsgCIQYgAygCzAIhByADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgBzYC/AIgAyAGNgL4AiADIAU2AvQCIAMgBDYC8AIgDCANIA4gA0HQAWoQICADKALQAiEIIAMoAtQCIQkgAygC2AIhCiADKALcAiELIAMgFjYCzAIgAyAVNgLIAiADIBQ2AsQCIAMgEzYCwAIgAyASNgLcAiADIBE2AtgCIAMgDzYC1AIgAyACNgLQAiADIB42AuwCIAMgHTYC6AIgAyAcNgLkAiADIBs2AuACIAMgGjYC/AIgAyAZNgL4AiADIBg2AvQCIAMgFzYC8AIgHyAQIAwgDSAOEB4gAygCsAIhEyADKAK0AiEUIAMoArgCIRUgAygCvAIhFiADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAWQd+ugOoFayIENgL8AiADIBVBtbOWvwVrIgU2AvgCIAMgFEGQ6dHtA2siBjYC9AIgAyATQd3czsQDayIHNgLwAiAQIAwgDSAOECAgAyAGNgLsASADIAc2AugBIAMgBDYC5AEgAyAFNgLgASADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQeABahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyASNgLMAiADIBE2AsgCIAMgDzYCxAIgAyACNgLAAiADIB42AtwCIAMgHTYC2AIgAyAcNgLUAiADIBs2AtACIAMgGjYC7AIgAyAZNgLoAiADIBg2AuQCIAMgFzYC4AIgAyAWNgL8AiADIBU2AvgCIAMgFDYC9AIgAyATNgLwAiAfIBAgDCANIA4QHiADKAKwAiECIAMoArQCIQ8gAygCuAIhESADKAK8AiESIAMgBzYC3AIgAyAGNgLYAiADIAU2AtQCIAMgBDYC0AIgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIBJB56+08wJrIgQ2AvwCIAMgEUHc85vLAmsiBTYC+AIgAyAPQfuUx98AayIGNgL0AiADIAJB8MCqgwFqIgc2AvACIBAgDCANIA4QICADIAY2AvwBIAMgBzYC+AEgAyAENgL0ASADIAU2AvABIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANB8AFqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIB42AswCIAMgHTYCyAIgAyAcNgLEAiADIBs2AsACIAMgGjYC3AIgAyAZNgLYAiADIBg2AtQCIAMgFzYC0AIgAyAWNgLsAiADIBU2AugCIAMgFDYC5AIgAyATNgLgAiADIBI2AvwCIAMgETYC+AIgAyAPNgL0AiADIAI2AvACIB8gECAMIA0gDhAeIAMoArACIRsgAygCtAIhHCADKAK4AiEdIAMoArwCIR4gAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgHkGWgpPNAWoiBDYC/AIgAyAdQYjY3fEBaiIFNgL4AiADIBxBzO6hugJqIgY2AvQCIAMgG0G1+cKlA2oiBzYC8AIgECAMIA0gDhAgIAMgBjYCjAIgAyAHNgKIAiADIAQ2AoQCIAMgBTYCgAIgAygCwAIhBCADKALEAiEFIAMoAsgCIQYgAygCzAIhByADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgBzYC/AIgAyAGNgL4AiADIAU2AvQCIAMgBDYC8AIgDCANIA4gA0GAAmoQICADKALQAiEIIAMoAtQCIQkgAygC2AIhCiADKALcAiELIAMgGjYCzAIgAyAZNgLIAiADIBg2AsQCIAMgFzYCwAIgAyAWNgLcAiADIBU2AtgCIAMgFDYC1AIgAyATNgLQAiADIBI2AuwCIAMgETYC6AIgAyAPNgLkAiADIAI2AuACIAMgHjYC/AIgAyAdNgL4AiADIBw2AvQCIAMgGzYC8AIgHyAQIAwgDSAOEB4gAygCsAIhFyADKAK0AiEYIAMoArgCIRkgAygCvAIhGiADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAaQbOZ8MgDaiIENgL8AiADIBlBytTi9gRqIgU2AvgCIAMgGEHPlPPcBWoiBjYC9AIgAyAXQfPfucEGaiIHNgLwAiAQIAwgDSAOECAgAyAGNgKcAiADIAc2ApgCIAMgBDYClAIgAyAFNgKQAiADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQZACahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyAWNgLMAiADIBU2AsgCIAMgFDYCxAIgAyATNgLAAiADIBI2AtwCIAMgETYC2AIgAyAPNgLUAiADIAI2AtACIAMgHjYC7AIgAyAdNgLoAiADIBw2AuQCIAMgGzYC4AIgAyAaNgL8AiADIBk2AvgCIAMgGDYC9AIgAyAXNgLwAiAfIBAgDCANIA4QHiADKAKwAiETIAMoArQCIRQgAygCuAIhFSADKAK8AiEWIAMg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IAMoAhBBAWoiBDYCECADIANBKGoQQiADLQABIQIgAy0AAEEBcQ0ACwsgA0E4aiADQSBqKQIANwMAIANBMGogA0EYaikCADcDACADIAMpAhA3AygjAEEgayICJAAgA0EoaiIBKAIAQRRHBEAgAkEANgIIQbiHwAAgASACQQhqEEoACyABQQA2AgAgACABKQAENwAAIABBCGogAUEMaikAADcAACAAQRBqIAFBFGooAAA2AAAgAkEgaiQAIANBQGskAA8LQdyGwABBLUGMh8AAED8AC/YBAgN/AX4jAEEwayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEsaiIEQQA2AgAgAkKAgICAEDcCJCACQSRqQdiQwAAgAxALGiACQSBqIAQoAgAiAzYCACACIAIpAiQiBTcDGCABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQRBqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8EALQAAGiACIAU3AwhBDEEEEFoiAUUEQEEEQQwQbAALIAEgAikDCDcCACABQQhqIAMoAgA2AgAgAEH4kcAANgIEIAAgATYCACACQTBqJAALygEAAkACQCABBEAgAkEASA0BAkACQAJ/IAMoAgQEQCADQQhqKAIAIgFFBEAgAkUEQEEBIQEMBAtBsZPBAC0AABogAkEBEFoMAgsgAygCACABQQEgAhBUDAELIAJFBEBBASEBDAILQbGTwQAtAAAaIAJBARBaCyIBRQ0BCyAAIAE2AgQgAEEIaiACNgIAIABBADYCAA8LIABBATYCBAwCCyAAQQA2AgQMAQsgAEEANgIEIABBATYCAA8LIABBCGogAjYCACAAQQE2AgALxAEBAn8jAEEgayIEJAACQCACIANqIgMgAkkNAEEIIAEoAgAiAkEBdCIFIAMgAyAFSRsiAyADQQhNGyIDQX9zQR92IQUCQCACRQRAIARBADYCGAwBCyAEIAI2AhwgBEEBNgIYIAQgASgCBDYCFAsgBEEIaiAFIAMgBEEUahAqIAQoAgwhBSAEKAIIBEAgBEEQaigCACEDDAELIAEgAzYCACABIAU2AgRBgYCAgHghBQsgACADNgIEIAAgBTYCACAEQSBqJAALhAIBAn8jAEEgayIGJABB6JPBAEHok8EAKAIAIgdBAWo2AgACQAJAIAdBAEgNAEG0l8EALQAADQBBtJfBAEEBOgAAQbCXwQBBsJfBACgCAEEBajYCACAGIAU6AB0gBiAEOgAcIAYgAzYCGCAGIAI2AhQgBkHAksAANgIQIAZBrJDAADYCDEHYk8EAKAIAIgJBAEgNAEHYk8EAIAJBAWo2AgBB2JPBAEHgk8EAKAIABH8gBiAAIAEoAhARAwAgBiAGKQMANwIMQeCTwQAoAgAgBkEMakHkk8EAKAIAKAIUEQMAQdiTwQAoAgBBAWsFIAILNgIAQbSXwQBBADoAACAEDQELAAsAC8gBAQJ/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNAEEIIAAoAgAiAkEBdCIEIAEgASAESRsiASABQQhNGyIEQX9zQR92IQECQCACRQRAIANBADYCGAwBCyADIAI2AhwgA0EBNgIYIAMgACgCBDYCFAsgA0EIaiABIAQgA0EUahArIAMoAgwhASADKAIIRQRAIAAgBDYCACAAIAE2AgQMAgsgAUGBgICAeEYNASABRQ0AIAEgA0EQaigCABBsAAsQRwALIANBIGokAAvIAQECfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQBBCCAAKAIAIgJBAXQiBCABIAEgBEkbIgEgAUEITRsiBEF/c0EfdiEBAkAgAkUEQCADQQA2AhgMAQsgAyACNgIcIANBATYCGCADIAAoAgQ2AhQLIANBCGogASAEIANBFGoQJSADKAIMIQEgAygCCEUEQCAAIAQ2AgAgACABNgIEDAILIAFBgYCAgHhGDQEgAUUNACABIANBEGooAgAQbAALEEcACyADQSBqJAALqQEBAX8gAAJ/AkACfwJAAkAgAQRAIAJBAEgNASADKAIEBEAgA0EIaigCACIEBEAgAygCACAEIAEgAhBUDAULCyACRQ0CQbGTwQAtAAAaIAIgARBaDAMLIABBADYCBCAAQQhqIAI2AgAMAwsgAEEANgIEDAILIAELIgMEQCAAIAM2AgQgAEEIaiACNgIAQQAMAgsgACABNgIEIABBCGogAjYCAAtBAQs2AgALrAEBAX8CQAJAIAEEQCACQQBIDQECfyADKAIEBEACQCADQQhqKAIAIgRFBEAMAQsgAygCACAEIAEgAhBUDAILCyABIAJFDQAaQbGTwQAtAAAaIAIgARBaCyIDBEAgACADNgIEIABBCGogAjYCACAAQQA2AgAPCyAAIAE2AgQgAEEIaiACNgIADAILIABBADYCBCAAQQhqIAI2AgAMAQsgAEEANgIECyAAQQE2AgALpQIBAn8jAEHgAGsiAyQAIANBADYCOCADIAI2AkAgAyABNgI8IANBEGogA0E8ahBCAkAgAy0AEEEBcQRAIAMtABEhAgNAIARBIE8NAiADQRhqIARqIAI6AAAgAyADKAI4QQFqIgQ2AjggA0EIaiADQTxqEEIgAy0ACSECIAMtAAhBAXENAAsLIANBPGoiASADQRhqQSQQbxojAEEgayICJAAgASgCIEEgRwRAIAJBADYCCEGwh8AAIAFBIGogAkEIahBKAAsgAUEANgIgIAAgASkAADcAACAAQQhqIAFBCGopAAA3AAAgAEEQaiABQRBqKQAANwAAIABBGGogAUEYaikAADcAACACQSBqJAAgA0HgAGokAA8LQdyGwABBLUGMh8AAED8AC48BAgN/AX4jAEEgayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEcaiIEQQA2AgAgAkKAgICAEDcCFCACQRRqQdiQwAAgAxALGiACQRBqIAQoAgAiAzYCACACIAIpAhQiBTcDCCABQQhqIAM2AgAgASAFNwIACyAAQfiRwAA2AgQgACABNgIAIAJBIGokAAt9AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQSRqQgI3AgAgBUE8akEkNgIAIAVBAjYCHCAFQfCWwAA2AhggBUElNgI0IAUgBUEwajYCICAFIAVBEGo2AjggBSAFQQhqNgIwIAVBGGogBBBIAAtsAQF/IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0EUakICNwIAIANBLGpBEzYCACADQQI2AgwgA0GUmsAANgIIIANBEzYCJCADIANBIGo2AhAgAyADQQRqNgIoIAMgAzYCICADQQhqIAIQSAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBFGpCAjcCACADQSxqQRM2AgAgA0ECNgIMIANBzJXAADYCCCADQRM2AiQgAyADQSBqNgIQIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEEgAC2wBAX8jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQRRqQgI3AgAgA0EsakET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AWsiBA0AC0EAIQUMAgsDQCAEQQBHIQUgBEUEQCADIQIMAwsCQCABLQAAIgJBMGsiB0EKSQ0AQX8gAkEgciICQdcAayIHIAcgAkHhAGtJGyIHQRBJDQBBASECDAMLQQIhAiADQf8BcUEEdCIDQQh2DQIgAUEBaiEBIARBAWshBCADQf8BcSAHQf8BcWoiA0H/AXEgA0YNAAsMAQtBASECQQEhBQsgCCACOgABIAggBToAACAJQTBqJAAgBi0ACSEBIAAgBi0ACEEBcToAACAAIAE6AAEgBkEQaiQACzcBAn8gACABKAIAIgIgASgCBCIDRwR/IAEgAkEBajYCACACLQAABSABCzoAASAAIAIgA0c6AAALOQACQAJ/IAJBgIDEAEcEQEEBIAAgAiABKAIQEQAADQEaCyADDQFBAAsPCyAAIAMgBCABKAIMEQEACzoBAX8jAEEQayIDJAAgAyACNgIMIAMgATYCCCADIAI2AgQgA0EEahA3IAAgAykCCDcDACADQRBqJAALvQIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARBjDwtBACEAIwBBgAFrIgMkACACKAIAIQIDQCAAIANqQf8AakEwQTcgAkEPcSIEQQpJGyAEajoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgAFLBEAgAkGAAUHEl8AAEC8ACyABQdSXwABBAiAAIANqQYABakEAIABrEAggA0GAAWokAA8LQQAhACMAQYABayIDJAAgAigCACECA0AgACADakH/AGpBMEHXACACQQ9xIgRBCkkbIARqOgAAIABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGAAUsEQCACQYABQcSXwAAQLwALIAFB1JfAAEECIAAgA2pBgAFqQQAgAGsQCCADQYABaiQACzoBAX8gACgCCCICIAAoAgBGBEAgACACEDkgACgCCCECCyAAIAJBAWo2AgggACgCBCACaiABOgAAQQALPwEBfyMAQSBrIgAkACAAQRRqQgA3AgAgAEEBNgIMIABBgJPAADYCCCAAQdCSwAA2AhAgAEEIakGIk8AAEEgAC7UCAQJ/IwBBIGsiAiQAIAJBATsBHCACIAE2AhggAiAANgIUIAJBiJXAADYCECACQdCTwAA2AgwjAEEQayIBJAAg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cnNGYWlsZWQgdG8gZW5jb2RlIGJlY2gzMiBhZGRyZXNzLgAAaAAQAAoAAACZAQAAEwAAAGgAEAAKAAAAmwEAACgAAABoABAACgAAAJsBAABIAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZAAAAAIAAAACAAAABAAAAGAAEABiABAAZAAQAAUAAAAEAAAABAAAAAYAAABFbXB0eUludmFsaWREaWdpdFBvc092ZXJmbG93TmVnT3ZlcmZsb3daZXJvAAUAAAAMAAAACwAAAAsAAAAEAAAACAEQAA0BEAAZARAAJAEQAC8BEABjYXBhY2l0eSBvdmVyZmxvdwAAAFwBEAARAAAAL3J1c3RjLzA3ZGNhNDg5YWMyZDkzM2M3OGQzYzUxNThlM2Y0M2JlZWZlYjAyY2UvbGlicmFyeS9hbGxvYy9zcmMvdmVjL3NwZWNfZnJvbV9pdGVyX25lc3RlZC5ycwAAeAEQAF4AAAA7AAAAEgAAAC9ydXN0Yy8wN2RjYTQ4OWFjMmQ5MzNjNzhkM2M1MTU4ZTNmNDNiZWVmZWIwMmNlL2xpYnJhcnkvYWxsb2Mvc3JjL3ZlYy9tb2QucnPoARAATAAAAHkLAAANAAAAL1VzZXJzL2FuZHJldy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JlY2gzMi0wLjkuMS9zcmMvbGliLnJzKCljYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAAcAAAAAAAAAAQAAAAgAAAAHAAAAAAAAAAEAAAAJAAAARXJyb3IAAAAKAAAADAAAAAQAAAALAAAADAAAAA0AAABEAhAAWgAAAPEBAAAyAAAARAIQAFoAAAAHAQAAJQAAAAAAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gW3NyYy91dGlscy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaW5pdGlhbGl6ZWRfbGVuZ3RoIDwgTgAAAFADEAAMAAAAJAAAAAkAAAAVAAAAUAMQAAwAAAAsAAAACQAAACAAAAAEAAAAFAAAAA4AAAAMAAAABAAAAA8AAAAQAAAADQAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0edQDEAAkAAAAL3J1c3RjLzA3ZGNhNDg5YWMyZDkzM2M3OGQzYzUxNThlM2Y0M2JlZWZlYjAyY2UvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycwAEEABMAAAAzwEAAAkAAAD///////////////////////////////////////////////////////////////8P/woRFRQaHgcF/////////x3/GA0ZCQgX/xIWHxsT/wEAAxALHAwOBgQC////////Hf8YDRkJCBf/EhYfGxP/AQADEAscDA4GBAL//////xEAAAAAAAAAAQAAABIAAABFcnJvcgAAAHEAAABwAAAAegAAAHIAAAB5AAAAOQAAAHgAAAA4AAAAZwAAAGYAAAAyAAAAdAAAAHYAAABkAAAAdwAAADAAAABzAAAAMwAAAGoAAABuAAAANQAAADQAAABrAAAAaAAAAGMAAABlAAAANgAAAG0AAAB1AAAAYQAAADcAAABsAAAAL1VzZXJzL2FuZHJldy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JlY2gzMi0wLjkuMS9zcmMvbGliLnJzAAB0BRAAWgAAAGIAAAAJAAAAsldqO22OUCb6GaEe3TNCPbNiFCpVbmhhbmRsZWQgZXJyb3Igd3JpdGluZyB0aGUgY2hlY2tzdW0gb24gZHJvcC4AAAB0BRAAWgAAANwAAAAOAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZXQFEABaAAAAiwEAABkAAAB0BRAAWgAAACQCAAAYAAAAY29udmVydF9iaXRzIGBmcm9tYCBhbmQgYHRvYCBwYXJhbWV0ZXJzIDAgb3IgZ3JlYXRlciB0aGFuIDgAdAUQAFoAAADcAgAACQAAADEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXovVXNlcnMvYW5kcmV3Ly5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvYmFzZTU4LTAuMi4wL3NyYy9saWIucnMCBxAAWgAAAFQAAAAoAAAAAgcQAFoAAABUAAAAGQAAAAIHEABaAAAAPgAAACYAAAACBxAAWgAAAKUAAAAPAAAAAgcQAFoAAABrAAAAFAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAVAAAADAAAAAQAAAAWAAAAFwAAABgAAABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAABwCBAAFQAAAIUIEAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzpAgQABgAAABiAQAACQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnPMCBAAHAAAAIQCAAAeAAAAFQAAAAwAAAAEAAAAGQAAABoAAAAIAAAABAAAABsAAAAaAAAACAAAAAQAAAAcAAAAHQAAAB4AAAAQAAAABAAAAB8AAAAgAAAAIQAAAAAAAAABAAAAIgAAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNjYXBhY2l0eSBvdmVyZmxvdwAAAGwJEAARAAAAUAkQABwAAAA7AgAABQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3N0ci5yc5gJEAAYAAAAlQEAAD8AAACYCRAAGAAAAJYBAAAzAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kIAD7CRAAPAAAAGxpYnJhcnkvY29yZS9zcmMvbnVtL21vZC5ycwBAChAAGwAAAJ0FAAAFAAAALi4AAGwKEAACAAAAMDEyMzQ1Njc4OWFiY2RlZikAAAAAAAAAAQAAACoAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAmAoQACAAAAC4ChAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogAOcKEAAQAAAA9woQABcAAAAOCxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAADnChAAEAAAADALEAAQAAAAQAsQAAkAAAAOCxAACQAAADogAADQCRAAAAAAAGwLEAACAAAAKwAAAAwAAAAEAAAALAAAAC0AAAAuAAAAICAgICB7ICwgIHsKLAp9IH1saWJyYXJ5L2NvcmUvc3JjL2ZtdC9udW0ucnOpCxAAGwAAAGkAAAAXAAAAMHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OWxpYnJhcnkvY29yZS9zcmMvc2xpY2UvbWVtY2hyLnJzAACeDBAAIAAAAJ8AAAAJAAAAngwQACAAAACDAAAAHgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCDgDBAAEgAAAPIMEAAiAAAAcmFuZ2UgZW5kIGluZGV4ICQNEAAQAAAA8gwQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IABEDRAAFgAAAFoNEAANAAAAWy4uLl1iZWdpbiA8PSBlbmQgKCA8PSApIHdoZW4gc2xpY2luZyBgYH0NEAAOAAAAiw0QAAQAAACPDRAAEAAAAJ8NEAABAAAAYnl0ZSBpbmRleCAgaXMgbm90IGEgY2hhciBib3VuZGFyeTsgaXQgaXMgaW5zaWRlICAoYnl0ZXMgKSBvZiBgAMANEAALAAAAyw0QACYAAADxDRAACAAAAPkNEAAGAAAAnw0QAAEAAAAgaXMgb3V0IG9mIGJvdW5kcyBvZiBgAADADRAACwAAACgOEAAWAAAAnw0QAAEAAABsaWJyYXJ5L2NvcmUvc3JjL3N0ci9tb2QucnMAWA4QABsAAAAJAQAALAAAAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAAACEDhAAJQAAABoAAAA2AAAAhA4QACUAAAAKAAAAKwAAAAAGAQEDAQQCBQcHAggICQIKBQsCDgQQARECEgUTERQBFQIXAhkNHAUdCB8BJAFqBGsCrwOxArwCzwLRAtQM1QnWAtcC2gHgBeEC5wToAu4g8AT4AvoD+wEMJzs+Tk+Pnp6fe4uTlqKyuoaxBgcJNj0+VvPQ0QQUGDY3Vld/qq6vvTXgEoeJjp4EDQ4REikxNDpFRklKTk9kZVy2txscBwgKCxQXNjk6qKnY2Qk3kJGoBwo7PmZpj5IRb1+/7u9aYvT8/1NUmpsuLycoVZ2goaOkp6iturzEBgsMFR06P0VRpqfMzaAHGRoiJT4/5+zv/8XGBCAjJSYoMzg6SEpMUFNVVlhaXF5gY2Vma3N4fX+KpKqvsMDQrq9ub76TXiJ7BQMELQNmAwEvLoCCHQMxDxwEJAkeBSsFRAQOKoCqBiQEJAQoCDQLTkOBNwkWCggYO0U5A2MICTAWBSEDGwUBQDgESwUvBAoHCQdAICcEDAk2AzoFGgcEDAdQSTczDTMHLggKgSZSSysIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULQj4qBjsFCgZRBgEFEAMFgItiHkgICoCmXiJFCwoGDRM6Bgo2LAQXgLk8ZFMMSAkKRkUbSAhTDUkHCoD2RgodA0dJNwMOCAoGOQcKgTYZBzsDHFYBDzINg5tmdQuAxIpMYw2EMBAWj6qCR6G5gjkHKgRcBiYKRgooBROCsFtlSwQ5BxFABQsCDpf4CITWKgmi54EzDwEdBg4ECIGMiQRrBQ0DCQcQkmBHCXQ8gPYKcwhwFUZ6FAwUDFcJGYCHgUcDhUIPFYRQHwYGgNUrBT4hAXAtAxoEAoFAHxE6BQGB0CqC5oD3KUwECgQCgxFETD2AwjwGAQRVBRs0AoEOLARkDFYKgK44HQ0sBAkHAg4GgJqD2AQRAw0DdwRfBgwEAQ8MBDgICgYoCCJOgVQMHQMJBzYIDgQJBwkHgMslCoQGAAEDBQUGBgIHBggHCREKHAsZDBoNEA4MDwQQAxISEwkWARcEGAEZAxoHGwEcAh8WIAMrAy0LLgEwAzECMgGnAqkCqgSrCPoC+wX9Av4D/wmteHmLjaIwV1iLjJAc3Q4PS0z7/C4vP1xdX+KEjY6RkqmxurvFxsnK3uTl/wAEERIpMTQ3Ojs9SUpdhI6SqbG0urvGys7P5OUABA0OERIpMTQ6O0VGSUpeZGWEkZudyc7PDREpOjtFSVdbXF5fZGWNkam0urvFyd/k5fANEUVJZGWAhLK8vr/V1/Dxg4WLpKa+v8XHz9rbSJi9zcbOz0lOT1dZXl+Jjo+xtre/wcbH1xEWF1tc9vf+/4Btcd7fDh9ubxwdX31+rq9/u7wWFx4fRkdOT1haXF5+f7XF1NXc8PH1cnOPdHWWJi4vp6+3v8fP19+aQJeYMI8f0tTO/05PWlsHCA8QJy/u725vNz0/QkWQkVNndcjJ0NHY2ef+/wAgXyKC3wSCRAgbBAYRgawOgKsFHwmBGwMZCAEELwQ0BAcDAQcGBxEKUA8SB1UHAwQcCgkDCAMHAwIDAwMMBAUDCwYBDhUFTgcbB1cHAgYXDFAEQwMtAwEEEQYPDDoEHSVfIG0EaiWAyAWCsAMaBoL9A1kHFgkYCRQMFAxqBgoGGgZZBysFRgosBAwEAQMxCywEGgYLA4CsBgoGLzFNA4CkCDwDDwM8BzgIKwWC/xEYCC8RLQMhDyEPgIwEgpcZCxWIlAUvBTsHAg4YCYC+InQMgNYaDAWA/wWA3wzynQM3CYFcFIC4CIDLBQoYOwMKBjgIRggMBnQLHgNaBFkJgIMYHAoWCUwEgIoGq6QMFwQxoQSB2iYHDAUFgKYQgfUHASAqBkwEgI0EgL4DGwMPDWxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnNIFBAAKAAAAFAAAAAoAAAASBQQACgAAABcAAAAFgAAAGxpYnJhcnkvY29yZS9zcmMvZXNjYXBlLnJzAACQFBAAGgAAADgAAAALAAAAXHV7AJAUEAAaAAAAZgAAACMAAACwAgAAXROgAhIXICK9H2AifCwgMAUwYDQVoOA1+KRgNwymoDce++A3AP7gQ/0BYUSAByFIAQrhSCQNoUmrDiFLLxhhSzsZYVkwHOFZ8x5hXTA0IWHwamFiT2/hYvCvoWOdvKFkAM9hZWfR4WUA2mFmAOChZ67iIWnr5CFr0Oiha/vz4WsBAG5s8AG/bCcBBgELASMBAQFHAQQBAQEEAQICAMAEAgQBCQIBAfsHzwEFATEtAQEBAgECAQEsAQsGCgsBASMBChUQAWUIAQoBBCEBAQEeG1sLOgsEAQIBGBgrAywBBwIGCCk6NwEBAQQIBAEDBwoCDQEPAToBBAQIARQCGgECAjkBBAIEAgIDAwEeAgMBCwI5AQQFAQIEARQCFgYBAToBAgEBBAgBBwILAh4BPQEMATIBAwE3AQEDBQMBBAcCCwIdAToBAgEGAQUCFAIcAjkCBAQIARQCHQFIAQcDAQFaAQIHCwliAQIJCQEBB0kCGwEBAQEBNw4BBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAV4BAAMAAx0CHgIeAkACAQcIAQILAwEFAS0FMwFBAiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEnAQgfMQQwAQEFAQEFASgJDAIgBAICAQM4AQECAwEBAzoIAgJABlIDAQ0BBwQBBgEDAjI/DQEiZQABAQMLAw0DDQMNAgwFCAIKAQIBAgUxBQEKAQENARANMyEAAnEDfQEPAWAgLwEAASQEAwUFAV0GXQMAAQAGAAFiBAEKAQEcBFACDiJOARcDZwMDAggBAwEEARkCBQGXAhoSDQEmCBkLLgMwAQIEAgIRARUCQgYCAgICDAEIASMBCwEzAQEDAgIFAgEBGwEOAgUCAQFkBQkDeQECAQQBAAGTEQAQAwEMECIBAgGpAQcBBgELASMBAQEvAS0CQwEVAwAB4gGVBQAGASoBCQADAQIFBCgDBAGlAgAEAAJQA0YLMQR7ATYPKQECAgoDMQQCAgIBBAEKATIDJAUBCD4BDAI0CQoEAgFfAwIBAQIGAQIBnQEDCBUCOQIDASUHAwXDCAIDAQEXAVQGAQEEAgEC7gQGAgECGwJVCAIBAQJqAQEBAgYBAWUDAgQBBQAJAQIAAgEBBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQEBAQARBg8ABTsHCQQAAT8RQAIBAgAEAQcBAgACAQQALgIXAAMJEAIHHgSUAwA3BDIIAQ4BFgUBDwAHARECBwECAQUFPiEBoA4AAT0EAAUAB20IAAUAAR5ggPAAAKAQAACgE+AGgBwgCBYfoAi2JMAJACwgE0CmYBMwq+AUAPtgFyH/IBgABKEYgAchGYAM4RugGOEcQG5hHQDUoR2m1uEdAN+BIjDgYSUA6SEmMPFhJorxsiZBGgYaLwEKAQQBBRcBHwHDAQQE0AEkBwIeBWABKgQCAgIEAQEGAQEDAQEBFAFTAYsIpgEmCSkAJgEBBQECKwEEAFYCBgAJBysCA0DAQAACBgImAgYCCAEBAQEBAQEfAjUBBwEBAwMBBwMEAgYEDQUDAQd0AQ0BEA1lAQQBAgoBAQMFBgEBAQEBAQQBBgQBAgQFBQQBESADAgA0AOUGBAMCDCYBAQUBAC4SHoRmAwQBOwUCAQEBBRgFAQMAKwEOBlAABwwFABoGGgBQYCQEJHQLAQ8BBwECAQsBDwEHAQIAAQIDASoBCQAzDTMAQABAAFUBRwECAgECAgIEAQwBAQEHAUEBBAIIAQcBHAEEAQUBAQMHAQACGQEZAR8BGQEfARkBHwEZAR8BGQEIAAoBFAYGAD4ARAAaBhoGGgAAAAMAAIMEIACRBWAAXROgABIXIB8MIGAf7yygKyowICxvpuAsAqhgLR77YC4A/iA2nv9gNv0B4TYBCiE3JA3hN6sOYTkvGKE5MBxhSPMeoUxANGFQ8GqhUU9vIVKdvKFSAM9hU2XRoVMA2iFUAODhVa7iYVfs5CFZ0OihWSAA7lnwAX9aAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDPAgqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgECAQMBBQIHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwADHQIeAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAcBAQUBKAkMAiAEAgIBAzgBAQIDAQEDOggCApgDAQ0BBwQBBgEDAsZAAAHDIQADjQFgIAAGaQIABAEKIAJQAgABAwEEARkCBQGXAhoSDQEmCBkLLgMwAQIEAgInAUMGAgICAgwBCAEvATMBAQMCAgUCAQEqAggB7gECAQQBAAEAEBAQAAIAAeIBlQUAAwECBQQoAwQBpQIABAACUANGCzEEewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQoEAgFfAwIBAQIGAQIBnQEDCBUCOQIBAQEBFgEOBwMFwwgCAwEBFwFRAQIGAQECAQECAQLrAQIEBgIBAhsCVQgCAQECagEBAQIGAQFlAwIEAQUACQEC9QEKAgEBBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQEBAQABBg8ABTsHAAE/BFEBAAIALgIXAAEBAwQFCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABAAHbQcAYIDwAADAAAAA4AAAAMEAAADhAAAAwgAAAOIAAADDAAAA4wAAAMQAAADkAAAAxQAAAOUAAADGAAAA5gAAAMcAAADnAAAAyAAAAOgAAADJAAAA6QAAAMoAAADqAAAAywAAAOsAAADMAAAA7AAAAM0AAADtAAAAzgAAAO4AAADPAAAA7wAAANAAAADwAAAA0QAAAPEAAADSAAAA8gAAANMAAADzAAAA1AAAAPQAAADVAAAA9QAAANYAAAD2AAAA2AAAAPgAAADZAAAA+QAAANoAAAD6AAAA2wAAAPsAAADcAAAA/AAAAN0AAAD9AAAA3gAAAP4AAAAAAQAAAQEAAAIBAAADAQAABAEAAAUBAAAGAQAABwEAAAgBAAAJAQAACgEAAAsBAAAMAQAADQEAAA4BAAAPAQAAEAEAABEBAAASAQAAEwEAABQBAAAVAQAAFgEAABcBAAAYAQAAGQEAABoBAAAbAQAAHAEAAB0BAAAeAQAAHwEAACABAAAhAQAAIgEAACMBAAAkAQAAJQEAACYBAAAnAQAAKAEAACkBAAAqAQAAKwEAACwBAAAtAQAALgEAAC8BAAAwAQAAAABAADIBAAAzAQAANAEAADUBAAA2AQAANwEAADkBAAA6AQAAOwEAADwBAAA9AQAAPgEAAD8BAABAAQAAQQEAAEIBAABDAQAARAEAAEUBAABGAQAARwEAAEgBAABKAQAASwEAAEwBAABNAQAATgEAAE8BAABQAQAAUQEAAFIBAABTAQAAVAEAAFUBAABWAQAAVwEAAFgBAABZAQAAWgEAAFsBAABcAQAAXQEAAF4BAABfAQAAYAEAAGEBAABiAQAAYwEAAGQBAABlAQAAZgEAAGcBAABoAQAAaQEAAGoBAABrAQAAbAEAAG0BAABuAQAAbwEAAHABAABxAQAAcgEAAHMBAAB0AQAAdQEAAHYBAAB3AQAAeAEAAP8AAAB5AQAAegEAAHsBAAB8AQAAfQEAAH4BAACBAQAAUwIAAIIBAACDAQAAhAEAAIUBAACGAQAAVAIAAIcBAACIAQAAiQEAAFYCAACKAQAAVwIAAIsBAACMAQAAjgEAAN0BAACPAQAAWQIAAJABAABbAgAAkQEAAJIBAACTAQAAYAIAAJQBAABjAgAAlgEAAGkCAACXAQAAaAIAAJgBAACZAQAAnAEAAG8CAACdAQAAcgIAAJ8BAAB1AgAAoAEAAKEBAACiAQAAowEAAKQBAAClAQAApgEAAIACAACnAQAAqAEAAKkBAACDAgAArAEAAK0BAACuAQAAiAIAAK8BAACwAQAAsQEAAIoCAACyAQAAiwIAALMBAAC0AQAAtQEAALYBAAC3AQAAkgIAALgBAAC5AQAAvAEAAL0BAADEAQAAxgEAAMUBAADGAQAAxwEAAMkBAADIAQAAyQEAAMoBAADMAQAAywEAAMwBAADNAQAAzgEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAANUBAADWAQAA1wEAANgBAADZAQAA2gEAANsBAADcAQAA3gEAAN8BAADgAQAA4QEAAOIBAADjAQAA5AEAAOUBAADmAQAA5wEAAOgBAADpAQAA6gEAAOsBAADsAQAA7QEAAO4BAADvAQAA8QEAAPMBAADyAQAA8wEAAPQBAAD1AQAA9gEAAJUBAAD3AQAAvwEAAPgBAAD5AQAA+gEAAPsBAAD8AQAA/QEAAP4BAAD/AQAAAAIAAAECAAACAgAAAwIAAAQCAAAFAgAABgIAAAcCAAAIAgAACQIAAAoCAAALAgAADAIAAA0CAAAOAgAADwIAABACAAARAgAAEgIAABMCAAAUAgAAFQIAABYCAAAXAgAAGAIAABkCAAAaAgAAGwIAABwCAAAdAgAAHgIAAB8CAAAgAgAAngEAACICAAAjAgAAJAIAACUCAAAmAgAAJwIAACgCAAApAgAAKgIAACsCAAAsAgAALQIAAC4CAAAvAgAAMAIAADECAAAyAgAAMwIAADoCAABlLAAAOwIAADwCAAA9AgAAmgEAAD4CAABmLAAAQQIAAEICAABDAgAAgAEAAEQCAACJAgAARQIAAIwCAABGAgAARwIAAEgCAABJAgAASgIAAEsCAABMAgAATQIAAE4CAABPAgAAcAMAAHEDAAByAwAAcwMAAHYDAAB3AwAAfwMAAPMDAACGAwAArAMAAIgDAACtAwAAiQMAAK4DAACKAwAArwMAAIwDAADMAwAAjgMAAM0DAACPAwAAzgMAAJEDAACxAwAAkgMAALIDAACTAwAAswMAAJQDAAC0AwAAlQMAALUDAACWAwAAtgMAAJcDAAC3AwAAmAMAALgDAACZAwAAuQMAAJoDAAC6AwAAmwMAALsDAACcAwAAvAMAAJ0DAAC9AwAAngMAAL4DAACfAwAAvwMAAKADAADAAwAAoQMAAMEDAACjAwAAwwMAAKQDAADEAwAApQMAAMUDAACmAwAAxgMAAKcDAADHAwAAqAMAAMgDAACpAwAAyQMAAKoDAADKAwAAqwMAAMsDAADPAwAA1wMAANgDAADZAwAA2gMAANsDAADcAwAA3QMAAN4DAADfAwAA4AMAAOEDAADiAwAA4wMAAOQDAADlAwAA5gMAAOcDAADoAwAA6QMAAOoDAADrAwAA7AMAAO0DAADuAwAA7wMAAPQDAAC4AwAA9wMAAPgDAAD5AwAA8gMAAPoDAAD7AwAA/QMAAHsDAAD+AwAAfAMAAP8DAAB9AwAAAAQAAFAEAAABBAAAUQQAAAIEAABSBAAAAwQAAFMEAAAEBAAAVAQAAAUEAABVBAAABgQAAFYEAAAHBAAAVwQAAAgEAABYBAAACQQAAFkEAAAKBAAAWgQAAAsEAABbBAAADAQAAFwEAAANBAAAXQQAAA4EAABeBAAADwQAAF8EAAAQBAAAMAQAABEEAAAxBAAAEgQAADIEAAATBAAAMwQAABQEAAA0BAAAFQQAADUEAAAWBAAANgQAABcEAAA3BAAAGAQAADgEAAAZBAAAOQQAABoEAAA6BAAAGwQAADsEAAAcBAAAPAQAAB0EAAA9BAAAHgQAAD4EAAAfBAAAPwQAACAEAABABAAAIQQAAEEEAAAiBAAAQgQAACMEAABDBAAAJAQAAEQEAAAlBAAARQQAACYEAABGBAAAJwQAAEcEAAAoBAAASAQAACkEAABJBAAAKgQAAEoEAAArBAAASwQAACwEAABMBAAALQQAAE0EAAAuBAAATgQAAC8EAABPBAAAYAQAAGEEAABiBAAAYwQAAGQEAABlBAAAZgQAAGcEAABoBAAAaQQAAGoEAABrBAAAbAQAAG0EAABuBAAAbwQAAHAEAABxBAAAcgQAAHMEAAB0BAAAdQQAAHYEAAB3BAAAeAQAAHkEAAB6BAAAewQAAHwEAAB9BAAAfgQAAH8EAACABAAAgQQAAIoEAACLBAAAjAQAAI0EAACOBAAAjwQAAJAEAACRBAAAkgQAAJMEAACUBAAAlQQAAJYEAACXBAAAmAQAAJkEAACaBAAAmwQAAJwEAACdBAAAngQAAJ8EAACgBAAAoQQAAKIEAACjBAAApAQAAKUEAACmBAAApwQAAKgEAACpBAAAqgQAAKsEAACsBAAArQQAAK4EAACvBAAAsAQAALEEAACyBAAAswQAALQEAAC1BAAAtgQAALcEAAC4BAAAuQQAALoEAAC7BAAAvAQAAL0EAAC+BAAAvwQAAMAEAADPBAAAwQQAAMIEAADDBAAAxAQAAMUEAADGBAAAxwQAAMgEAADJBAAAygQAAMsEAADMBAAAzQQAAM4EAADQBAAA0QQAANIEAADTBAAA1AQAANUEAADWBAAA1wQAANgEAADZBAAA2gQAANsEAADcBAAA3QQAAN4EAADfBAAA4AQAAOEEAADiBAAA4wQAAOQEAADlBAAA5gQAAOcEAADoBAAA6QQAAOoEAADrBAAA7AQAAO0EAADuBAAA7wQAAPAEAADxBAAA8gQAAPMEAAD0BAAA9QQAAPYEAAD3BAAA+AQAAPkEAAD6BAAA+wQAAPwEAAD9BAAA/gQAAP8EAAAABQAAAQUAAAIFAAADBQAABAUAAAUFAAAGBQAABwUAAAgFAAAJBQAACgUAAAsFAAAMBQAADQUAAA4FAAAPBQAAEAUAABEFAAASBQAAEwUAABQFAAAVBQAAFgUAABcFAAAYBQAAGQUAABoFAAAbBQAAHAUAAB0FAAAeBQAAHwUAACAFAAAhBQAAIgUAACMFAAAkBQAAJQUAACYFAAAnBQAAKAUAACkFAAAqBQAAKwUAACwFAAAtBQAALgUAAC8FAAAxBQAAYQUAADIFAABiBQAAMwUAAGMFAAA0BQAAZAUAADUFAABlBQAANgUAAGYFAAA3BQAAZwUAADgFAABoBQAAOQUAAGkFAAA6BQAAagUAADsFAABrBQAAPAUAAGwFAAA9BQAAbQUAAD4FAABuBQAAPwUAAG8FAABABQAAcAUAAEEFAABxBQAAQgUAAHIFAABDBQAAcwUAAEQFAAB0BQAARQUAAHUFAABGBQAAdgUAAEcFAAB3BQAASAUAAHgFAABJBQAAeQUAAEoFAAB6BQAASwUAAHsFAABMBQAAfAUAAE0FAAB9BQAATgUAAH4FAABPBQAAfwUAAFAFAACABQAAUQUAAIEFAABSBQAAggUAAFMFAACDBQAAVAUAAIQFAABVBQAAhQUAAFYFAACGBQAAoBAAAAAtAAChEAAAAS0AAKIQAAACLQAAoxAAAAMtAACkEAAABC0AAKUQAAAFLQAAphAAAAYtAACnEAAABy0AAKgQAAAILQAAqRAAAAktAACqEAAACi0AAKsQAAALLQAArBAAAAwtAACtEAAADS0AAK4QAAAOLQAArxAAAA8tAACwEAAAEC0AALEQAAARLQAAshAAABItAACzEAAAEy0AALQQAAAULQAAtRAAABUtAAC2EAAAFi0AALcQAAAXLQAAuBAAABgtAAC5EAAAGS0AALoQAAAaLQAAuxAAABstAAC8EAAAHC0AAL0QAAAdLQAAvhAAAB4tAAC/EAAAHy0AAMAQAAAgLQAAwRAAACEtAADCEAAAIi0AAMMQAAAjLQAAxBAAACQtAADFEAAAJS0AAMcQAAAnLQAAzRAAAC0tAACgEwAAcKsAAKETAABxqwAAohMAAHKrAACjEwAAc6sAAKQTAAB0qwAApRMAAHWrAACmEwAAdqsAAKcTAAB3qwAAqBMAAHirAACpEwAAeasAAKoTAAB6qwAAqxMAAHurAACsEwAAfKsAAK0TAAB9qwAArhMAAH6rAACvEwAAf6sAALATAACAqwAAsRMAAIGrAACyEwAAgqsAALMTAACDqwAAtBMAAISrAAC1EwAAhasAALYTAACGqwAAtxMAAIerAAC4EwAAiKsAALkTAACJqwAAuhMAAIqrAAC7EwAAi6sAALwTAACMqwAAvRMAAI2rAAC+EwAAjqsAAL8TAACPqwAAwBMAAJCrAADBEwAAkasAAMITAACSqwAAwxMAAJOrAADEEwAAlKsAAMUTAACVqwAAxhMAAJarAADHEwAAl6sAAMgTAACYqwAAyRMAAJmrAADKEwAAmqsAAMsTAACbqwAAzBMAAJyrAADNEwAAnasAAM4TAACeqwAAzxMAAJ+rAADQEwAAoKsAANETAAChqwAA0hMAAKKrAADTEwAAo6sAANQTAACkqwAA1RMAAKWrAADWEwAApqsAANcTAACnqwAA2BMAAKirAADZEwAAqasAANoTAACqqwAA2xMAAKurAADcEwAArKsAAN0TAACtqwAA3hMAAK6rAADfEwAAr6sAAOATAACwqwAA4RMAALGrAADiEwAAsqsAAOMTAACzqwAA5BMAALSrAADlEwAAtasAAOYTAAC2qwAA5xMAALerAADoEwAAuKsAAOkTAAC5qwAA6hMAALqrAADrEwAAu6sAAOwTAAC8qwAA7RMAAL2rAADuEwAAvqsAAO8TAAC/qwAA8BMAAPgTAADxEwAA+RMAAPITAAD6EwAA8xMAAPsTAAD0EwAA/BMAAPUTAAD9EwAAkBwAANAQAACRHAAA0RAAAJIcAADSEAAAkxwAANMQAACUHAAA1BAAAJUcAADVEAAAlhwAANYQAACXHAAA1xAAAJgcAADYEAAAmRwAANkQAACaHAAA2hAAAJscAADbEAAAnBwAANwQAACdHAAA3RAAAJ4cAADeEAAAnxwAAN8QAACgHAAA4BAAAKEcAADhEAAAohwAAOIQAACjHAAA4xAAAKQcAADkEAAApRwAAOUQAACmHAAA5hAAAKccAADnEAAAqBwAAOgQAACpHAAA6RAAAKocAADqEAAAqxwAAOsQAACsHAAA7BAAAK0cAADtEAAArhwAAO4QAACvHAAA7xAAALAcAADwEAAAsRwAAPEQAACyHAAA8hAAALMcAADzEAAAtBwAAPQQAAC1HAAA9RAAALYcAAD2EAAAtxwAAPcQAAC4HAAA+BAAALkcAAD5EAAAuhwAAPoQAAC9HAAA/RAAAL4cAAD+EAAAvxwAAP8QAAAAHgAAAR4AAAIeAAADHgAABB4AAAUeAAAGHgAABx4AAAgeAAAJHgAACh4AAAseAAAMHgAADR4AAA4eAAAPHgAAEB4AABEeAAASHgAAEx4AABQeAAAVHgAAFh4AABceAAAYHgAAGR4AABoeAAAbHgAAHB4AAB0eAAAeHgAAHx4AACAeAAAhHgAAIh4AACMeAAAkHgAAJR4AACYeAAAnHgAAKB4AACkeAAAqHgAAKx4AACweAAAtHgAALh4AAC8eAAAwHgAAMR4AADIeAAAzHgAANB4AADUeAAA2HgAANx4AADgeAAA5HgAAOh4AADseAAA8HgAAPR4AAD4eAAA/HgAAQB4AAEEeAABCHgAAQx4AAEQeAABFHgAARh4AAEceAABIHgAASR4AAEoeAABLHgAATB4AAE0eAABOHgAATx4AAFAeAABRHgAAUh4AAFMeAABUHgAAVR4AAFYeAABXHgAAWB4AAFkeAABaHgAAWx4AAFweAABdHgAAXh4AAF8eAABgHgAAYR4AAGIeAABjHgAAZB4AAGUeAABmHgAAZx4AAGgeAABpHgAAah4AAGseAABsHgAAbR4AAG4eAABvHgAAcB4AAHEeAAByHgAAcx4AAHQeAAB1HgAAdh4AAHceAAB4HgAAeR4AAHoeAAB7HgAAfB4AAH0eAAB+HgAAfx4AAIAeAACBHgAAgh4AAIMeAACEHgAAhR4AAIYeAACHHgAAiB4AAIkeAACKHgAAix4AAIweAACNHgAAjh4AAI8eAACQHgAAkR4AAJIeAACTHgAAlB4AAJUeAACeHgAA3wAAAKAeAAChHgAAoh4AAKMeAACkHgAApR4AAKYeAACnHgAAqB4AAKkeAACqHgAAqx4AAKweAACtHgAArh4AAK8eAACwHgAAsR4AALIeAACzHgAAtB4AALUeAAC2HgAAtx4AALgeAAC5HgAAuh4AALseAAC8HgAAvR4AAL4eAAC/HgAAwB4AAMEeAADCHgAAwx4AAMQeAADFHgAAxh4AAMceAADIHgAAyR4AAMoeAADLHgAAzB4AAM0eAADOHgAAzx4AANAeAADRHgAA0h4AANMeAADUHgAA1R4AANYeAADXHgAA2B4AANkeAADaHgAA2x4AANweAADdHgAA3h4AAN8eAADgHgAA4R4AAOIeAADjHgAA5B4AAOUeAADmHgAA5x4AAOgeAADpHgAA6h4AAOseAADsHgAA7R4AAO4eAADvHgAA8B4AAPEeAADyHgAA8x4AAPQeAAD1HgAA9h4AAPceAAD4HgAA+R4AAPoeAAD7HgAA/B4AAP0eAAD+HgAA/x4AAAgfAAAAHwAACR8AAAEfAAAKHwAAAh8AAAsfAAADHwAADB8AAAQfAAANHwAABR8AAA4fAAAGHwAADx8AAAcfAAAYHwAAEB8AABkfAAARHwAAGh8AABIfAAAbHwAAEx8AABwfAAAUHwAAHR8AABUfAAAoHwAAIB8AACkfAAAhHwAAKh8AACIfAAArHwAAIx8AACwfAAAkHwAALR8AACUfAAAuHwAAJh8AAC8fAAAnHwAAOB8AADAfAAA5HwAAMR8AADofAAAyHwAAOx8AADMfAAA8HwAANB8AAD0fAAA1HwAAPh8AADYfAAA/HwAANx8AAEgfAABAHwAASR8AAEEfAABKHwAAQh8AAEsfAABDHwAATB8AAEQfAABNHwAARR8AAFkfAABRHwAAWx8AAFMfAABdHwAAVR8AAF8fAABXHwAAaB8AAGAfAABpHwAAYR8AAGofAABiHwAAax8AAGMfAABsHwAAZB8AAG0fAABlHwAAbh8AAGYfAABvHwAAZx8AAIgfAACAHwAAiR8AAIEfAACKHwAAgh8AAIsfAACDHwAAjB8AAIQfAACNHwAAhR8AAI4fAACGHwAAjx8AAIcfAACYHwAAkB8AAJkfAACRHwAAmh8AAJIfAACbHwAAkx8AAJwfAACUHwAAnR8AAJUfAACeHwAAlh8AAJ8fAACXHwAAqB8AAKAfAACpHwAAoR8AAKofAACiHwAAqx8AAKMfAACsHwAApB8AAK0fAAClHwAArh8AAKYfAACvHwAApx8AALgfAACwHwAAuR8AALEfAAC6HwAAcB8AALsfAABxHwAAvB8AALMfAADIHwAAch8AAMkfAABzHwAAyh8AAHQfAADLHwAAdR8AAMwfAADDHwAA2B8AANAfAADZHwAA0R8AANofAAB2HwAA2x8AAHcfAADoHwAA4B8AAOkfAADhHwAA6h8AAHofAADrHwAAex8AAOwfAADlHwAA+B8AAHgfAAD5HwAAeR8AAPofAAB8HwAA+x8AAH0fAAD8HwAA8x8AACYhAADJAwAAKiEAAGsAAAArIQAA5QAAADIhAABOIQAAYCEAAHAhAABhIQAAcSEAAGIhAAByIQAAYyEAAHMhAABkIQAAdCEAAGUhAAB1IQAAZiEAAHYhAABnIQAAdyEAAGghAAB4IQAAaSEAAHkhAABqIQAAeiEAAGshAAB7IQAAbCEAAHwhAABtIQAAfSEAAG4hAAB+IQAAbyEAAH8hAACDIQAAhCEAALYkAADQJAAAtyQAANEkAAC4JAAA0iQAALkkAADTJAAAuiQAANQkAAC7JAAA1SQAALwkAADWJAAAvSQAANckAAC+JAAA2CQAAL8kAADZJAAAwCQAANokAADBJAAA2yQAAMIkAADcJAAAwyQAAN0kAADEJAAA3iQAAMUkAADfJAAAxiQAAOAkAADHJAAA4SQAAMgkAADiJAAAySQAAOMkAADKJAAA5CQAAMskAADlJAAAzCQAAOYkAADNJAAA5yQAAM4kAADoJAAAzyQAAOkkAAAALAAAMCwAAAEsAAAxLAAAAiwAADIsAAADLAAAMywAAAQsAAA0LAAABSwAADUsAAAGLAAANiwAAAcsAAA3LAAACCwAADgsAAAJLAAAOSwAAAosAAA6LAAACywAADssAAAMLAAAPCwAAA0sAAA9LAAADiwAAD4sAAAPLAAAPywAABAsAABALAAAESwAAEEsAAASLAAAQiwAABMsAABDLAAAFCwAAEQsAAAVLAAARSwAABYsAABGLAAAFywAAEcsAAAYLAAASCwAABksAABJLAAAGiwAAEosAAAbLAAASywAABwsAABMLAAAHSwAAE0sAAAeLAAATiwAAB8sAABPLAAAICwAAFAsAAAhLAAAUSwAACIsAABSLAAAIywAAFMsAAAkLAAAVCwAACUsAABVLAAAJiwAAFYsAAAnLAAAVywAACgsAABYLAAAKSwAAFksAAAqLAAAWiwAACssAABbLAAALCwAAFwsAAAtLAAAXSwAAC4sAABeLAAALywAAF8sAABgLAAAYSwAAGIsAABrAgAAYywAAH0dAABkLAAAfQIAAGcsAABoLAAAaSwAAGosAABrLAAAbCwAAG0sAABRAgAAbiwAAHECAABvLAAAUAIAAHAsAABSAgAAciwAAHMsAAB1LAAAdiwAAH4sAAA/AgAAfywAAEACAACALAAAgSwAAIIsAACDLAAAhCwAAIUsAACGLAAAhywAAIgsAACJLAAAiiwAAIssAACMLAAAjSwAAI4sAACPLAAAkCwAAJEsAACSLAAAkywAAJQsAACVLAAAliwAAJcsAACYLAAAmSwAAJosAACbLAAAnCwAAJ0sAACeLAAAnywAAKAsAAChLAAAoiwAAKMsAACkLAAApSwAAKYsAACnLAAAqCwAAKksAACqLAAAqywAAKwsAACtLAAAriwAAK8sAACwLAAAsSwAALIsAACzLAAAtCwAALUsAAC2LAAAtywAALgsAAC5LAAAuiwAALssAAC8LAAAvSwAAL4sAAC/LAAAwCwAAMEsAADCLAAAwywAAMQsAADFLAAAxiwAAMcsAADILAAAySwAAMosAADLLAAAzCwAAM0sAADOLAAAzywAANAsAADRLAAA0iwAANMsAADULAAA1SwAANYsAADXLAAA2CwAANksAADaLAAA2ywAANwsAADdLAAA3iwAAN8sAADgLAAA4SwAAOIsAADjLAAA6ywAAOwsAADtLAAA7iwAAPIsAADzLAAAQKYAAEGmAABCpgAAQ6YAAESmAABFpgAARqYAAEemAABIpgAASaYAAEqmAABLpgAATKYAAE2mAABOpgAAT6YAAFCmAABRpgAAUqYAAFOmAABUpgAAVaYAAFamAABXpgAAWKYAAFmmAABapgAAW6YAAFymAABdpgAAXqYAAF+mAABgpgAAYaYAAGKmAABjpgAAZKYAAGWmAABmpgAAZ6YAAGimAABppgAAaqYAAGumAABspgAAbaYAAICmAACBpgAAgqYAAIOmAACEpgAAhaYAAIamAACHpgAAiKYAAImmAACKpgAAi6YAAIymAACNpgAAjqYAAI+mAACQpgAAkaYAAJKmAACTpgAAlKYAAJWmAACWpgAAl6YAAJimAACZpgAAmqYAAJumAAAipwAAI6cAACSnAAAlpwAAJqcAACenAAAopwAAKacAACqnAAArpwAALKcAAC2nAAAupwAAL6cAADKnAAAzpwAANKcAADWnAAA2pwAAN6cAADinAAA5pwAAOqcAADunAAA8pwAAPacAAD6nAAA/pwAAQKcAAEGnAABCpwAAQ6cAAESnAABFpwAARqcAAEenAABIpwAASacAAEqnAABLpwAATKcAAE2nAABOpwAAT6cAAFCnAABRpwAAUqcAAFOnAABUpwAAVacAAFanAABXpwAAWKcAAFmnAABapwAAW6cAAFynAABdpwAAXqcAAF+nAABgpwAAYacAAGKnAABjpwAAZKcAAGWnAABmpwAAZ6cAAGinAABppwAAaqcAAGunAABspwAAbacAAG6nAABvpwAAeacAAHqnAAB7pwAAfKcAAH2nAAB5HQAAfqcAAH+nAACApwAAgacAAIKnAACDpwAAhKcAAIWnAACGpwAAh6cAAIunAACMpwAAjacAAGUCAACQpwAAkacAAJKnAACTpwAAlqcAAJenAACYpwAAmacAAJqnAACbpwAAnKcAAJ2nAACepwAAn6cAAKCnAAChpwAAoqcAAKOnAACkpwAApacAAKanAACnpwAAqKcAAKmnAACqpwAAZgIAAKunAABcAgAArKcAAGECAACtpwAAbAIAAK6nAABqAgAAsKcAAJ4CAACxpwAAhwIAALKnAACdAgAAs6cAAFOrAAC0pwAAtacAALanAAC3pwAAuKcAALmnAAC6pwAAu6cAALynAAC9pwAAvqcAAL+nAADApwAAwacAAMKnAADDpwAAxKcAAJSnAADFpwAAggIAAManAACOHQAAx6cAAMinAADJpwAAyqcAANCnAADRpwAA1qcAANenAADYpwAA2acAAPWnAAD2pwAAIf8AAEH/AAAi/wAAQv8AACP/AABD/wAAJP8AAET/AAAl/wAARf8AACb/AABG/wAAJ/8AAEf/AAAo/wAASP8AACn/AABJ/wAAKv8AAEr/AAAr/wAAS/8AACz/AABM/wAALf8AAE3/AAAu/wAATv8AAC//AABP/wAAMP8AAFD/AAAx/wAAUf8AADL/AABS/wAAM/8AAFP/AAA0/wAAVP8AADX/AABV/wAANv8AAFb/AAA3/wAAV/8AADj/AABY/wAAOf8AAFn/AAA6/wAAWv8AAAAEAQAoBAEAAQQBACkEAQACBAEAKgQBAAMEAQArBAEABAQBACwEAQAFBAEALQQBAAYEAQAuBAEABwQBAC8EAQAIBAEAMAQBAAkEAQAxBAEACgQBADIEAQALBAEAMwQBAAwEAQA0BAEADQQBADUEAQAOBAEANgQBAA8EAQA3BAEAEAQBADgEAQARBAEAOQQBABIEAQA6BAEAEwQBADsEAQAUBAEAPAQBABUEAQA9BAEAFgQBAD4EAQAXBAEAPwQBABgEAQBABAEAGQQBAEEEAQAaBAEAQgQBABsEAQBDBAEAHAQBAEQEAQAdBAEARQQBAB4EAQBGBAEAHwQBAEcEAQAgBAEASAQBACEEAQBJBAEAIgQBAEoEAQAjBAEASwQBACQEAQBMBAEAJQQBAE0EAQAmBAEATgQBACcEAQBPBAEAsAQBANgEAQCxBAEA2QQBALIEAQDaBAEAswQBANsEAQC0BAEA3AQBALUEAQDdBAEAtgQBAN4EAQC3BAEA3wQBALgEAQDgBAEAuQQBAOEEAQC6BAEA4gQBALsEAQDjBAEAvAQBAOQEAQC9BAEA5QQBAL4EAQDmBAEAvwQBAOcEAQDABAEA6AQBAMEEAQDpBAEAwgQBAOoEAQDDBAEA6wQBAMQEAQDsBAEAxQQBAO0EAQDGBAEA7gQBAMcEAQDvBAEAyAQBAPAEAQDJBAEA8QQBAMoEAQDyBAEAywQBAPMEAQDMBAEA9AQBAM0EAQD1BAEAzgQBAPYEAQDPBAEA9wQBANAEAQD4BAEA0QQBAPkEAQDSBAEA+gQBANMEAQD7BAEAcAUBAJcFAQBxBQEAmAUBAHIFAQCZBQEAcwUBAJoFAQB0BQEAmwUBAHUFAQCcBQEAdgUBAJ0FAQB3BQEAngUBAHgFAQCfBQEAeQUBAKAFAQB6BQEAoQUBAHwFAQCjBQEAfQUBAKQFAQB+BQEApQUBAH8FAQCmBQEAgAUBAKcFAQCBBQEAqAUBAIIFAQCpBQEAgwUBAKoFAQCEBQEAqwUBAIUFAQCsBQEAhgUBAK0FAQCHBQEArgUBAIgFAQCvBQEAiQUBALAFAQCKBQEAsQUBAIwFAQCzBQEAjQUBALQFAQCOBQEAtQUBAI8FAQC2BQEAkAUBALcFAQCRBQEAuAUBAJIFAQC5BQEAlAUBALsFAQCVBQEAvAUBAIAMAQDADAEAgQwBAMEMAQCCDAEAwgwBAIMMAQDDDAEAhAwBAMQMAQCFDAEAxQwBAIYMAQDGDAEAhwwBAMcMAQCIDAEAyAwBAIkMAQDJDAEAigwBAMoMAQCLDAEAywwBAIwMAQDMDAEAjQwBAM0MAQCODAEAzgwBAI8MAQDPDAEAkAwBANAMAQCRDAEA0QwBAJIMAQDSDAEAkwwBANMMAQCUDAEA1AwBAJUMAQDVDAEAlgwBANYMAQCXDAEA1wwBAJgMAQDYDAEAmQwBANkMAQCaDAEA2gwBAJsMAQDbDAEAnAwBANwMAQCdDAEA3QwBAJ4MAQDeDAEAnwwBAN8MAQCgDAEA4AwBAKEMAQDhDAEAogwBAOIMAQCjDAEA4wwBAKQMAQDkDAEApQwBAOUMAQCmDAEA5gwBAKcMAQDnDAEAqAwBAOgMAQCpDAEA6QwBAKoMAQDqDAEAqwwBAOsMAQCsDAEA7AwBAK0MAQDtDAEArgwBAO4MAQCvDAEA7wwBALAMAQDwDAEAsQwBAPEMAQCyDAEA8gwBAKAYAQDAGAEAoRgBAMEYAQCiGAEAwhgBAKMYAQDDGAEApBgBAMQYAQClGAEAxRgBAKYYAQDGGAEApxgBAMcYAQCoGAEAyBgBAKkYAQDJGAEAqhgBAMoYAQCrGAEAyxgBAKwYAQDMGAEArRgBAM0YAQCuGAEAzhgBAK8YAQDPGAEAsBgBANAYAQCxGAEA0RgBALIYAQDSGAEAsxgBANMYAQC0GAEA1BgBALUYAQDVGAEAthgBANYYAQC3GAEA1xgBALgYAQDYGAEAuRgBANkYAQC6GAEA2hgBALsYAQDbGAEAvBgBANwYAQC9GAEA3RgBAL4YAQDeGAEAvxgBAN8YAQBAbgEAYG4BAEFuAQBhbgEAQm4BAGJuAQBDbgEAY24BAERuAQBkbgEARW4BAGVuAQBGbgEAZm4BAEduAQBnbgEASG4BAGhuAQBJbgEAaW4BAEpuAQBqbgEAS24BAGtuAQBMbgEAbG4BAE1uAQBtbgEATm4BAG5uAQBPbgEAb24BAFBuAQBwbgEAUW4BAHFuAQBSbgEAcm4BAFNuAQBzbgEAVG4BAHRuAQBVbgEAdW4BAFZuAQB2bgEAV24BAHduAQBYbgEAeG4BAFluAQB5bgEAWm4BAHpuAQBbbgEAe24BAFxuAQB8bgEAXW4BAH1uAQBebgEAfm4BAF9uAQB/bgEAAOkBACLpAQAB6QEAI+kBAALpAQAk6QEAA+kBACXpAQAE6QEAJukBAAXpAQAn6QEABukBACjpAQAH6QEAKekBAAjpAQAq6QEACekBACvpAQAK6QEALOkBAAvpAQAt6QEADOkBAC7pAQAN6QEAL+kBAA7pAQAw6QEAD+kBADHpAQAQ6QEAMukBABHpAQAz6QEAEukBADTpAQAT6QEANekBABTpAQA26QEAFekBADfpAQAW6QEAOOkBABfpAQA56QEAGOkBADrpAQAZ6QEAO+kBABrpAQA86QEAG+kBAD3pAQAc6QEAPukBAB3pAQA/6QEAHukBAEDpAQAf6QEAQekBACDpAQBC6QEAIekBAEPpAQBvCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS43Ni4wICgwN2RjYTQ4OWEgMjAyNC0wMi0wNCkGd2FscnVzBjAuMjAuMwx3YXNtLWJpbmRnZW4GMC4yLjkyACwPdGFyZ2V0X2ZlYXR1cmVzAisPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dA==";
      const binary = atob(base64);
      const array = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        array[i] = binary.charCodeAt(i);
      }
      return array.buffer;
    })();
    var wasmModule = new WebAssembly.Module(bytes);
    var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
    wasm = wasmInstance.exports;
    module.exports.__wasm = wasm;
  }
});
var Bitcoin = __toESM(require_bitcoin(), 1);
var networkToBitcoinNetwork = /* @__PURE__ */ __name((network) => {
  switch (network) {
    case "mainnet":
      return Bitcoin.BitcoinNetwork.Mainnet;
    case "perseverance":
    case "sisyphos":
    case "testnet":
      return Bitcoin.BitcoinNetwork.Testnet;
    case "backspin":
    case "regtest":
      return Bitcoin.BitcoinNetwork.Regtest;
    default:
      throw new Error(`Invalid network: ${network}`);
  }
}, "networkToBitcoinNetwork");
var isValidAddressForNetwork2 = /* @__PURE__ */ __name((address, network) => Bitcoin.isValidAddressForNetwork(address, networkToBitcoinNetwork(network)), "isValidAddressForNetwork2");
var validatePolkadotAddress = /* @__PURE__ */ __name((address) => {
  try {
    ss582.decode(address);
    return true;
  } catch {
    return false;
  }
}, "validatePolkadotAddress");
var validateEvmAddress = /* @__PURE__ */ __name((address) => ethers.isAddress(address), "validateEvmAddress");
var validateBitcoinMainnetAddress = /* @__PURE__ */ __name((address) => isValidAddressForNetwork2(address, "mainnet"), "validateBitcoinMainnetAddress");
var validateBitcoinTestnetAddress = /* @__PURE__ */ __name((address) => isValidAddressForNetwork2(address, "testnet"), "validateBitcoinTestnetAddress");
var validateBitcoinRegtestAddress = /* @__PURE__ */ __name((address) => isValidAddressForNetwork2(address, "regtest"), "validateBitcoinRegtestAddress");
var validators = {
  mainnet: {
    Bitcoin: validateBitcoinMainnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress
  },
  perseverance: {
    Bitcoin: validateBitcoinTestnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress
  },
  sisyphos: {
    Bitcoin: validateBitcoinTestnetAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress
  },
  backspin: {
    Bitcoin: validateBitcoinRegtestAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress
  },
  localnet: {
    Bitcoin: validateBitcoinRegtestAddress,
    Ethereum: validateEvmAddress,
    Polkadot: validatePolkadotAddress,
    Arbitrum: validateEvmAddress
  }
};
var assertValidAddress = /* @__PURE__ */ __name((chain2, address, network) => assert(validators[network][chain2](address), `Address "${address}" is not a valid "${chain2}" address for "${network}"`), "assertValidAddress");

// ../shared/src/parsers.ts
var enumValues = Object.values;
var safeStringify = /* @__PURE__ */ __name((obj) => JSON.stringify(obj, (key, value) => typeof value === "bigint" ? value.toString() : value), "safeStringify");
var errorMap2 = /* @__PURE__ */ __name((_issue, context) => ({
  message: `received: ${safeStringify(context.data)}`
}), "errorMap");
var string = z.string({
  errorMap: errorMap2
});
var number = z.number({
  errorMap: errorMap2
});
var numericString = string.regex(/^[0-9]+$/);
var numericOrEmptyString = string.regex(/^[0-9]*$/);
var hexString = string.refine((v) => /^0x[0-9a-f]*$/i.test(v));
var hexStringWithMaxByteSize = /* @__PURE__ */ __name((maxByteSize) => hexString.refine((val) => val.length / 2 <= maxByteSize + 1, {
  message: `String must be less than or equal to ${maxByteSize} bytes`
}), "hexStringWithMaxByteSize");
var btcAddress = /* @__PURE__ */ __name((network) => {
  if (network === "mainnet") {
    return string.regex(/^(1|3|bc1)/).refine(validateBitcoinMainnetAddress, (address) => ({
      message: `"${address}" is not a valid Bitcoin mainnet address`
    }));
  }
  return z.union([
    string.regex(/^(m|n|2|tb1)/).refine(validateBitcoinTestnetAddress, (address) => ({
      message: `"${address}" is not a valid Bitcoin testnet address`
    })),
    string.regex(/^bcrt1/).refine(validateBitcoinRegtestAddress, (address) => ({
      message: `"${address}" is not a valid Bitcoin regtest address`
    }))
  ]);
}, "btcAddress");
var DOT_PREFIX = 0;
var dotAddress = z.union([
  string,
  hexString
]).transform((arg) => {
  try {
    if (arg.startsWith("0x")) {
      return ss582.encode({
        data: arg,
        ss58Format: DOT_PREFIX
      });
    }
    return ss582.encode({
      data: ss582.decode(arg).data,
      ss58Format: DOT_PREFIX
    });
  } catch {
    return null;
  }
}).refine(isString, {
  message: `address is not a valid polkadot address`
});
var ethereumAddress = hexString.refine((address) => ethers.isAddress(address), (address) => ({
  message: `${address} is not a valid ethereum address`
}));
var chainflipAddress = string.refine((address) => address.startsWith("cF") && ss582.decode(address), (address) => ({
  message: `${address} is not a valid chainflip address`
}));
numericString.transform((arg) => BigInt(arg));
var u128 = z.union([
  number,
  numericString,
  hexString
]).transform((arg) => BigInt(arg));
var unsignedInteger = z.union([
  u128,
  z.number().transform((n) => BigInt(n))
]);
var rustEnum = /* @__PURE__ */ __name((values) => z.object({
  __kind: z.enum(values)
}).transform(({ __kind }) => __kind), "rustEnum");
rustEnum(enumValues(InternalAssets));
rustEnum(enumValues(Chains));
var chain = z.nativeEnum(Chains);
var asset = z.nativeEnum(Assets);
z.nativeEnum(ChainflipNetworks);
var uncheckedAssetAndChain = z.object({
  asset: z.string(),
  chain: z.string()
});
var assetAndChain = uncheckedAssetAndChain.refine((value) => isValidAssetAndChain(value));
z.union([
  z.object({
    __kind: z.literal("CcmPrincipal"),
    value: unsignedInteger
  }).transform(({ value: ccmId }) => ({
    type: "PRINCIPAL",
    ccmId
  })),
  z.object({
    __kind: z.literal("CcmGas"),
    value: unsignedInteger
  }).transform(({ value: ccmId }) => ({
    type: "GAS",
    ccmId
  })),
  z.object({
    __kind: z.literal("Swap")
  }).transform(() => ({
    type: "SWAP"
  }))
]);
var chainflipSS58Prefix = 2112;
z.union([
  hexString,
  string.regex(/^[a-f\d]$/i).transform((value) => `0x${value}`)
]).transform((value) => ss582.encode({
  data: value,
  ss58Format: chainflipSS58Prefix
}));
z.union([
  z.object({
    __kind: z.literal("Swap"),
    swapId: u128
  }),
  z.object({
    __kind: z.literal("LiquidityProvision"),
    lpAccount: hexString
  }),
  z.object({
    __kind: z.literal("CcmTransfer"),
    principalSwapId: u128.nullable().optional(),
    gasSwapId: u128.nullable().optional()
  }),
  z.object({
    __kind: z.literal("NoAction")
  }),
  z.object({
    __kind: z.literal("BoostersCredited"),
    prewitnessedDepositId: u128
  })
]);

// ../shared/src/schemas.ts
z.object({
  srcChain: chain,
  srcAsset: asset,
  destChain: chain,
  destAsset: asset,
  amount: numericString.transform((n) => BigInt(n)),
  brokerCommissionBps: numericOrEmptyString.transform((v) => Number(v)).optional()
}).transform((args, ctx) => {
  const { srcAsset, destAsset } = getInternalAssets(args, false);
  if (srcAsset === null) {
    ctx.addIssue({
      message: `invalid asset and chain combination: ${JSON.stringify({
        asset: args.srcAsset,
        chain: args.srcChain
      })}`,
      code: z.ZodIssueCode.custom
    });
    return z.NEVER;
  }
  if (destAsset === null) {
    ctx.addIssue({
      message: `invalid asset and chain combination: ${JSON.stringify({
        asset: args.destAsset,
        chain: args.destChain
      })}`,
      code: z.ZodIssueCode.custom
    });
    return z.NEVER;
  }
  return {
    srcAsset,
    destAsset,
    amount: args.amount,
    brokerCommissionBps: args.brokerCommissionBps
  };
});
var ccmMetadataSchema = z.object({
  gasBudget: numericString,
  message: hexStringWithMaxByteSize(1024 * 10)
});
var affiliateBroker = z.object({
  account: chainflipAddress,
  commissionBps: number
}).transform(({ account, commissionBps: bps }) => ({
  account,
  bps
}));
z.object({
  srcAsset: asset,
  destAsset: asset,
  srcChain: chain,
  destChain: chain,
  destAddress: z.string(),
  amount: numericString,
  ccmMetadata: ccmMetadataSchema.optional(),
  maxBoostFeeBps: z.number().optional(),
  srcAddress: z.string().optional()
}).transform(({ amount, ...rest }) => ({
  ...rest,
  expectedDepositAmount: amount
}));

export { affiliateBroker, assertValidAddress, assetAndChain, btcAddress, ccmMetadataSchema, dotAddress, ethereumAddress, hexString, numericString, z };
