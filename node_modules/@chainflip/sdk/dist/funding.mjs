import { getFlipBalance, getFundingEnvironment, getStateChainGatewayContractAddress, approve, getTokenContractAddress, checkAllowance, extractOverrides, StateChainGateway__factory } from './chunk-M32JHS3U.mjs';
import { __name, __publicField, ChainflipNetworks, InternalAssets, assert } from './chunk-3V7QJANN.mjs';

// ../shared/src/stateChainGateway/utils.ts
var getStateChainGateway = /* @__PURE__ */ __name((networkOpts) => {
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return StateChainGateway__factory.connect(stateChainGatewayContractAddress, networkOpts.signer);
}, "getStateChainGateway");

// ../shared/src/stateChainGateway/approval.ts
var checkStateChainGatewayAllowance = /* @__PURE__ */ __name(async (amount, networkOpts) => {
  const flipContractAddress = networkOpts.network === "localnet" ? networkOpts.flipContractAddress : getTokenContractAddress(InternalAssets.Flip, networkOpts.network);
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return checkAllowance(amount, stateChainGatewayContractAddress, flipContractAddress, networkOpts.signer);
}, "checkStateChainGatewayAllowance");
var approveStateChainGateway = /* @__PURE__ */ __name(async (amount, networkOpts, txOpts) => {
  const { allowance, erc20, hasSufficientAllowance } = await checkStateChainGatewayAllowance(amount, networkOpts);
  if (hasSufficientAllowance) return null;
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return approve(amount, stateChainGatewayContractAddress, erc20, allowance, txOpts);
}, "approveStateChainGateway");

// ../shared/src/stateChainGateway/index.ts
var fundStateChainAccount = /* @__PURE__ */ __name(async (accountId, amount, networkOpts, txOpts) => {
  const flipContractAddress = networkOpts.network === "localnet" ? networkOpts.flipContractAddress : getTokenContractAddress(InternalAssets.Flip, networkOpts.network);
  const stateChainGateway = getStateChainGateway(networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(amount, await stateChainGateway.getAddress(), flipContractAddress, networkOpts.signer);
  assert(hasSufficientAllowance, "Insufficient allowance");
  const transaction = await stateChainGateway.fundStateChainAccount(accountId, amount, extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "fundStateChainAccount");
var executeRedemption = /* @__PURE__ */ __name(async (accountId, networkOpts, txOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  const transaction = await stateChainGateway.executeRedemption(accountId, extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "executeRedemption");
var getMinimumFunding = /* @__PURE__ */ __name((networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  return stateChainGateway.getMinimumFunding();
}, "getMinimumFunding");
var getRedemptionDelay = /* @__PURE__ */ __name((networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  return stateChainGateway.REDEMPTION_DELAY();
}, "getRedemptionDelay");
var getPendingRedemption = /* @__PURE__ */ __name(async (accountId, networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  const pendingRedemption = await stateChainGateway.getPendingRedemption(accountId);
  return pendingRedemption.amount !== 0n ? stateChainGateway.getPendingRedemption(accountId) : void 0;
}, "getPendingRedemption");

// src/funding/sdk.ts
var _FundingSDK = class _FundingSDK {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "rpcConfig");
    __publicField(this, "redemptionTax");
    const network = options.network ?? ChainflipNetworks.perseverance;
    this.options = {
      ...options,
      network
    };
    this.rpcConfig = options.rpcUrl ? {
      rpcUrl: options.rpcUrl
    } : {
      network
    };
  }
  /**
  * @param accountId the hex-encoded validator account id
  * @param amount the amount to fund in base units of FLIP
  */
  async fundStateChainAccount(accountId, amount, txOpts = {}) {
    const tx = await fundStateChainAccount(accountId, amount, this.options, txOpts);
    return tx.hash;
  }
  /**
  * @param accountId the hex-encoded validator account id
  */
  async executeRedemption(accountId, txOpts = {}) {
    const tx = await executeRedemption(accountId, this.options, txOpts);
    return tx.hash;
  }
  async getMinimumFunding() {
    return getMinimumFunding(this.options);
  }
  async getRedemptionDelay() {
    return getRedemptionDelay(this.options);
  }
  async getFlipBalance() {
    return getFlipBalance(this.options.network, this.options.signer);
  }
  async getPendingRedemption(accountId) {
    return getPendingRedemption(accountId, this.options);
  }
  /**
  * @param the amount of FLIP to request approval for
  * @returns the transaction hash or null if no approval was required
  */
  async approveStateChainGateway(amount, txOpts = {}) {
    const tx = await approveStateChainGateway(amount, this.options, txOpts);
    return tx ? tx.hash : null;
  }
  async getRedemptionTax() {
    this.redemptionTax ?? (this.redemptionTax = (await getFundingEnvironment(this.rpcConfig)).redemptionTax);
    return this.redemptionTax;
  }
};
__name(_FundingSDK, "FundingSDK");
var FundingSDK = _FundingSDK;

export { FundingSDK };
