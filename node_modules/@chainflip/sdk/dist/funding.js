'use strict';

var ethers = require('ethers');
var rpc = require('@chainflip/rpc');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _ERC20__factory = class _ERC20__factory {
  static createInterface() {
    return new ethers.Interface(_abi);
  }
  static connect(address, runner) {
    return new ethers.Contract(address, _abi, runner);
  }
};
__name(_ERC20__factory, "ERC20__factory");
__publicField(_ERC20__factory, "abi", _abi);
var ERC20__factory = _ERC20__factory;
var _abi2 = [
  {
    inputs: [
      {
        internalType: "contract IKeyManager",
        name: "keyManager",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "minFunding",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "communityGuardDisabled",
        type: "bool"
      }
    ],
    name: "CommunityGuardDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "flip",
        type: "address"
      }
    ],
    name: "FLIPSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldSupply",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newSupply",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "stateChainBlockNumber",
        type: "uint256"
      }
    ],
    name: "FlipSupplyUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "funder",
        type: "address"
      }
    ],
    name: "Funded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "GovernanceWithdrawal",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "oldMinFunding",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newMinFunding",
        type: "uint256"
      }
    ],
    name: "MinFundingChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RedemptionExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RedemptionExpired",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "redeemAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint48",
        name: "startTime",
        type: "uint48"
      },
      {
        indexed: false,
        internalType: "uint48",
        name: "expiryTime",
        type: "uint48"
      }
    ],
    name: "RedemptionRegistered",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "suspended",
        type: "bool"
      }
    ],
    name: "Suspended",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "keyManager",
        type: "address"
      }
    ],
    name: "UpdatedKeyManager",
    type: "event"
  },
  {
    inputs: [],
    name: "REDEMPTION_DELAY",
    outputs: [
      {
        internalType: "uint48",
        name: "",
        type: "uint48"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "disableCommunityGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableCommunityGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      }
    ],
    name: "executeRedemption",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "fundStateChainAccount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getCommunityGuardDisabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCommunityKey",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getFLIP",
    outputs: [
      {
        internalType: "contract IFLIP",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getGovernor",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getKeyManager",
    outputs: [
      {
        internalType: "contract IKeyManager",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastSupplyUpdateBlockNumber",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getMinimumFunding",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      }
    ],
    name: "getPendingRedemption",
    outputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "redeemAddress",
            type: "address"
          },
          {
            internalType: "uint48",
            name: "startTime",
            type: "uint48"
          },
          {
            internalType: "uint48",
            name: "expiryTime",
            type: "uint48"
          }
        ],
        internalType: "struct IStateChainGateway.Redemption",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSuspendedState",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "govUpdateFlipIssuer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "govWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "bytes32",
        name: "nodeID",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "redeemAddress",
        type: "address"
      },
      {
        internalType: "uint48",
        name: "expiryTime",
        type: "uint48"
      }
    ],
    name: "registerRedemption",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "resume",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IFLIP",
        name: "flip",
        type: "address"
      }
    ],
    name: "setFlip",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newMinFunding",
        type: "uint256"
      }
    ],
    name: "setMinFunding",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "suspend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "newIssuer",
        type: "address"
      },
      {
        internalType: "bool",
        name: "omitChecks",
        type: "bool"
      }
    ],
    name: "updateFlipIssuer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "uint256",
        name: "newTotalSupply",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "stateChainBlockNumber",
        type: "uint256"
      }
    ],
    name: "updateFlipSupply",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "contract IKeyManager",
        name: "keyManager",
        type: "address"
      },
      {
        internalType: "bool",
        name: "omitChecks",
        type: "bool"
      }
    ],
    name: "updateKeyManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var _StateChainGateway__factory = class _StateChainGateway__factory {
  static createInterface() {
    return new ethers.Interface(_abi2);
  }
  static connect(address, runner) {
    return new ethers.Contract(address, _abi2, runner);
  }
};
__name(_StateChainGateway__factory, "StateChainGateway__factory");
__publicField(_StateChainGateway__factory, "abi", _abi2);
var StateChainGateway__factory = _StateChainGateway__factory;

// ../shared/src/enums.ts
var arrayToMap = /* @__PURE__ */ __name((array) => Object.fromEntries(array.map((key) => [
  key,
  key
])), "arrayToMap");
var InternalAssets = arrayToMap([
  "Flip",
  "Usdc",
  "Dot",
  "Eth",
  "Btc",
  "Usdt",
  "ArbUsdc",
  "ArbEth"
]);
var Chains = arrayToMap([
  "Bitcoin",
  "Ethereum",
  "Polkadot",
  "Arbitrum"
]);
var Assets = arrayToMap([
  "FLIP",
  "USDC",
  "DOT",
  "ETH",
  "BTC",
  "USDT"
]);
var ChainflipNetworks = arrayToMap([
  "backspin",
  "sisyphos",
  "perseverance",
  "mainnet"
]);
({
  [InternalAssets.Eth]: {
    chain: Chains.Ethereum,
    asset: Assets.ETH,
    name: "Ether",
    decimals: 18,
    contractId: 1
  },
  [InternalAssets.Flip]: {
    chain: Chains.Ethereum,
    asset: Assets.FLIP,
    name: "FLIP",
    decimals: 18,
    contractId: 2
  },
  [InternalAssets.Usdc]: {
    chain: Chains.Ethereum,
    asset: Assets.USDC,
    name: "USDC",
    decimals: 6,
    contractId: 3
  },
  [InternalAssets.Usdt]: {
    chain: Chains.Ethereum,
    asset: Assets.USDT,
    name: "USDT",
    decimals: 6,
    contractId: 8
  },
  [InternalAssets.Dot]: {
    chain: Chains.Polkadot,
    asset: Assets.DOT,
    name: "Polkadot",
    decimals: 10,
    contractId: 4
  },
  [InternalAssets.Btc]: {
    chain: Chains.Bitcoin,
    asset: Assets.BTC,
    name: "Bitcoin",
    decimals: 8,
    contractId: 5
  },
  [InternalAssets.ArbEth]: {
    chain: Chains.Arbitrum,
    asset: Assets.ETH,
    name: "Arbitrum Ether",
    decimals: 18,
    contractId: 6
  },
  [InternalAssets.ArbUsdc]: {
    chain: Chains.Arbitrum,
    asset: Assets.USDC,
    name: "Arbitrum USDC",
    decimals: 6,
    contractId: 7
  }
});
var chainConstants = {
  [Chains.Ethereum]: {
    assets: [
      Assets.ETH,
      Assets.FLIP,
      Assets.USDC,
      Assets.USDT
    ],
    gasAsset: Assets.ETH,
    contractId: 1,
    blockTimeSeconds: 12
  },
  [Chains.Polkadot]: {
    assets: [
      Assets.DOT
    ],
    gasAsset: Assets.DOT,
    contractId: 2,
    blockTimeSeconds: 6
  },
  [Chains.Bitcoin]: {
    assets: [
      Assets.BTC
    ],
    gasAsset: Assets.BTC,
    contractId: 3,
    blockTimeSeconds: 10 * 60
  },
  [Chains.Arbitrum]: {
    assets: [
      Assets.ETH,
      Assets.USDC
    ],
    gasAsset: Assets.ETH,
    contractId: 4,
    blockTimeSeconds: 0.26
  }
};
function isValidAssetAndChain(assetAndChain) {
  const { asset, chain } = assetAndChain;
  if (!(chain in Chains)) return false;
  const validAssets = chainConstants[chain].assets;
  return validAssets.includes(asset);
}
__name(isValidAssetAndChain, "isValidAssetAndChain");
function getInternalAsset(asset, assert2 = true) {
  if (!isValidAssetAndChain(asset)) {
    if (assert2) {
      throw new Error(`invalid asset and chain combination: ${JSON.stringify(asset)}`);
    }
    return null;
  }
  const map = {
    [Chains.Ethereum]: {
      [Assets.USDC]: InternalAssets.Usdc,
      [Assets.FLIP]: InternalAssets.Flip,
      [Assets.ETH]: InternalAssets.Eth,
      [Assets.USDT]: InternalAssets.Usdt
    },
    [Chains.Bitcoin]: {
      [Assets.BTC]: InternalAssets.Btc
    },
    [Chains.Polkadot]: {
      [Assets.DOT]: InternalAssets.Dot
    },
    [Chains.Arbitrum]: {
      [Assets.USDC]: InternalAssets.ArbUsdc,
      [Assets.ETH]: InternalAssets.ArbEth
    }
  };
  const chain = map[asset.chain];
  return chain[asset.asset];
}
__name(getInternalAsset, "getInternalAsset");

// ../shared/src/consts.ts
({
  [ChainflipNetworks.backspin]: 1e3,
  [ChainflipNetworks.sisyphos]: 1e3,
  [ChainflipNetworks.perseverance]: 1e3,
  [ChainflipNetworks.mainnet]: 1e3
});
({
  [ChainflipNetworks.backspin]: 10997,
  [ChainflipNetworks.sisyphos]: 11155111,
  [ChainflipNetworks.perseverance]: 11155111,
  [ChainflipNetworks.mainnet]: 1
});
({
  [ChainflipNetworks.backspin]: 412346,
  [ChainflipNetworks.sisyphos]: 421614,
  [ChainflipNetworks.perseverance]: 421614,
  [ChainflipNetworks.mainnet]: 42161
});
var SEPOLIA_USDC_CONTRACT_ADDRESS = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
var SEPOLIA_USDT_CONTRACT_ADDRESS = "0x27CEA6Eb8a21Aae05Eb29C91c5CA10592892F584";
var ADDRESSES = {
  [ChainflipNetworks.backspin]: {
    FLIP_CONTRACT_ADDRESS: "0x10C6E9530F1C1AF873a391030a1D9E8ed0630D26",
    USDC_CONTRACT_ADDRESS: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    USDT_CONTRACT_ADDRESS: "0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82",
    ARBUSDC_CONTRACT_ADDRESS: "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    VAULT_CONTRACT_ADDRESS: "0xB7A5bd0345EF1Cc5E66bf61BdeC17D2461fBd968",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xeEBe00Ac0756308ac4AaBfD76c05c4F3088B8883",
    ARB_VAULT_CONTRACT_ADDRESS: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
  },
  [ChainflipNetworks.sisyphos]: {
    FLIP_CONTRACT_ADDRESS: "0xcD079EAB6B5443b545788Fd210C8800FEADd87fa",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    VAULT_CONTRACT_ADDRESS: "0xa94d6b1853F3cb611Ed3cCb701b4fdA5a9DACe85",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x1F7fE41C798cc7b1D34BdC8de2dDDA4a4bE744D9",
    ARB_VAULT_CONTRACT_ADDRESS: "0x8155BdD48CD011e1118b51A1C82be020A3E5c2f2"
  },
  [ChainflipNetworks.perseverance]: {
    FLIP_CONTRACT_ADDRESS: "0xdC27c60956cB065D19F08bb69a707E37b36d8086",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    VAULT_CONTRACT_ADDRESS: "0x36eaD71325604DC15d35FAE584D7b50646D81753",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xA34a967197Ee90BB7fb28e928388a573c5CFd099",
    ARB_VAULT_CONTRACT_ADDRESS: "0x2bb150e6d4366A1BDBC4275D1F35892CD63F27e3"
  },
  [ChainflipNetworks.mainnet]: {
    FLIP_CONTRACT_ADDRESS: "0x826180541412D574cf1336d22c0C0a287822678A",
    USDC_CONTRACT_ADDRESS: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    USDT_CONTRACT_ADDRESS: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    ARBUSDC_CONTRACT_ADDRESS: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    VAULT_CONTRACT_ADDRESS: "0xF5e10380213880111522dd0efD3dbb45b9f62Bcc",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x6995Ab7c4D7F4B03f467Cf4c8E920427d9621DBd",
    ARB_VAULT_CONTRACT_ADDRESS: "0x79001a5e762f3bEFC8e5871b42F6734e00498920"
  }
};

// ../shared/src/contracts.ts
var extractOverrides = /* @__PURE__ */ __name((transactionOverrides) => {
  const { wait, ...ethersOverrides } = transactionOverrides;
  return ethersOverrides;
}, "extractOverrides");
function getTokenContractAddress(asset, network) {
  if (asset === InternalAssets.Flip) return ADDRESSES[network].FLIP_CONTRACT_ADDRESS;
  if (asset === InternalAssets.Usdc) return ADDRESSES[network].USDC_CONTRACT_ADDRESS;
  if (asset === InternalAssets.Usdt) return ADDRESSES[network].USDT_CONTRACT_ADDRESS;
  if (asset === InternalAssets.ArbUsdc) return ADDRESSES[network].ARBUSDC_CONTRACT_ADDRESS;
  throw new Error(`No contract address for ${asset} on ${network}`);
}
__name(getTokenContractAddress, "getTokenContractAddress");
var getStateChainGatewayContractAddress = /* @__PURE__ */ __name((network) => ADDRESSES[network].STATE_CHAIN_GATEWAY_ADDRESS, "getStateChainGatewayContractAddress");
var checkAllowance = /* @__PURE__ */ __name(async (amount, spenderAddress, erc20Address, signer) => {
  const erc20 = ERC20__factory.connect(erc20Address, signer);
  const signerAddress = await signer.getAddress();
  const allowance = await erc20.allowance(signerAddress, spenderAddress);
  return {
    allowance,
    hasSufficientAllowance: allowance >= amount,
    erc20
  };
}, "checkAllowance");
var approve = /* @__PURE__ */ __name(async (amount, spenderAddress, erc20, allowance, txOpts) => {
  if (allowance >= amount) return null;
  const transaction = await erc20.approve(spenderAddress, amount - allowance, extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "approve");
var getFlipBalance = /* @__PURE__ */ __name(async (network, signer) => {
  const flipAddress = getTokenContractAddress(InternalAssets.Flip, network);
  const flip = ERC20__factory.connect(flipAddress, signer);
  return flip.balanceOf(await signer.getAddress());
}, "getFlipBalance");
var camelCase = /* @__PURE__ */ __name((str) => str.replace(/_([a-z])/g, (_, char) => char.toUpperCase()), "camelCase");
var camelCaseKeys = /* @__PURE__ */ __name((obj) => {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map((item) => camelCaseKeys(item));
  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [
    camelCase(key),
    camelCaseKeys(value)
  ]));
}, "camelCaseKeys");
var createRequest = /* @__PURE__ */ __name((method) => async (urlOrNetwork, ...params) => {
  const url = "network" in urlOrNetwork ? rpc.constants.PUBLIC_RPC_ENDPOINTS[urlOrNetwork.network] : urlOrNetwork.rpcUrl;
  const result = await new rpc.HttpClient(url).sendRequest(method, ...params);
  return camelCaseKeys(result);
}, "createRequest");
var transform = /* @__PURE__ */ __name((fn, cb) => (...args) => fn(...args).then(cb), "transform");
var getFundingEnvironment = createRequest("cf_funding_environment");
createRequest("cf_swapping_environment");
createRequest("cf_ingress_egress_environment");
createRequest("cf_environment");
createRequest("cf_swap_rate");
createRequest("state_getMetadata");
createRequest("cf_supported_assets");
createRequest("state_getRuntimeVersion");
createRequest("chain_getBlockHash");
transform(createRequest("cf_boost_pools_depth"), (result) => result.map(({ chain, asset, ...rest }) => ({
  asset: getInternalAsset({
    chain,
    asset
  }),
  ...rest
})));
createRequest("cf_swap_rate_v2");

// ../shared/src/stateChainGateway/utils.ts
var getStateChainGateway = /* @__PURE__ */ __name((networkOpts) => {
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return StateChainGateway__factory.connect(stateChainGatewayContractAddress, networkOpts.signer);
}, "getStateChainGateway");

// ../shared/src/guards.ts
function assert(condition, message) {
  if (condition) return;
  const error = new Error(message);
  if (error.stack) {
    error.stack = error.stack.replace(/\n.+/, "\n");
  }
  throw error;
}
__name(assert, "assert");

// ../shared/src/stateChainGateway/approval.ts
var checkStateChainGatewayAllowance = /* @__PURE__ */ __name(async (amount, networkOpts) => {
  const flipContractAddress = networkOpts.network === "localnet" ? networkOpts.flipContractAddress : getTokenContractAddress(InternalAssets.Flip, networkOpts.network);
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return checkAllowance(amount, stateChainGatewayContractAddress, flipContractAddress, networkOpts.signer);
}, "checkStateChainGatewayAllowance");
var approveStateChainGateway = /* @__PURE__ */ __name(async (amount, networkOpts, txOpts) => {
  const { allowance, erc20, hasSufficientAllowance } = await checkStateChainGatewayAllowance(amount, networkOpts);
  if (hasSufficientAllowance) return null;
  const stateChainGatewayContractAddress = networkOpts.network === "localnet" ? networkOpts.stateChainGatewayContractAddress : getStateChainGatewayContractAddress(networkOpts.network);
  return approve(amount, stateChainGatewayContractAddress, erc20, allowance, txOpts);
}, "approveStateChainGateway");

// ../shared/src/stateChainGateway/index.ts
var fundStateChainAccount = /* @__PURE__ */ __name(async (accountId, amount, networkOpts, txOpts) => {
  const flipContractAddress = networkOpts.network === "localnet" ? networkOpts.flipContractAddress : getTokenContractAddress(InternalAssets.Flip, networkOpts.network);
  const stateChainGateway = getStateChainGateway(networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(amount, await stateChainGateway.getAddress(), flipContractAddress, networkOpts.signer);
  assert(hasSufficientAllowance, "Insufficient allowance");
  const transaction = await stateChainGateway.fundStateChainAccount(accountId, amount, extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "fundStateChainAccount");
var executeRedemption = /* @__PURE__ */ __name(async (accountId, networkOpts, txOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  const transaction = await stateChainGateway.executeRedemption(accountId, extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "executeRedemption");
var getMinimumFunding = /* @__PURE__ */ __name((networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  return stateChainGateway.getMinimumFunding();
}, "getMinimumFunding");
var getRedemptionDelay = /* @__PURE__ */ __name((networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  return stateChainGateway.REDEMPTION_DELAY();
}, "getRedemptionDelay");
var getPendingRedemption = /* @__PURE__ */ __name(async (accountId, networkOpts) => {
  const stateChainGateway = getStateChainGateway(networkOpts);
  const pendingRedemption = await stateChainGateway.getPendingRedemption(accountId);
  return pendingRedemption.amount !== 0n ? stateChainGateway.getPendingRedemption(accountId) : void 0;
}, "getPendingRedemption");

// src/funding/sdk.ts
var _FundingSDK = class _FundingSDK {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "rpcConfig");
    __publicField(this, "redemptionTax");
    const network = options.network ?? ChainflipNetworks.perseverance;
    this.options = {
      ...options,
      network
    };
    this.rpcConfig = options.rpcUrl ? {
      rpcUrl: options.rpcUrl
    } : {
      network
    };
  }
  /**
  * @param accountId the hex-encoded validator account id
  * @param amount the amount to fund in base units of FLIP
  */
  async fundStateChainAccount(accountId, amount, txOpts = {}) {
    const tx = await fundStateChainAccount(accountId, amount, this.options, txOpts);
    return tx.hash;
  }
  /**
  * @param accountId the hex-encoded validator account id
  */
  async executeRedemption(accountId, txOpts = {}) {
    const tx = await executeRedemption(accountId, this.options, txOpts);
    return tx.hash;
  }
  async getMinimumFunding() {
    return getMinimumFunding(this.options);
  }
  async getRedemptionDelay() {
    return getRedemptionDelay(this.options);
  }
  async getFlipBalance() {
    return getFlipBalance(this.options.network, this.options.signer);
  }
  async getPendingRedemption(accountId) {
    return getPendingRedemption(accountId, this.options);
  }
  /**
  * @param the amount of FLIP to request approval for
  * @returns the transaction hash or null if no approval was required
  */
  async approveStateChainGateway(amount, txOpts = {}) {
    const tx = await approveStateChainGateway(amount, this.options, txOpts);
    return tx ? tx.hash : null;
  }
  async getRedemptionTax() {
    this.redemptionTax ?? (this.redemptionTax = (await getFundingEnvironment(this.rpcConfig)).redemptionTax);
    return this.redemptionTax;
  }
};
__name(_FundingSDK, "FundingSDK");
var FundingSDK = _FundingSDK;

exports.FundingSDK = FundingSDK;
