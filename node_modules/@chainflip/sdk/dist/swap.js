'use strict';

var ss582 = require('@chainflip/utils/ss58');
var ethers = require('ethers');
require('@chainflip/utils/string');
var rpc = require('@chainflip/rpc');
var bytes = require('@chainflip/utils/bytes');
var axios = require('axios');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var ss582__namespace = /*#__PURE__*/_interopNamespace(ss582);
var ethers__namespace = /*#__PURE__*/_interopNamespace(ethers);
var axios__default = /*#__PURE__*/_interopDefault(axios);

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../shared/src/enums.ts
function isValidAssetAndChain(assetAndChain2) {
  const { asset: asset2, chain: chain2 } = assetAndChain2;
  if (!(chain2 in exports.Chains)) return false;
  const validAssets = chainConstants[chain2].assets;
  return validAssets.includes(asset2);
}
function getInternalAsset(asset2, assert2 = true) {
  if (!isValidAssetAndChain(asset2)) {
    if (assert2) {
      throw new Error(`invalid asset and chain combination: ${JSON.stringify(asset2)}`);
    }
    return null;
  }
  const map = {
    [exports.Chains.Ethereum]: {
      [exports.Assets.USDC]: exports.ChainflipIds.Usdc,
      [exports.Assets.FLIP]: exports.ChainflipIds.Flip,
      [exports.Assets.ETH]: exports.ChainflipIds.Eth,
      [exports.Assets.USDT]: exports.ChainflipIds.Usdt
    },
    [exports.Chains.Bitcoin]: {
      [exports.Assets.BTC]: exports.ChainflipIds.Btc
    },
    [exports.Chains.Polkadot]: {
      [exports.Assets.DOT]: exports.ChainflipIds.Dot
    },
    [exports.Chains.Arbitrum]: {
      [exports.Assets.USDC]: exports.ChainflipIds.ArbUsdc,
      [exports.Assets.ETH]: exports.ChainflipIds.ArbEth
    }
  };
  const chain2 = map[asset2.chain];
  return chain2[asset2.asset];
}
function getInternalAssets({ srcAsset, srcChain, destAsset, destChain }, assert2 = true) {
  return {
    srcAsset: getInternalAsset({
      asset: srcAsset,
      chain: srcChain
    }, assert2),
    destAsset: getInternalAsset({
      asset: destAsset,
      chain: destChain
    }, assert2)
  };
}
function getAssetAndChain(internalAsset, prefix) {
  const { chain: chain2, asset: asset2 } = assetConstants[internalAsset];
  if (prefix) {
    return {
      [`${prefix}Asset`]: asset2,
      [`${prefix}Chain`]: chain2
    };
  }
  return {
    chain: chain2,
    asset: asset2
  };
}
var arrayToMap; exports.ChainflipIds = void 0; exports.Chains = void 0; exports.Assets = void 0; exports.ChainflipNetworks = void 0; var isTestnet, assetConstants, chainConstants, readChainAssetValue;
var init_enums = __esm({
  "../shared/src/enums.ts"() {
    arrayToMap = /* @__PURE__ */ __name((array) => Object.fromEntries(array.map((key) => [
      key,
      key
    ])), "arrayToMap");
    exports.ChainflipIds = arrayToMap([
      "Flip",
      "Usdc",
      "Dot",
      "Eth",
      "Btc",
      "Usdt",
      "ArbUsdc",
      "ArbEth"
    ]);
    exports.Chains = arrayToMap([
      "Bitcoin",
      "Ethereum",
      "Polkadot",
      "Arbitrum"
    ]);
    exports.Assets = arrayToMap([
      "FLIP",
      "USDC",
      "DOT",
      "ETH",
      "BTC",
      "USDT"
    ]);
    exports.ChainflipNetworks = arrayToMap([
      "backspin",
      "sisyphos",
      "perseverance",
      "mainnet"
    ]);
    isTestnet = /* @__PURE__ */ __name((network) => network !== exports.ChainflipNetworks.mainnet, "isTestnet");
    assetConstants = {
      [exports.ChainflipIds.Eth]: {
        chain: exports.Chains.Ethereum,
        asset: exports.Assets.ETH,
        name: "Ether",
        decimals: 18,
        contractId: 1
      },
      [exports.ChainflipIds.Flip]: {
        chain: exports.Chains.Ethereum,
        asset: exports.Assets.FLIP,
        name: "FLIP",
        decimals: 18,
        contractId: 2
      },
      [exports.ChainflipIds.Usdc]: {
        chain: exports.Chains.Ethereum,
        asset: exports.Assets.USDC,
        name: "USDC",
        decimals: 6,
        contractId: 3
      },
      [exports.ChainflipIds.Usdt]: {
        chain: exports.Chains.Ethereum,
        asset: exports.Assets.USDT,
        name: "USDT",
        decimals: 6,
        contractId: 8
      },
      [exports.ChainflipIds.Dot]: {
        chain: exports.Chains.Polkadot,
        asset: exports.Assets.DOT,
        name: "Polkadot",
        decimals: 10,
        contractId: 4
      },
      [exports.ChainflipIds.Btc]: {
        chain: exports.Chains.Bitcoin,
        asset: exports.Assets.BTC,
        name: "Bitcoin",
        decimals: 8,
        contractId: 5
      },
      [exports.ChainflipIds.ArbEth]: {
        chain: exports.Chains.Arbitrum,
        asset: exports.Assets.ETH,
        name: "Arbitrum Ether",
        decimals: 18,
        contractId: 6
      },
      [exports.ChainflipIds.ArbUsdc]: {
        chain: exports.Chains.Arbitrum,
        asset: exports.Assets.USDC,
        name: "Arbitrum USDC",
        decimals: 6,
        contractId: 7
      }
    };
    chainConstants = {
      [exports.Chains.Ethereum]: {
        assets: [
          exports.Assets.ETH,
          exports.Assets.FLIP,
          exports.Assets.USDC,
          exports.Assets.USDT
        ],
        gasAsset: exports.Assets.ETH,
        contractId: 1,
        blockTimeSeconds: 12
      },
      [exports.Chains.Polkadot]: {
        assets: [
          exports.Assets.DOT
        ],
        gasAsset: exports.Assets.DOT,
        contractId: 2,
        blockTimeSeconds: 6
      },
      [exports.Chains.Bitcoin]: {
        assets: [
          exports.Assets.BTC
        ],
        gasAsset: exports.Assets.BTC,
        contractId: 3,
        blockTimeSeconds: 10 * 60
      },
      [exports.Chains.Arbitrum]: {
        assets: [
          exports.Assets.ETH,
          exports.Assets.USDC
        ],
        gasAsset: exports.Assets.ETH,
        contractId: 4,
        blockTimeSeconds: 0.26
      }
    };
    __name(isValidAssetAndChain, "isValidAssetAndChain");
    readChainAssetValue = /* @__PURE__ */ __name((map, asset2) => {
      const { chain: chain2, asset: symbol } = assetConstants[asset2];
      const chainValues = map[chain2];
      return chainValues[symbol];
    }, "readChainAssetValue");
    __name(getInternalAsset, "getInternalAsset");
    __name(getInternalAssets, "getInternalAssets");
    __name(getAssetAndChain, "getAssetAndChain");
  }
});

// ../shared/src/guards.ts
function assert(condition, message) {
  if (condition) return;
  const error = new Error(message);
  if (error.stack) {
    error.stack = error.stack.replace(/\n.+/, "\n");
  }
  throw error;
}
var isString2, isNotNullish;
var init_guards = __esm({
  "../shared/src/guards.ts"() {
    isString2 = /* @__PURE__ */ __name((value) => typeof value === "string", "isString");
    isNotNullish = /* @__PURE__ */ __name((value) => value !== null && value !== void 0, "isNotNullish");
    __name(assert, "assert");
  }
});

// ../../node_modules/.pnpm/@chainflip+bitcoin@0.2.2/node_modules/@chainflip/bitcoin/dist/index.mjs
var __create, __defProp2, __getOwnPropDesc, __getOwnPropNames2, __getProtoOf, __hasOwnProp, __commonJS, __copyProps, __toESM, require_bitcoin, Bitcoin, networkToBitcoinNetwork, isValidAddressForNetwork2;
var init_dist = __esm({
  "../../node_modules/.pnpm/@chainflip+bitcoin@0.2.2/node_modules/@chainflip/bitcoin/dist/index.mjs"() {
    __create = Object.create;
    __defProp2 = Object.defineProperty;
    __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    __getOwnPropNames2 = Object.getOwnPropertyNames;
    __getProtoOf = Object.getPrototypeOf;
    __hasOwnProp = Object.prototype.hasOwnProperty;
    __commonJS = /* @__PURE__ */ __name((cb, mod) => /* @__PURE__ */ __name(function __require() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    }, "__require"), "__commonJS");
    __copyProps = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp2(to, key, { get: /* @__PURE__ */ __name(() => from[key], "get"), enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    }, "__copyProps");
    __toESM = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    )), "__toESM");
    require_bitcoin = __commonJS({
      "wasm:./built/bitcoin.js"(exports, module) {
        var imports = {};
        imports["__wbindgen_placeholder__"] = module.exports;
        var wasm;
        var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
        cachedTextDecoder.decode();
        var cachedUint8Memory0 = null;
        function getUint8Memory0() {
          if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
            cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
          }
          return cachedUint8Memory0;
        }
        __name(getUint8Memory0, "getUint8Memory0");
        function getStringFromWasm0(ptr, len) {
          ptr = ptr >>> 0;
          return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
        }
        __name(getStringFromWasm0, "getStringFromWasm0");
        var heap = new Array(128).fill(void 0);
        heap.push(void 0, null, true, false);
        var heap_next = heap.length;
        function addHeapObject(obj) {
          if (heap_next === heap.length)
            heap.push(heap.length + 1);
          const idx = heap_next;
          heap_next = heap[idx];
          heap[idx] = obj;
          return idx;
        }
        __name(addHeapObject, "addHeapObject");
        function getObject(idx) {
          return heap[idx];
        }
        __name(getObject, "getObject");
        function dropObject(idx) {
          if (idx < 132)
            return;
          heap[idx] = heap_next;
          heap_next = idx;
        }
        __name(dropObject, "dropObject");
        function takeObject(idx) {
          const ret = getObject(idx);
          dropObject(idx);
          return ret;
        }
        __name(takeObject, "takeObject");
        var WASM_VECTOR_LEN = 0;
        var cachedTextEncoder = new TextEncoder("utf-8");
        var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
          return cachedTextEncoder.encodeInto(arg, view);
        } : function(arg, view) {
          const buf = cachedTextEncoder.encode(arg);
          view.set(buf);
          return {
            read: arg.length,
            written: buf.length
          };
        };
        function passStringToWasm0(arg, malloc, realloc) {
          if (realloc === void 0) {
            const buf = cachedTextEncoder.encode(arg);
            const ptr2 = malloc(buf.length, 1) >>> 0;
            getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
            WASM_VECTOR_LEN = buf.length;
            return ptr2;
          }
          let len = arg.length;
          let ptr = malloc(len, 1) >>> 0;
          const mem = getUint8Memory0();
          let offset = 0;
          for (; offset < len; offset++) {
            const code = arg.charCodeAt(offset);
            if (code > 127)
              break;
            mem[ptr + offset] = code;
          }
          if (offset !== len) {
            if (offset !== 0) {
              arg = arg.slice(offset);
            }
            ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
            const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
            const ret = encodeString(arg, view);
            offset += ret.written;
            ptr = realloc(ptr, len, offset, 1) >>> 0;
          }
          WASM_VECTOR_LEN = offset;
          return ptr;
        }
        __name(passStringToWasm0, "passStringToWasm0");
        var cachedInt32Memory0 = null;
        function getInt32Memory0() {
          if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
            cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
          }
          return cachedInt32Memory0;
        }
        __name(getInt32Memory0, "getInt32Memory0");
        module.exports.decode = function(address, encoding, network) {
          let deferred3_0;
          let deferred3_1;
          try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.decode(retptr, ptr0, len0, encoding, network);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr2 = r0;
            var len2 = r1;
            if (r3) {
              ptr2 = 0;
              len2 = 0;
              throw takeObject(r2);
            }
            deferred3_0 = ptr2;
            deferred3_1 = len2;
            return getStringFromWasm0(ptr2, len2);
          } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
          }
        };
        module.exports.isValidAddressForNetwork = function(address, network) {
          const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.isValidAddressForNetwork(ptr0, len0, network);
          return ret !== 0;
        };
        module.exports.BitcoinNetwork = Object.freeze({ Mainnet: 0, "0": "Mainnet", Testnet: 1, "1": "Testnet", Regtest: 2, "2": "Regtest" });
        module.exports.AddressEncoding = Object.freeze({ P2WPKH: 0, "0": "P2WPKH", P2SH: 1, "1": "P2SH", P2PKH: 2, "2": "P2PKH", P2WSH: 3, "3": "P2WSH", Taproot: 4, "4": "Taproot" });
        module.exports.__wbindgen_error_new = function(arg0, arg1) {
          const ret = new Error(getStringFromWasm0(arg0, arg1));
          return addHeapObject(ret);
        };
        module.exports.__wbindgen_object_drop_ref = function(arg0) {
          takeObject(arg0);
        };
        module.exports.__wbindgen_throw = function(arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
        };
        var bytes = (() => {
          const base64 = "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0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyASQfS6+ZUHaiIENgL8AiADIBFBgpyF+QdrIgU2AvgCIAMgD0HZ8o+hBmsiBjYC9AIgAyACQYydkPMDayIHNgLwAiAQIAwgDSAOECAgAyAGNgJ8IAMgBzYCeCADIAQ2AnQgAyAFNgJwIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANB8ABqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIB42AswCIAMgHTYCyAIgAyAcNgLEAiADIBs2AsACIAMgGjYC3AIgAyAZNgLYAiADIBg2AtQCIAMgFzYC0AIgAyAWNgLsAiADIBU2AugCIAMgFDYC5AIgAyATNgLgAiADIBI2AvwCIAMgETYC+AIgAyAPNgL0AiADIAI2AvACIANBsAJqIh8gECAMIA0gDhAeIAMoArACIRsgAygCtAIhHCADKAK4AiEdIAMoArwCIR4gAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgHkG/rJLbAWsiBDYC/AIgAyAdQfrwhoIBayIFNgL4AiADIBxBxruG/gBqIgY2AvQCIAMgG0HMw7KgAmoiBzYC8AIgECAMIA0gDhAgIAMgBjYCjAEgAyAHNgKIASADIAQ2AoQBIAMgBTYCgAEgAygCwAIhBCADKALEAiEFIAMoAsgCIQYgAygCzAIhByADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgBzYC/AIgAyAGNgL4AiADIAU2AvQCIAMgBDYC8AIgDCANIA4gA0GAAWoQICADKALQAiEIIAMoAtQCIQkgAygC2AIhCiADKALcAiELIAMgGjYCzAIgAyAZNgLIAiADIBg2AsQCIAMgFzYCwAIgAyAWNgLcAiADIBU2AtgCIAMgFDYC1AIgAyATNgLQAiADIBI2AuwCIAMgETYC6AIgAyAPNgLkAiADIAI2AuACIAMgHjYC/AIgAyAdNgL4AiADIBw2AvQCIAMgGzYC8AIgHyAQIAwgDSAOEB4gAygCsAIhFyADKAK0AiEYIAMoArgCIRkgAygCvAIhGiADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAaQe/YpO8CaiIENgL8AiADIBlBqonS0wRqIgU2AvgCIAMgGEHc08LlBWoiBjYC9AIgAyAXQdqR5rcHaiIHNgLwAiAQIAwgDSAOECAgAyAGNgKcASADIAc2ApgBIAMgBDYClAEgAyAFNgKQASADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQZABahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyAWNgLMAiADIBU2AsgCIAMgFDYCxAIgAyATNgLAAiADIBI2AtwCIAMgETYC2AIgAyAPNgLUAiADIAI2AtACIAMgHjYC7AIgAyAdNgLoAiADIBw2AuQCIAMgGzYC4AIgAyAaNgL8AiADIBk2AvgCIAMgGDYC9AIgAyAXNgLwAiAfIBAgDCANIA4QHiADKAKwAiETIAMoArQCIRQgAygCuAIhFSADKAK8AiEWIAMgBzYC3AIgAyAGNgLYAiADIAU2AtQCIAMgBDYC0AIgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIBZBrt2GvgZrIgQ2AvwCIAMgFUGT87i+BWsiBTYC+AIgAyAUQbiw8/8EayIGNgL0AiADIBNBuYCahQRrIgc2AvACIBAgDCANIA4QICADIAY2AqwBIAMgBzYCqAEgAyAENgKkASADIAU2AqABIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANBoAFqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIBI2AswCIAMgETYCyAIgAyAPNgLEAiADIAI2AsACIAMgHjYC3AIgAyAdNgLYAiADIBw2AtQCIAMgGzYC0AIgAyAaNgLsAiADIBk2AugCIAMgGDYC5AIgAyAXNgLgAiADIBY2AvwCIAMgFTYC+AIgAyAUNgL0AiADIBM2AvACIB8gECAMIA0gDhAeIAMoArACIQIgAygCtAIhDyADKAK4AiERIAMoArwCIRIgAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgEkGN6P/IA2siBDYC/AIgAyARQbnd4dICayIFNgL4AiADIA9B0capNmoiBjYC9AIgAyACQefSpKEBaiIHNgLwAiAQIAwgDSAOECAgAyAGNgK8ASADIAc2ArgBIAMgBDYCtAEgAyAFNgKwASADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQbABahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyAeNgLMAiADIB02AsgCIAMgHDYCxAIgAyAbNgLAAiADIBo2AtwCIAMgGTYC2AIgAyAYNgLUAiADIBc2AtACIAMgFjYC7AIgAyAVNgLoAiADIBQ2AuQCIAMgEzYC4AIgAyASNgL8AiADIBE2AvgCIAMgDzYC9AIgAyACNgLwAiAfIBAgDCANIA4QHiADKAKwAiEbIAMoArQCIRwgAygCuAIhHSADKAK8AiEeIAMgBzYC3AIgAyAGNgLYAiADIAU2AtQCIAMgBDYC0AIgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIB5BhZXcvQJqIgQ2AvwCIAMgHUG4wuzwAmoiBTYC+AIgAyAcQfzbsekEaiIGNgL0AiADIBtBk5rgmQVqIgc2AvACIBAgDCANIA4QICADIAY2AswBIAMgBzYCyAEgAyAENgLEASADIAU2AsABIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANBwAFqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIBo2AswCIAMgGTYCyAIgAyAYNgLEAiADIBc2AsACIAMgFjYC3AIgAyAVNgLYAiADIBQ2AtQCIAMgEzYC0AIgAyASNgLsAiADIBE2AugCIAMgDzYC5AIgAyACNgLgAiADIB42AvwCIAMgHTYC+AIgAyAcNgL0AiADIBs2AvACIB8gECAMIA0gDhAeIAMoArACIRcgAygCtAIhGCADKAK4AiEZIAMoArwCIRogAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgGkHU5qmoBmoiBDYC/AIgAyAZQbuVqLMHaiIFNgL4AiADIBhB0u308QdrIgY2AvQCIAMgF0H7prfsBmsiBzYC8AIgECAMIA0gDhAgIAMgBjYC3AEgAyAHNgLYASADIAQ2AtQBIAMgBTYC0AEgAygCwAIhBCADKALEAiEFIAMoAsgCIQYgAygCzAIhByADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgBzYC/AIgAyAGNgL4AiADIAU2AvQCIAMgBDYC8AIgDCANIA4gA0HQAWoQICADKALQAiEIIAMoAtQCIQkgAygC2AIhCiADKALcAiELIAMgFjYCzAIgAyAVNgLIAiADIBQ2AsQCIAMgEzYCwAIgAyASNgLcAiADIBE2AtgCIAMgDzYC1AIgAyACNgLQAiADIB42AuwCIAMgHTYC6AIgAyAcNgLkAiADIBs2AuACIAMgGjYC/AIgAyAZNgL4AiADIBg2AvQCIAMgFzYC8AIgHyAQIAwgDSAOEB4gAygCsAIhEyADKAK0AiEUIAMoArgCIRUgAygCvAIhFiADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAWQd+ugOoFayIENgL8AiADIBVBtbOWvwVrIgU2AvgCIAMgFEGQ6dHtA2siBjYC9AIgAyATQd3czsQDayIHNgLwAiAQIAwgDSAOECAgAyAGNgLsASADIAc2AugBIAMgBDYC5AEgAyAFNgLgASADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQeABahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyASNgLMAiADIBE2AsgCIAMgDzYCxAIgAyACNgLAAiADIB42AtwCIAMgHTYC2AIgAyAcNgLUAiADIBs2AtACIAMgGjYC7AIgAyAZNgLoAiADIBg2AuQCIAMgFzYC4AIgAyAWNgL8AiADIBU2AvgCIAMgFDYC9AIgAyATNgLwAiAfIBAgDCANIA4QHiADKAKwAiECIAMoArQCIQ8gAygCuAIhESADKAK8AiESIAMgBzYC3AIgAyAGNgLYAiADIAU2AtQCIAMgBDYC0AIgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIBJB56+08wJrIgQ2AvwCIAMgEUHc85vLAmsiBTYC+AIgAyAPQfuUx98AayIGNgL0AiADIAJB8MCqgwFqIgc2AvACIBAgDCANIA4QICADIAY2AvwBIAMgBzYC+AEgAyAENgL0ASADIAU2AvABIAMoAsACIQQgAygCxAIhBSADKALIAiEGIAMoAswCIQcgAyALNgLsAiADIAo2AugCIAMgCTYC5AIgAyAINgLgAiADIAc2AvwCIAMgBjYC+AIgAyAFNgL0AiADIAQ2AvACIAwgDSAOIANB8AFqECAgAygC0AIhCCADKALUAiEJIAMoAtgCIQogAygC3AIhCyADIB42AswCIAMgHTYCyAIgAyAcNgLEAiADIBs2AsACIAMgGjYC3AIgAyAZNgLYAiADIBg2AtQCIAMgFzYC0AIgAyAWNgLsAiADIBU2AugCIAMgFDYC5AIgAyATNgLgAiADIBI2AvwCIAMgETYC+AIgAyAPNgL0AiADIAI2AvACIB8gECAMIA0gDhAeIAMoArACIRsgAygCtAIhHCADKAK4AiEdIAMoArwCIR4gAyAHNgLcAiADIAY2AtgCIAMgBTYC1AIgAyAENgLQAiADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgHkGWgpPNAWoiBDYC/AIgAyAdQYjY3fEBaiIFNgL4AiADIBxBzO6hugJqIgY2AvQCIAMgG0G1+cKlA2oiBzYC8AIgECAMIA0gDhAgIAMgBjYCjAIgAyAHNgKIAiADIAQ2AoQCIAMgBTYCgAIgAygCwAIhBCADKALEAiEFIAMoAsgCIQYgAygCzAIhByADIAs2AuwCIAMgCjYC6AIgAyAJNgLkAiADIAg2AuACIAMgBzYC/AIgAyAGNgL4AiADIAU2AvQCIAMgBDYC8AIgDCANIA4gA0GAAmoQICADKALQAiEIIAMoAtQCIQkgAygC2AIhCiADKALcAiELIAMgGjYCzAIgAyAZNgLIAiADIBg2AsQCIAMgFzYCwAIgAyAWNgLcAiADIBU2AtgCIAMgFDYC1AIgAyATNgLQAiADIBI2AuwCIAMgETYC6AIgAyAPNgLkAiADIAI2AuACIAMgHjYC/AIgAyAdNgL4AiADIBw2AvQCIAMgGzYC8AIgHyAQIAwgDSAOEB4gAygCsAIhFyADKAK0AiEYIAMoArgCIRkgAygCvAIhGiADIAc2AtwCIAMgBjYC2AIgAyAFNgLUAiADIAQ2AtACIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAaQbOZ8MgDaiIENgL8AiADIBlBytTi9gRqIgU2AvgCIAMgGEHPlPPcBWoiBjYC9AIgAyAXQfPfucEGaiIHNgLwAiAQIAwgDSAOECAgAyAGNgKcAiADIAc2ApgCIAMgBDYClAIgAyAFNgKQAiADKALAAiEEIAMoAsQCIQUgAygCyAIhBiADKALMAiEHIAMgCzYC7AIgAyAKNgLoAiADIAk2AuQCIAMgCDYC4AIgAyAHNgL8AiADIAY2AvgCIAMgBTYC9AIgAyAENgLwAiAMIA0gDiADQZACahAgIAMoAtACIQggAygC1AIhCSADKALYAiEKIAMoAtwCIQsgAyAWNgLMAiADIBU2AsgCIAMgFDYCxAIgAyATNgLAAiADIBI2AtwCIAMgETYC2AIgAyAPNgLUAiADIAI2AtACIAMgHjYC7AIgAyAdNgLoAiADIBw2AuQCIAMgGzYC4AIgAyAaNgL8AiADIBk2AvgCIAMgGDYC9AIgAyAXNgLwAiAfIBAgDCANIA4QHiADKAKwAiETIAMoArQCIRQgAygCuAIhFSADKAK8AiEWIAMg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IAMoAhBBAWoiBDYCECADIANBKGoQQiADLQABIQIgAy0AAEEBcQ0ACwsgA0E4aiADQSBqKQIANwMAIANBMGogA0EYaikCADcDACADIAMpAhA3AygjAEEgayICJAAgA0EoaiIBKAIAQRRHBEAgAkEANgIIQbiHwAAgASACQQhqEEoACyABQQA2AgAgACABKQAENwAAIABBCGogAUEMaikAADcAACAAQRBqIAFBFGooAAA2AAAgAkEgaiQAIANBQGskAA8LQdyGwABBLUGMh8AAED8AC/YBAgN/AX4jAEEwayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEsaiIEQQA2AgAgAkKAgICAEDcCJCACQSRqQdiQwAAgAxALGiACQSBqIAQoAgAiAzYCACACIAIpAiQiBTcDGCABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQRBqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8EALQAAGiACIAU3AwhBDEEEEFoiAUUEQEEEQQwQbAALIAEgAikDCDcCACABQQhqIAMoAgA2AgAgAEH4kcAANgIEIAAgATYCACACQTBqJAALygEAAkACQCABBEAgAkEASA0BAkACQAJ/IAMoAgQEQCADQQhqKAIAIgFFBEAgAkUEQEEBIQEMBAtBsZPBAC0AABogAkEBEFoMAgsgAygCACABQQEgAhBUDAELIAJFBEBBASEBDAILQbGTwQAtAAAaIAJBARBaCyIBRQ0BCyAAIAE2AgQgAEEIaiACNgIAIABBADYCAA8LIABBATYCBAwCCyAAQQA2AgQMAQsgAEEANgIEIABBATYCAA8LIABBCGogAjYCACAAQQE2AgALxAEBAn8jAEEgayIEJAACQCACIANqIgMgAkkNAEEIIAEoAgAiAkEBdCIFIAMgAyAFSRsiAyADQQhNGyIDQX9zQR92IQUCQCACRQRAIARBADYCGAwBCyAEIAI2AhwgBEEBNgIYIAQgASgCBDYCFAsgBEEIaiAFIAMgBEEUahAqIAQoAgwhBSAEKAIIBEAgBEEQaigCACEDDAELIAEgAzYCACABIAU2AgRBgYCAgHghBQsgACADNgIEIAAgBTYCACAEQSBqJAALhAIBAn8jAEEgayIGJABB6JPBAEHok8EAKAIAIgdBAWo2AgACQAJAIAdBAEgNAEG0l8EALQAADQBBtJfBAEEBOgAAQbCXwQBBsJfBACgCAEEBajYCACAGIAU6AB0gBiAEOgAcIAYgAzYCGCAGIAI2AhQgBkHAksAANgIQIAZBrJDAADYCDEHYk8EAKAIAIgJBAEgNAEHYk8EAIAJBAWo2AgBB2JPBAEHgk8EAKAIABH8gBiAAIAEoAhARAwAgBiAGKQMANwIMQeCTwQAoAgAgBkEMakHkk8EAKAIAKAIUEQMAQdiTwQAoAgBBAWsFIAILNgIAQbSXwQBBADoAACAEDQELAAsAC8gBAQJ/IwBBIGsiAyQAAkACQCABIAEgAmoiAUsNAEEIIAAoAgAiAkEBdCIEIAEgASAESRsiASABQQhNGyIEQX9zQR92IQECQCACRQRAIANBADYCGAwBCyADIAI2AhwgA0EBNgIYIAMgACgCBDYCFAsgA0EIaiABIAQgA0EUahArIAMoAgwhASADKAIIRQRAIAAgBDYCACAAIAE2AgQMAgsgAUGBgICAeEYNASABRQ0AIAEgA0EQaigCABBsAAsQRwALIANBIGokAAvIAQECfyMAQSBrIgMkAAJAAkAgASABIAJqIgFLDQBBCCAAKAIAIgJBAXQiBCABIAEgBEkbIgEgAUEITRsiBEF/c0EfdiEBAkAgAkUEQCADQQA2AhgMAQsgAyACNgIcIANBATYCGCADIAAoAgQ2AhQLIANBCGogASAEIANBFGoQJSADKAIMIQEgAygCCEUEQCAAIAQ2AgAgACABNgIEDAILIAFBgYCAgHhGDQEgAUUNACABIANBEGooAgAQbAALEEcACyADQSBqJAALqQEBAX8gAAJ/AkACfwJAAkAgAQRAIAJBAEgNASADKAIEBEAgA0EIaigCACIEBEAgAygCACAEIAEgAhBUDAULCyACRQ0CQbGTwQAtAAAaIAIgARBaDAMLIABBADYCBCAAQQhqIAI2AgAMAwsgAEEANgIEDAILIAELIgMEQCAAIAM2AgQgAEEIaiACNgIAQQAMAgsgACABNgIEIABBCGogAjYCAAtBAQs2AgALrAEBAX8CQAJAIAEEQCACQQBIDQECfyADKAIEBEACQCADQQhqKAIAIgRFBEAMAQsgAygCACAEIAEgAhBUDAILCyABIAJFDQAaQbGTwQAtAAAaIAIgARBaCyIDBEAgACADNgIEIABBCGogAjYCACAAQQA2AgAPCyAAIAE2AgQgAEEIaiACNgIADAILIABBADYCBCAAQQhqIAI2AgAMAQsgAEEANgIECyAAQQE2AgALpQIBAn8jAEHgAGsiAyQAIANBADYCOCADIAI2AkAgAyABNgI8IANBEGogA0E8ahBCAkAgAy0AEEEBcQRAIAMtABEhAgNAIARBIE8NAiADQRhqIARqIAI6AAAgAyADKAI4QQFqIgQ2AjggA0EIaiADQTxqEEIgAy0ACSECIAMtAAhBAXENAAsLIANBPGoiASADQRhqQSQQbxojAEEgayICJAAgASgCIEEgRwRAIAJBADYCCEGwh8AAIAFBIGogAkEIahBKAAsgAUEANgIgIAAgASkAADcAACAAQQhqIAFBCGopAAA3AAAgAEEQaiABQRBqKQAANwAAIABBGGogAUEYaikAADcAACACQSBqJAAgA0HgAGokAA8LQdyGwABBLUGMh8AAED8AC48BAgN/AX4jAEEgayICJAAgASgCAEGAgICAeEYEQCABKAIMIQMgAkEcaiIEQQA2AgAgAkKAgICAEDcCFCACQRRqQdiQwAAgAxALGiACQRBqIAQoAgAiAzYCACACIAIpAhQiBTcDCCABQQhqIAM2AgAgASAFNwIACyAAQfiRwAA2AgQgACABNgIAIAJBIGokAAt9AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQSRqQgI3AgAgBUE8akEkNgIAIAVBAjYCHCAFQfCWwAA2AhggBUElNgI0IAUgBUEwajYCICAFIAVBEGo2AjggBSAFQQhqNgIwIAVBGGogBBBIAAtsAQF/IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0EUakICNwIAIANBLGpBEzYCACADQQI2AgwgA0GUmsAANgIIIANBEzYCJCADIANBIGo2AhAgAyADQQRqNgIoIAMgAzYCICADQQhqIAIQSAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBFGpCAjcCACADQSxqQRM2AgAgA0ECNgIMIANBzJXAADYCCCADQRM2AiQgAyADQSBqNgIQIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEEgAC2wBAX8jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQRRqQgI3AgAgA0EsakET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AWsiBA0AC0EAIQUMAgsDQCAEQQBHIQUgBEUEQCADIQIMAwsCQCABLQAAIgJBMGsiB0EKSQ0AQX8gAkEgciICQdcAayIHIAcgAkHhAGtJGyIHQRBJDQBBASECDAMLQQIhAiADQf8BcUEEdCIDQQh2DQIgAUEBaiEBIARBAWshBCADQf8BcSAHQf8BcWoiA0H/AXEgA0YNAAsMAQtBASECQQEhBQsgCCACOgABIAggBToAACAJQTBqJAAgBi0ACSEBIAAgBi0ACEEBcToAACAAIAE6AAEgBkEQaiQACzcBAn8gACABKAIAIgIgASgCBCIDRwR/IAEgAkEBajYCACACLQAABSABCzoAASAAIAIgA0c6AAALOQACQAJ/IAJBgIDEAEcEQEEBIAAgAiABKAIQEQAADQEaCyADDQFBAAsPCyAAIAMgBCABKAIMEQEACzoBAX8jAEEQayIDJAAgAyACNgIMIAMgATYCCCADIAI2AgQgA0EEahA3IAAgAykCCDcDACADQRBqJAALvQIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARBjDwtBACEAIwBBgAFrIgMkACACKAIAIQIDQCAAIANqQf8AakEwQTcgAkEPcSIEQQpJGyAEajoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgAFLBEAgAkGAAUHEl8AAEC8ACyABQdSXwABBAiAAIANqQYABakEAIABrEAggA0GAAWokAA8LQQAhACMAQYABayIDJAAgAigCACECA0AgACADakH/AGpBMEHXACACQQ9xIgRBCkkbIARqOgAAIABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGAAUsEQCACQYABQcSXwAAQLwALIAFB1JfAAEECIAAgA2pBgAFqQQAgAGsQCCADQYABaiQACzoBAX8gACgCCCICIAAoAgBGBEAgACACEDkgACgCCCECCyAAIAJBAWo2AgggACgCBCACaiABOgAAQQALPwEBfyMAQSBrIgAkACAAQRRqQgA3AgAgAEEBNgIMIABBgJPAADYCCCAAQdCSwAA2AhAgAEEIakGIk8AAEEgAC7UCAQJ/IwBBIGsiAiQAIAJBATsBHCACIAE2AhggAiAANgIUIAJBiJXAADYCECACQdCTwAA2AgwjAEEQayIBJAAg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cnNGYWlsZWQgdG8gZW5jb2RlIGJlY2gzMiBhZGRyZXNzLgAAaAAQAAoAAACZAQAAEwAAAGgAEAAKAAAAmwEAACgAAABoABAACgAAAJsBAABIAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZAAAAAIAAAACAAAABAAAAGAAEABiABAAZAAQAAUAAAAEAAAABAAAAAYAAABFbXB0eUludmFsaWREaWdpdFBvc092ZXJmbG93TmVnT3ZlcmZsb3daZXJvAAUAAAAMAAAACwAAAAsAAAAEAAAACAEQAA0BEAAZARAAJAEQAC8BEABjYXBhY2l0eSBvdmVyZmxvdwAAAFwBEAARAAAAL3J1c3RjLzA3ZGNhNDg5YWMyZDkzM2M3OGQzYzUxNThlM2Y0M2JlZWZlYjAyY2UvbGlicmFyeS9hbGxvYy9zcmMvdmVjL3NwZWNfZnJvbV9pdGVyX25lc3RlZC5ycwAAeAEQAF4AAAA7AAAAEgAAAC9ydXN0Yy8wN2RjYTQ4OWFjMmQ5MzNjNzhkM2M1MTU4ZTNmNDNiZWVmZWIwMmNlL2xpYnJhcnkvYWxsb2Mvc3JjL3ZlYy9tb2QucnPoARAATAAAAHkLAAANAAAAL1VzZXJzL2FuZHJldy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL2JlY2gzMi0wLjkuMS9zcmMvbGliLnJzKCljYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlAAcAAAAAAAAAAQAAAAgAAAAHAAAAAAAAAAEAAAAJAAAARXJyb3IAAAAKAAAADAAAAAQAAAALAAAADAAAAA0AAABEAhAAWgAAAPEBAAAyAAAARAIQAFoAAAAHAQAAJQAAAAAAAABn5glqha5nu3Lzbjw69U+lf1IOUYxoBZur2YMfGc3gW3NyYy91dGlscy5yc2Fzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaW5pdGlhbGl6ZWRfbGVuZ3RoIDwgTgAAAFADEAAMAAAAJAAAAAkAAAAVAAAAUAMQAAwAAAAsAAAACQAAACAAAAAEAAAAFAAAAA4AAAAMAAAABAAAAA8AAAAQAAAADQAAAFRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBh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OQUAAGkFAAA6BQAAagUAADsFAABrBQAAPAUAAGwFAAA9BQAAbQUAAD4FAABuBQAAPwUAAG8FAABABQAAcAUAAEEFAABxBQAAQgUAAHIFAABDBQAAcwUAAEQFAAB0BQAARQUAAHUFAABGBQAAdgUAAEcFAAB3BQAASAUAAHgFAABJBQAAeQUAAEoFAAB6BQAASwUAAHsFAABMBQAAfAUAAE0FAAB9BQAATgUAAH4FAABPBQAAfwUAAFAFAACABQAAUQUAAIEFAABSBQAAggUAAFMFAACDBQAAVAUAAIQFAABVBQAAhQUAAFYFAACGBQAAoBAAAAAtAAChEAAAAS0AAKIQAAACLQAAoxAAAAMtAACkEAAABC0AAKUQAAAFLQAAphAAAAYtAACnEAAABy0AAKgQAAAILQAAqRAAAAktAACqEAAACi0AAKsQAAALLQAArBAAAAwtAACtEAAADS0AAK4QAAAOLQAArxAAAA8tAACwEAAAEC0AALEQAAARLQAAshAAABItAACzEAAAEy0AALQQAAAULQAAtRAAABUtAAC2EAAAFi0AALcQAAAXLQAAuBAAABgtAAC5EAAAGS0AALoQAAAaLQAAuxAAABstAAC8EAAAHC0AAL0QAAAdLQAAvhAAAB4tAAC/EAAAHy0AAMAQAAAgLQAAwRAAACEtAADCEAAAIi0AAMMQAAAjLQAAxBAAACQtAADFEAAAJS0AAMcQAAAnLQAAzRAAAC0tAACgEwAAcKsAAKETAABxqwAAohMAAHKrAACjEwAAc6sAAKQTAAB0qwAApRMAAHWrAACmEwAAdqsAAKcTAAB3qwAAqBMAAHirAACpEwAAeasAAKoTAAB6qwAAqxMAAHurAACsEwAAfKsAAK0TAAB9qwAArhMAAH6rAACvEwAAf6sAALATAACAqwAAsRMAAIGrAACyEwAAgqsAALMTAACDqwAAtBMAAISrAAC1EwAAhasAALYTAACGqwAAtxMAAIerAAC4EwAAiKsAALkTAACJqwAAuhMAAIqrAAC7EwAAi6sAALwTAACMqwAAvRMAAI2rAAC+EwAAjqsAAL8TAACPqwAAwBMAAJCrAADBEwAAkasAAMITAACSqwAAwxMAAJOrAADEEwAAlKsAAMUTAACVqwAAxhMAAJarAADHEwAAl6sAAMgTAACYqwAAyRMAAJmrAADKEwAAmqsAAMsTAACbqwAAzBMAAJyrAADNEwAAnasAAM4TAACeqwAAzxMAAJ+rAADQEwAAoKsAANETAAChqwAA0hMAAKKrAADTEwAAo6sAANQTAACkqwAA1RMAAKWrAADWEwAApqsAANcTAACnqwAA2BMAAKirAADZEwAAqasAANoTAACqqwAA2xMAAKurAADcEwAArKsAAN0TAACtqwAA3hMAAK6rAADfEwAAr6sAAOATAACwqwAA4RMAALGrAADiEwAAsqsAAOMTAACzqwAA5BMAALSrAADlEwAAtasAAOYTAAC2qwAA5xMAALerAADoEwAAuKsAAOkTAAC5qwAA6hMAALqrAADrEwAAu6sAAOwTAAC8qwAA7RMAAL2rAADuEwAAvqsAAO8TAAC/qwAA8BMAAPgTAADxEwAA+RMAAPITAAD6EwAA8xMAAPsTAAD0EwAA/BMAAPUTAAD9EwAAkBwAANAQAACRHAAA0RAAAJIcAADSEAAAkxwAANMQAACUHAAA1BAAAJUcAADVEAAAlhwAANYQAACXHAAA1xAAAJgcAADYEAAAmRwAANkQAACaHAAA2hAAAJscAADbEAAAnBwAANwQAACdHAAA3RAAAJ4cAADeEAAAnxwAAN8QAACgHAAA4BAAAKEcAADhEAAAohwAAOIQAACjHAAA4xAAAKQcAADkEAAApRwAAOUQAACmHAAA5hAAAKccAADnEAAAqBwAAOgQAACpHAAA6RAAAKocAADqEAAAqxwAAOsQAACsHAAA7BAAAK0cAADtEAAArhwAAO4QAACvHAAA7xAAALAcAADwEAAAsRwAAPEQAACyHAAA8hAAALMcAADzEAAAtBwAAPQQAAC1HAAA9RAAALYcAAD2EAAAtxwAAPcQAAC4HAAA+BAAALkcAAD5EAAAuhwAAPoQAAC9HAAA/RAAAL4cAAD+EAAAvxwAAP8QAAAAHgAAAR4AAAIeAAADHgAABB4AAAUeAAAGHgAABx4AAAgeAAAJHgAACh4AAAseAAAMHgAADR4AAA4eAAAPHgAAEB4AABEeAAASHgAAEx4AABQeAAAVHgAAFh4AABceAAAYHgAAGR4AABoeAAAbHgAAHB4AAB0eAAAeHgAAHx4AACAeAAAhHgAAIh4AACMeAAAkHgAAJR4AACYeAAAnHgAAKB4AACkeAAAqHgAAKx4AACweAAAtHgAALh4AAC8eAAAwHgAAMR4AADIeAAAzHgAANB4AADUeAAA2HgAANx4AADgeAAA5HgAAOh4AADseAAA8HgAAPR4AAD4eAAA/HgAAQB4AAEEeAABCHgAAQx4AAEQeAABFHgAARh4AAEceAABIHgAASR4AAEoeAABLHgAATB4AAE0eAABOHgAATx4AAFAeAABRHgAAUh4AAFMeAABUHgAAVR4AAFYeAABXHgAAWB4AAFkeAABaHgAAWx4AAFweAABdHgAAXh4AAF8eAABgHgAAYR4AAGIeAABjHgAAZB4AAGUeAABmHgAAZx4AAGgeAABpHgAAah4AAGseAABsHgAAbR4AAG4eAABvHgAAcB4AAHEeAAByHgAAcx4AAHQeAAB1HgAAdh4AAHceAAB4HgAAeR4AAHoeAAB7HgAAfB4AAH0eAAB+HgAAfx4AAIAeAACBHgAAgh4AAIMeAACEHgAAhR4AAIYeAACHHgAAiB4AAIkeAACKHgAAix4AAIweAACNHgAAjh4AAI8eAACQHgAAkR4AAJIeAACTHgAAlB4AAJUeAACeHgAA3wAAAKAeAAChHgAAoh4AAKMeAACkHgAApR4AAKYeAACnHgAAqB4AAKkeAACqHgAAqx4AAKweAACtHgAArh4AAK8eAACwHgAAsR4AALIeAACzHgAAtB4AALUeAAC2HgAAtx4AALgeAAC5HgAAuh4AALseAAC8HgAAvR4AAL4eAAC/HgAAwB4AAMEeAADCHgAAwx4AAMQeAADFHgAAxh4AAMceAADIHgAAyR4AAMoeAADLHgAAzB4AAM0eAADOHgAAzx4AANAeAADRHgAA0h4AANMeAADUHgAA1R4AANYeAADXHgAA2B4AANkeAADaHgAA2x4AANweAADdHgAA3h4AAN8eAADgHgAA4R4AAOIeAADjHgAA5B4AAOUeAADmHgAA5x4AAOgeAADpHgAA6h4AAOseAADsHgAA7R4AAO4eAADvHgAA8B4AAPEeAADyHgAA8x4AAPQeAAD1HgAA9h4AAPceAAD4HgAA+R4AAPoeAAD7HgAA/B4AAP0eAAD+HgAA/x4AAAgfAAAAHwAACR8AAAEfAAAKHwAAAh8AAAsfAAADHwAADB8AAAQfAAANHwAABR8AAA4fAAAGHwAADx8AAAcfAAAYHwAAEB8AABkfAAARHwAAGh8AABIfAAAbHwAAEx8AABwfAAAUHwAAHR8AABUfAAAoHwAAIB8AACkfAAAhHwAAKh8AACIfAAArHwAAIx8AACwfAAAkHwAALR8AACUfAAAuHwAAJh8AAC8fAAAnHwAAOB8AADAfAAA5HwAAMR8AADofAAAyHwAAOx8AADMfAAA8HwAANB8AAD0fAAA1HwAAPh8AADYfAAA/HwAANx8AAEgfAABAHwAASR8AAEEfAABKHwAAQh8AAEsfAABDHwAATB8AAEQfAABNHwAARR8AAFkfAABRHwAAWx8AAFMfAABdHwAAVR8AAF8fAABXHwAAaB8AAGAfAABpHwAAYR8AAGofAABiHwAAax8AAGMfAABsHwAAZB8AAG0fAABlHwAAbh8AAGYfAABvHwAAZx8AAIgfAACAHwAAiR8AAIEfAACKHwAAgh8AAIsfAACDHwAAjB8AAIQfAACNHwAAhR8AAI4fAACGHwAAjx8AAIcfAACYHwAAkB8AAJkfAACRHwAAmh8AAJIfAACbHwAAkx8AAJwfAACUHwAAnR8AAJUfAACeHwAAlh8AAJ8fAACXHwAAqB8AAKAfAACpHwAAoR8AAKofAACiHwAAqx8AAKMfAACsHwAApB8AAK0fAAClHwAArh8AAKYfAACvHwAApx8AALgfAACwHwAAuR8AALEfAAC6HwAAcB8AALsfAABxHwAAvB8AALMfAADIHwAAch8AAMkfAABzHwAAyh8AAHQfAADLHwAAdR8AAMwfAADDHwAA2B8AANAfAADZHwAA0R8AANofAAB2HwAA2x8AAHcfAADoHwAA4B8AAOkfAADhHwAA6h8AAHofAADrHwAAex8AAOwfAADlHwAA+B8AAHgfAAD5HwAAeR8AAPofAAB8HwAA+x8AAH0fAAD8HwAA8x8AACYhAADJAwAAKiEAAGsAAAArIQAA5QAAADIhAABOIQAAYCEAAHAhAABhIQAAcSEAAGIhAAByIQAAYyEAAHMhAABkIQAAdCEAAGUhAAB1IQAAZiEAAHYhAABnIQAAdyEAAGghAAB4IQAAaSEAAHkhAABqIQAAeiEAAGshAAB7IQAAbCEAAHwhAABtIQAAfSEAAG4hAAB+IQAAbyEAAH8hAACDIQAAhCEAALYkAADQJAAAtyQAANEkAAC4JAAA0iQAALkkAADTJAAAuiQAANQkAAC7JAAA1SQAALwkAADWJAAAvSQAANckAAC+JAAA2CQAAL8kAADZJAAAwCQAANokAADBJAAA2yQAAMIkAADcJAAAwyQAAN0kAADEJAAA3iQAAMUkAADfJAAAxiQAAOAkAADHJAAA4SQAAMgkAADiJAAAySQAAOMkAADKJAAA5CQAAMskAADlJAAAzCQAAOYkAADNJAAA5yQAAM4kAADoJAAAzyQAAOkkAAAALAAAMCwAAAEsAAAxLAAAAiwAADIsAAADLAAAMywAAAQsAAA0LAAABSwAADUsAAAGLAAANiwAAAcsAAA3LAAACCwAADgsAAAJLAAAOSwAAAosAAA6LAAACywAADssAAAMLAAAPCwAAA0sAAA9LAAADiwAAD4sAAAPLAAAPywAABAsAABALAAAESwAAEEsAAASLAAAQiwAABMsAABDLAAAFCwAAEQsAAAVLAAARSwAABYsAABGLAAAFywAAEcsAAAYLAAASCwAABksAABJLAAAGiwAAEosAAAbLAAASywAABwsAABMLAAAHSwAAE0sAAAeLAAATiwAAB8sAABPLAAAICwAAFAsAAAhLAAAUSwAACIsAABSLAAAIywAAFMsAAAkLAAAVCwAACUsAABVLAAAJiwAAFYsAAAnLAAAVywAACgsAABYLAAAKSwAAFksAAAqLAAAWiwAACssAABbLAAALCwAAFwsAAAtLAAAXSwAAC4sAABeLAAALywAAF8sAABgLAAAYSwAAGIsAABrAgAAYywAAH0dAABkLAAAfQIAAGcsAABoLAAAaSwAAGosAABrLAAAbCwAAG0sAABRAgAAbiwAAHECAABvLAAAUAIAAHAsAABSAgAAciwAAHMsAAB1LAAAdiwAAH4sAAA/AgAAfywAAEACAACALAAAgSwAAIIsAACDLAAAhCwAAIUsAACGLAAAhywAAIgsAACJLAAAiiwAAIssAACMLAAAjSwAAI4sAACPLAAAkCwAAJEsAACSLAAAkywAAJQsAACVLAAAliwAAJcsAACYLAAAmSwAAJosAACbLAAAnCwAAJ0sAACeLAAAnywAAKAsAAChLAAAoiwAAKMsAACkLAAApSwAAKYsAACnLAAAqCwAAKksAACqLAAAqywAAKwsAACtLAAAriwAAK8sAACwLAAAsSwAALIsAACzLAAAtCwAALUsAAC2LAAAtywAALgsAAC5LAAAuiwAALssAAC8LAAAvSwAAL4sAAC/LAAAwCwAAMEsAADCLAAAwywAAMQsAADFLAAAxiwAAMcsAADILAAAySwAAMosAADLLAAAzCwAAM0sAADOLAAAzywAANAsAADRLAAA0iwAANMsAADULAAA1SwAANYsAADXLAAA2CwAANksAADaLAAA2ywAANwsAADdLAAA3iwAAN8sAADgLAAA4SwAAOIsAADjLAAA6ywAAOwsAADtLAAA7iwAAPIsAADzLAAAQKYAAEGmAABCpgAAQ6YAAESmAABFpgAARqYAAEemAABIpgAASaYAAEqmAABLpgAATKYAAE2mAABOpgAAT6YAAFCmAABRpgAAUqYAAFOmAABUpgAAVaYAAFamAABXpgAAWKYAAFmmAABapgAAW6YAAFymAABdpgAAXqYAAF+mAABgpgAAYaYAAGKmAABjpgAAZKYAAGWmAABmpgAAZ6YAAGimAABppgAAaqYAAGumAABspgAAbaYAAICmAACBpgAAgqYAAIOmAACEpgAAhaYAAIamAACHpgAAiKYAAImmAACKpgAAi6YAAIymAACNpgAAjqYAAI+mAACQpgAAkaYAAJKmAACTpgAAlKYAAJWmAACWpgAAl6YAAJimAACZpgAAmqYAAJumAAAipwAAI6cAACSnAAAlpwAAJqcAACenAAAopwAAKacAACqnAAArpwAALKcAAC2nAAAupwAAL6cAADKnAAAzpwAANKcAADWnAAA2pwAAN6cAADinAAA5pwAAOqcAADunAAA8pwAAPacAAD6nAAA/pwAAQKcAAEGnAABCpwAAQ6cAAESnAABFpwAARqcAAEenAABIpwAASacAAEqnAABLpwAATKcAAE2nAABOpwAAT6cAAFCnAABRpwAAUqcAAFOnAABUpwAAVacAAFanAABXpwAAWKcAAFmnAABapwAAW6cAAFynAABdpwAAXqcAAF+nAABgpwAAYacAAGKnAABjpwAAZKcAAGWnAABmpwAAZ6cAAGinAABppwAAaqcAAGunAABspwAAbacAAG6nAABvpwAAeacAAHqnAAB7pwAAfKcAAH2nAAB5HQAAfqcAAH+nAACApwAAgacAAIKnAACDpwAAhKcAAIWnAACGpwAAh6cAAIunAACMpwAAjacAAGUCAACQpwAAkacAAJKnAACTpwAAlqcAAJenAACYpwAAmacAAJqnAACbpwAA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";
          const binary = atob(base64);
          const array = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            array[i] = binary.charCodeAt(i);
          }
          return array.buffer;
        })();
        var wasmModule = new WebAssembly.Module(bytes);
        var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
        wasm = wasmInstance.exports;
        module.exports.__wasm = wasm;
      }
    });
    Bitcoin = __toESM(require_bitcoin(), 1);
    networkToBitcoinNetwork = /* @__PURE__ */ __name((network) => {
      switch (network) {
        case "mainnet":
          return Bitcoin.BitcoinNetwork.Mainnet;
        case "perseverance":
        case "sisyphos":
        case "testnet":
          return Bitcoin.BitcoinNetwork.Testnet;
        case "backspin":
        case "regtest":
          return Bitcoin.BitcoinNetwork.Regtest;
        default:
          throw new Error(`Invalid network: ${network}`);
      }
    }, "networkToBitcoinNetwork");
    isValidAddressForNetwork2 = /* @__PURE__ */ __name((address, network) => Bitcoin.isValidAddressForNetwork(address, networkToBitcoinNetwork(network)), "isValidAddressForNetwork2");
  }
});

// ../../node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap3, invalid_type_error, required_error, description } = params;
  if (errorMap3 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap3)
    return { errorMap: errorMap3, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, _ZodError, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, _ParseStatus, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, _ParseInputLazyPath, ParseInputLazyPath, handleResult, _ZodType, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv6Regex, base64Regex, dateRegexSource, dateRegex, _ZodString, ZodString, _ZodNumber, ZodNumber, _ZodBigInt, ZodBigInt, _ZodBoolean, ZodBoolean, _ZodDate, ZodDate, _ZodSymbol, ZodSymbol, _ZodUndefined, ZodUndefined, _ZodNull, ZodNull, _ZodAny, ZodAny, _ZodUnknown, ZodUnknown, _ZodNever, ZodNever, _ZodVoid, ZodVoid, _ZodArray, ZodArray, _ZodObject, ZodObject, _ZodUnion, ZodUnion, getDiscriminator, _ZodDiscriminatedUnion, ZodDiscriminatedUnion, _ZodIntersection, ZodIntersection, _ZodTuple, ZodTuple, _ZodRecord, ZodRecord, _ZodMap, ZodMap, _ZodSet, ZodSet, _ZodFunction, ZodFunction, _ZodLazy, ZodLazy, _ZodLiteral, ZodLiteral, _ZodEnum, ZodEnum, _ZodNativeEnum, ZodNativeEnum, _ZodPromise, ZodPromise, _ZodEffects, ZodEffects, _ZodOptional, ZodOptional, _ZodNullable, ZodNullable, _ZodDefault, ZodDefault, _ZodCatch, ZodCatch, _ZodNaN, ZodNaN, BRAND, _ZodBranded, ZodBranded, _ZodPipeline, ZodPipeline, _ZodReadonly, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z;
var init_lib = __esm({
  "../../node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.mjs"() {
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    _ZodError = class _ZodError extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    __name(_ZodError, "ZodError");
    ZodError = _ZodError;
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    }, "errorMap");
    overrideErrorMap = errorMap;
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    _ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    __name(_ParseStatus, "ParseStatus");
    ParseStatus = _ParseStatus;
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
    __name(__classPrivateFieldGet, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet, "__classPrivateFieldSet");
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    _ParseInputLazyPath = class _ParseInputLazyPath {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    __name(_ParseInputLazyPath, "ParseInputLazyPath");
    ParseInputLazyPath = _ParseInputLazyPath;
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    _ZodType = class _ZodType {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform2) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform2 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    __name(_ZodType, "ZodType");
    ZodType = _ZodType;
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    _ZodString = class _ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    __name(_ZodString, "ZodString");
    ZodString = _ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    _ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    __name(_ZodNumber, "ZodNumber");
    ZodNumber = _ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    _ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    __name(_ZodBigInt, "ZodBigInt");
    ZodBigInt = _ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    _ZodBoolean = class _ZodBoolean extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    __name(_ZodBoolean, "ZodBoolean");
    ZodBoolean = _ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    _ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    __name(_ZodDate, "ZodDate");
    ZodDate = _ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    _ZodSymbol = class _ZodSymbol extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    __name(_ZodSymbol, "ZodSymbol");
    ZodSymbol = _ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    _ZodUndefined = class _ZodUndefined extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    __name(_ZodUndefined, "ZodUndefined");
    ZodUndefined = _ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    _ZodNull = class _ZodNull extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    __name(_ZodNull, "ZodNull");
    ZodNull = _ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    _ZodAny = class _ZodAny extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    __name(_ZodAny, "ZodAny");
    ZodAny = _ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    _ZodUnknown = class _ZodUnknown extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    __name(_ZodUnknown, "ZodUnknown");
    ZodUnknown = _ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    _ZodNever = class _ZodNever extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    __name(_ZodNever, "ZodNever");
    ZodNever = _ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    _ZodVoid = class _ZodVoid extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    __name(_ZodVoid, "ZodVoid");
    ZodVoid = _ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    _ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    __name(_ZodArray, "ZodArray");
    ZodArray = _ZodArray;
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    __name(deepPartialify, "deepPartialify");
    _ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    __name(_ZodObject, "ZodObject");
    ZodObject = _ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    _ZodUnion = class _ZodUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    __name(_ZodUnion, "ZodUnion");
    ZodUnion = _ZodUnion;
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    _ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    __name(_ZodDiscriminatedUnion, "ZodDiscriminatedUnion");
    ZodDiscriminatedUnion = _ZodDiscriminatedUnion;
    __name(mergeValues, "mergeValues");
    _ZodIntersection = class _ZodIntersection extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    __name(_ZodIntersection, "ZodIntersection");
    ZodIntersection = _ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    _ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    __name(_ZodTuple, "ZodTuple");
    ZodTuple = _ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    _ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    __name(_ZodRecord, "ZodRecord");
    ZodRecord = _ZodRecord;
    _ZodMap = class _ZodMap extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    __name(_ZodMap, "ZodMap");
    ZodMap = _ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    _ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    __name(_ZodSet, "ZodSet");
    ZodSet = _ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    _ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    __name(_ZodFunction, "ZodFunction");
    ZodFunction = _ZodFunction;
    _ZodLazy = class _ZodLazy extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    __name(_ZodLazy, "ZodLazy");
    ZodLazy = _ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    _ZodLiteral = class _ZodLiteral extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    __name(_ZodLiteral, "ZodLiteral");
    ZodLiteral = _ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    __name(createZodEnum, "createZodEnum");
    _ZodEnum = class _ZodEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues2 = {};
        for (const val of this._def.values) {
          enumValues2[val] = val;
        }
        return enumValues2;
      }
      get Values() {
        const enumValues2 = {};
        for (const val of this._def.values) {
          enumValues2[val] = val;
        }
        return enumValues2;
      }
      get Enum() {
        const enumValues2 = {};
        for (const val of this._def.values) {
          enumValues2[val] = val;
        }
        return enumValues2;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    __name(_ZodEnum, "ZodEnum");
    ZodEnum = _ZodEnum;
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    _ZodNativeEnum = class _ZodNativeEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    __name(_ZodNativeEnum, "ZodNativeEnum");
    ZodNativeEnum = _ZodNativeEnum;
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    _ZodPromise = class _ZodPromise extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    __name(_ZodPromise, "ZodPromise");
    ZodPromise = _ZodPromise;
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    _ZodEffects = class _ZodEffects extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    __name(_ZodEffects, "ZodEffects");
    ZodEffects = _ZodEffects;
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    _ZodOptional = class _ZodOptional extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    __name(_ZodOptional, "ZodOptional");
    ZodOptional = _ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    _ZodNullable = class _ZodNullable extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    __name(_ZodNullable, "ZodNullable");
    ZodNullable = _ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    _ZodDefault = class _ZodDefault extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    __name(_ZodDefault, "ZodDefault");
    ZodDefault = _ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    _ZodCatch = class _ZodCatch extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    __name(_ZodCatch, "ZodCatch");
    ZodCatch = _ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    _ZodNaN = class _ZodNaN extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    __name(_ZodNaN, "ZodNaN");
    ZodNaN = _ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    _ZodBranded = class _ZodBranded extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    __name(_ZodBranded, "ZodBranded");
    ZodBranded = _ZodBranded;
    _ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    __name(_ZodPipeline, "ZodPipeline");
    ZodPipeline = _ZodPipeline;
    _ZodReadonly = class _ZodReadonly extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    __name(_ZodReadonly, "ZodReadonly");
    ZodReadonly = _ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    __name(custom, "custom");
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
      number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }), "boolean"),
      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
      date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      datetimeRegex,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});
var validatePolkadotAddress, validateEvmAddress, validateBitcoinMainnetAddress, validateBitcoinTestnetAddress, validateBitcoinRegtestAddress, validators, assertValidAddress;
var init_addressValidation = __esm({
  "../shared/src/validation/addressValidation.ts"() {
    init_dist();
    init_guards();
    validatePolkadotAddress = /* @__PURE__ */ __name((address) => {
      try {
        ss582__namespace.decode(address);
        return true;
      } catch {
        return false;
      }
    }, "validatePolkadotAddress");
    validateEvmAddress = /* @__PURE__ */ __name((address) => ethers__namespace.isAddress(address), "validateEvmAddress");
    validateBitcoinMainnetAddress = /* @__PURE__ */ __name((address) => isValidAddressForNetwork2(address, "mainnet"), "validateBitcoinMainnetAddress");
    validateBitcoinTestnetAddress = /* @__PURE__ */ __name((address) => isValidAddressForNetwork2(address, "testnet"), "validateBitcoinTestnetAddress");
    validateBitcoinRegtestAddress = /* @__PURE__ */ __name((address) => isValidAddressForNetwork2(address, "regtest"), "validateBitcoinRegtestAddress");
    validators = {
      mainnet: {
        Bitcoin: validateBitcoinMainnetAddress,
        Ethereum: validateEvmAddress,
        Polkadot: validatePolkadotAddress,
        Arbitrum: validateEvmAddress
      },
      perseverance: {
        Bitcoin: validateBitcoinTestnetAddress,
        Ethereum: validateEvmAddress,
        Polkadot: validatePolkadotAddress,
        Arbitrum: validateEvmAddress
      },
      sisyphos: {
        Bitcoin: validateBitcoinTestnetAddress,
        Ethereum: validateEvmAddress,
        Polkadot: validatePolkadotAddress,
        Arbitrum: validateEvmAddress
      },
      backspin: {
        Bitcoin: validateBitcoinRegtestAddress,
        Ethereum: validateEvmAddress,
        Polkadot: validatePolkadotAddress,
        Arbitrum: validateEvmAddress
      },
      localnet: {
        Bitcoin: validateBitcoinRegtestAddress,
        Ethereum: validateEvmAddress,
        Polkadot: validatePolkadotAddress,
        Arbitrum: validateEvmAddress
      }
    };
    assertValidAddress = /* @__PURE__ */ __name((chain2, address, network) => assert(validators[network][chain2](address), `Address "${address}" is not a valid "${chain2}" address for "${network}"`), "assertValidAddress");
  }
});
var enumValues, safeStringify, errorMap2, string, number, numericString, numericOrEmptyString, hexString, hexStringWithMaxByteSize, btcAddress, DOT_PREFIX, dotAddress, ethereumAddress, chainflipAddress, u128, unsignedInteger, rustEnum, chain, asset, uncheckedAssetAndChain, assetAndChain, chainflipSS58Prefix;
var init_parsers = __esm({
  "../shared/src/parsers.ts"() {
    init_dist();
    init_lib();
    init_enums();
    init_guards();
    init_addressValidation();
    enumValues = Object.values;
    safeStringify = /* @__PURE__ */ __name((obj) => JSON.stringify(obj, (key, value) => typeof value === "bigint" ? value.toString() : value), "safeStringify");
    errorMap2 = /* @__PURE__ */ __name((_issue, context) => ({
      message: `received: ${safeStringify(context.data)}`
    }), "errorMap");
    string = z.string({
      errorMap: errorMap2
    });
    number = z.number({
      errorMap: errorMap2
    });
    numericString = string.regex(/^[0-9]+$/);
    numericOrEmptyString = string.regex(/^[0-9]*$/);
    hexString = string.refine((v) => /^0x[0-9a-f]*$/i.test(v));
    hexStringWithMaxByteSize = /* @__PURE__ */ __name((maxByteSize) => hexString.refine((val) => val.length / 2 <= maxByteSize + 1, {
      message: `String must be less than or equal to ${maxByteSize} bytes`
    }), "hexStringWithMaxByteSize");
    btcAddress = /* @__PURE__ */ __name((network) => {
      if (network === "mainnet") {
        return string.regex(/^(1|3|bc1)/).refine(validateBitcoinMainnetAddress, (address) => ({
          message: `"${address}" is not a valid Bitcoin mainnet address`
        }));
      }
      return z.union([
        string.regex(/^(m|n|2|tb1)/).refine(validateBitcoinTestnetAddress, (address) => ({
          message: `"${address}" is not a valid Bitcoin testnet address`
        })),
        string.regex(/^bcrt1/).refine(validateBitcoinRegtestAddress, (address) => ({
          message: `"${address}" is not a valid Bitcoin regtest address`
        }))
      ]);
    }, "btcAddress");
    DOT_PREFIX = 0;
    dotAddress = z.union([
      string,
      hexString
    ]).transform((arg) => {
      try {
        if (arg.startsWith("0x")) {
          return ss582__namespace.encode({
            data: arg,
            ss58Format: DOT_PREFIX
          });
        }
        return ss582__namespace.encode({
          data: ss582__namespace.decode(arg).data,
          ss58Format: DOT_PREFIX
        });
      } catch {
        return null;
      }
    }).refine(isString2, {
      message: `address is not a valid polkadot address`
    });
    ethereumAddress = hexString.refine((address) => ethers__namespace.isAddress(address), (address) => ({
      message: `${address} is not a valid ethereum address`
    }));
    chainflipAddress = string.refine((address) => address.startsWith("cF") && ss582__namespace.decode(address), (address) => ({
      message: `${address} is not a valid chainflip address`
    }));
    numericString.transform((arg) => BigInt(arg));
    u128 = z.union([
      number,
      numericString,
      hexString
    ]).transform((arg) => BigInt(arg));
    unsignedInteger = z.union([
      u128,
      z.number().transform((n) => BigInt(n))
    ]);
    rustEnum = /* @__PURE__ */ __name((values) => z.object({
      __kind: z.enum(values)
    }).transform(({ __kind }) => __kind), "rustEnum");
    rustEnum(enumValues(exports.ChainflipIds));
    rustEnum(enumValues(exports.Chains));
    chain = z.nativeEnum(exports.Chains);
    asset = z.nativeEnum(exports.Assets);
    z.nativeEnum(exports.ChainflipNetworks);
    uncheckedAssetAndChain = z.object({
      asset: z.string(),
      chain: z.string()
    });
    assetAndChain = uncheckedAssetAndChain.refine((value) => isValidAssetAndChain(value));
    z.union([
      z.object({
        __kind: z.literal("CcmPrincipal"),
        value: unsignedInteger
      }).transform(({ value: ccmId }) => ({
        type: "PRINCIPAL",
        ccmId
      })),
      z.object({
        __kind: z.literal("CcmGas"),
        value: unsignedInteger
      }).transform(({ value: ccmId }) => ({
        type: "GAS",
        ccmId
      })),
      z.object({
        __kind: z.literal("Swap")
      }).transform(() => ({
        type: "SWAP"
      }))
    ]);
    chainflipSS58Prefix = 2112;
    z.union([
      hexString,
      string.regex(/^[a-f\d]$/i).transform((value) => `0x${value}`)
    ]).transform((value) => ss582__namespace.encode({
      data: value,
      ss58Format: chainflipSS58Prefix
    }));
    z.union([
      z.object({
        __kind: z.literal("Swap"),
        swapId: u128
      }),
      z.object({
        __kind: z.literal("LiquidityProvision"),
        lpAccount: hexString
      }),
      z.object({
        __kind: z.literal("CcmTransfer"),
        principalSwapId: u128.nullable().optional(),
        gasSwapId: u128.nullable().optional()
      }),
      z.object({
        __kind: z.literal("NoAction")
      }),
      z.object({
        __kind: z.literal("BoostersCredited"),
        prewitnessedDepositId: u128
      })
    ]);
  }
});

// ../shared/src/schemas.ts
var ccmMetadataSchema, affiliateBroker;
var init_schemas = __esm({
  "../shared/src/schemas.ts"() {
    init_lib();
    init_enums();
    init_parsers();
    z.object({
      srcChain: chain,
      srcAsset: asset,
      destChain: chain,
      destAsset: asset,
      amount: numericString.transform((n) => BigInt(n)),
      brokerCommissionBps: numericOrEmptyString.transform((v) => Number(v)).optional()
    }).transform((args, ctx) => {
      const { srcAsset, destAsset } = getInternalAssets(args, false);
      if (srcAsset === null) {
        ctx.addIssue({
          message: `invalid asset and chain combination: ${JSON.stringify({
            asset: args.srcAsset,
            chain: args.srcChain
          })}`,
          code: z.ZodIssueCode.custom
        });
        return z.NEVER;
      }
      if (destAsset === null) {
        ctx.addIssue({
          message: `invalid asset and chain combination: ${JSON.stringify({
            asset: args.destAsset,
            chain: args.destChain
          })}`,
          code: z.ZodIssueCode.custom
        });
        return z.NEVER;
      }
      return {
        srcAsset,
        destAsset,
        amount: args.amount,
        brokerCommissionBps: args.brokerCommissionBps
      };
    });
    ccmMetadataSchema = z.object({
      gasBudget: numericString,
      message: hexStringWithMaxByteSize(1024 * 10)
    });
    affiliateBroker = z.object({
      account: chainflipAddress,
      commissionBps: number
    }).transform(({ account, commissionBps: bps }) => ({
      account,
      bps
    }));
    z.object({
      srcAsset: asset,
      destAsset: asset,
      srcChain: chain,
      destChain: chain,
      destAddress: z.string(),
      amount: numericString,
      ccmMetadata: ccmMetadataSchema.optional(),
      maxBoostFeeBps: z.number().optional(),
      srcAddress: z.string().optional()
    }).transform(({ amount, ...rest }) => ({
      ...rest,
      expectedDepositAmount: amount
    }));
  }
});

// ../shared/src/broker.ts
var broker_exports = {};
__export(broker_exports, {
  requestSwapDepositAddress: () => requestSwapDepositAddress
});
async function requestSwapDepositAddress(swapRequest, opts, chainflipNetwork2) {
  const { srcAsset, srcChain, destAsset, destChain, destAddress, maxBoostFeeBps } = swapRequest;
  const client = new rpc.HttpClient(opts.url);
  const params = validateRequest(chainflipNetwork2, [
    {
      asset: srcAsset,
      chain: srcChain
    },
    {
      asset: destAsset,
      chain: destChain
    },
    submitAddress(destChain, destAddress),
    swapRequest.commissionBps ?? 0,
    swapRequest.ccmMetadata && {
      ...swapRequest.ccmMetadata,
      cfParameters: void 0
    },
    maxBoostFeeBps,
    swapRequest.affiliates
  ]);
  const response = await client.sendRequest("broker_requestSwapDepositAddress", ...params);
  return validateResponse(chainflipNetwork2, response);
}
var submitAddress, validateRequest, validateResponse;
var init_broker = __esm({
  "../shared/src/broker.ts"() {
    init_lib();
    init_enums();
    init_parsers();
    init_schemas();
    submitAddress = /* @__PURE__ */ __name((chain2, address) => {
      if (chain2 === exports.Chains.Polkadot) {
        return address.startsWith("0x") ? z.string().length(66).parse(address) : bytes.bytesToHex(ss582__namespace.decode(address).data);
      }
      return address;
    }, "submitAddress");
    validateRequest = /* @__PURE__ */ __name((network, params) => z.tuple([
      assetAndChain,
      assetAndChain,
      z.union([
        numericString,
        hexString,
        btcAddress(network)
      ]),
      z.number(),
      ccmMetadataSchema.merge(z.object({
        cfParameters: z.union([
          hexString,
          z.string()
        ]).optional()
      })).transform(({ message, ...rest }) => ({
        message,
        cf_parameters: rest.cfParameters,
        gas_budget: `0x${BigInt(rest.gasBudget).toString(16)}`
      })).optional(),
      z.number().optional(),
      z.array(affiliateBroker).optional()
    ]).parse(params), "validateRequest");
    validateResponse = /* @__PURE__ */ __name((network, response) => z.object({
      address: z.union([
        dotAddress,
        ethereumAddress,
        btcAddress(network)
      ]),
      issued_block: z.number(),
      channel_id: z.number(),
      source_chain_expiry_block: z.bigint(),
      channel_opening_fee: z.bigint()
    }).transform(({ address, issued_block, channel_id, source_chain_expiry_block, channel_opening_fee }) => ({
      address,
      issuedBlock: issued_block,
      channelId: BigInt(channel_id),
      sourceChainExpiryBlock: source_chain_expiry_block,
      channelOpeningFee: channel_opening_fee
    })).parse(response), "validateResponse");
    __name(requestSwapDepositAddress, "requestSwapDepositAddress");
  }
});

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x) {
  return x;
}
__name(identity, "identity");
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return /* @__PURE__ */ __name(function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  }, "piped");
}
__name(pipeFromArray, "pipeFromArray");
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      __name(unsubscribe, "unsubscribe");
      teardownRef = subscribe({
        next(value) {
          if (isDone) {
            return;
          }
          observer.next?.(value);
        },
        error(err) {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.error?.(err);
          unsubscribe();
        },
        complete() {
          if (isDone) {
            return;
          }
          isDone = true;
          observer.complete?.();
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self);
    }
  };
  return self;
}
__name(observable, "observable");

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          for (const observer of observers) {
            observer.next?.(value);
          }
        },
        error(error) {
          for (const observer of observers) {
            observer.error?.(error);
          }
        },
        complete() {
          for (const observer of observers) {
            observer.complete?.();
          }
        }
      });
    }
    __name(startIfNeeded, "startIfNeeded");
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    __name(resetIfNeeded, "resetIfNeeded");
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v) => v === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
__name(share, "share");
var _ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
__name(_ObservableAbortError, "ObservableAbortError");
var ObservableAbortError = _ObservableAbortError;
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    __name(onDone, "onDone");
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}
__name(observableToPromise, "observableToPromise");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    __name(execute, "execute");
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
__name(createChain, "createChain");

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/codes-c924c3db.mjs
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v = obj[key];
    newObj[v] = key;
  }
  return newObj;
}
__name(invert, "invert");
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
invert(TRPC_ERROR_CODES_BY_KEY);

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/index-f91d720c.mjs
invert(TRPC_ERROR_CODES_BY_KEY);
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path[path.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path.slice(0, -1) : path
      });
    }
  });
  return proxy;
}
__name(createInnerProxy, "createInnerProxy");
var createRecursiveProxy = /* @__PURE__ */ __name((callback) => createInnerProxy(callback, []), "createRecursiveProxy");
var createFlatProxy = /* @__PURE__ */ __name((callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
}, "createFlatProxy");

// ../../node_modules/.pnpm/@trpc+server@10.45.2/node_modules/@trpc/server/dist/getCauseFromUnknown-2d66414a.mjs
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
__name(isObject, "isObject");
var _UnknownCauseError = class _UnknownCauseError extends Error {
};
__name(_UnknownCauseError, "UnknownCauseError");
var UnknownCauseError = _UnknownCauseError;
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type = typeof cause;
  if (type === "undefined" || type === "function" || cause === null) {
    return void 0;
  }
  if (type !== "object") {
    return new Error(String(cause));
  }
  if (isObject(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
__name(getCauseFromUnknown, "getCauseFromUnknown");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/transformResult-ace864b8.mjs
function isObject2(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
__name(isObject2, "isObject");
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
__name(transformResultInner, "transformResultInner");
var _TransformResultError = class _TransformResultError extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
__name(_TransformResultError, "TransformResultError");
var TransformResultError = _TransformResultError;
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject2(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject2(result.result)) {
    throw new TransformResultError();
  }
  return result;
}
__name(transformResult, "transformResult");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/TRPCClientError-38f9a32a.mjs
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
__name(isTRPCClientError, "isTRPCClientError");
function isTRPCErrorResponse(obj) {
  return isObject2(obj) && isObject2(obj.error) && typeof obj.error.code === "number" && typeof obj.error.message === "string";
}
__name(isTRPCErrorResponse, "isTRPCErrorResponse");
var _TRPCClientError = class _TRPCClientError extends Error {
  static from(_cause, opts = {}) {
    const cause = _cause;
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    if (isTRPCErrorResponse(cause)) {
      return new _TRPCClientError(cause.error.message, {
        ...opts,
        result: cause
      });
    }
    if (!(cause instanceof Error)) {
      return new _TRPCClientError("Unknown error", {
        ...opts,
        cause
      });
    }
    return new _TRPCClientError(cause.message, {
      ...opts,
      cause: getCauseFromUnknown(cause)
    });
  }
  constructor(message, opts) {
    const cause = opts?.cause;
    super(message, {
      cause
    });
    this.meta = opts?.meta;
    this.cause = cause;
    this.shape = opts?.result?.error;
    this.data = opts?.result?.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};
__name(_TRPCClientError, "TRPCClientError");
var TRPCClientError = _TRPCClientError;

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/httpUtils-b9d0cb48.mjs
var isFunction = /* @__PURE__ */ __name((fn) => typeof fn === "function", "isFunction");
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
__name(getFetch, "getFetch");
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
__name(getAbortController, "getAbortController");
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url.toString().replace(/\/$/, ""),
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
__name(resolveHTTPLinkOptions, "resolveHTTPLinkOptions");
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
__name(arrayToDict, "arrayToDict");
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
__name(getInput, "getInput");
var getUrl = /* @__PURE__ */ __name((opts) => {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
}, "getUrl");
var getBody = /* @__PURE__ */ __name((opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
}, "getBody");
var jsonHttpRequester = /* @__PURE__ */ __name((opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
}, "jsonHttpRequester");
async function fetchHTTPResponse(opts, ac) {
  const url = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type } = opts;
  const resolvedHeaders = await opts.headers();
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url, {
    method: METHOD[type],
    signal: ac?.signal,
    body,
    headers
  });
}
__name(fetchHTTPResponse, "fetchHTTPResponse");
function httpRequest(opts) {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  let done = false;
  const promise = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts, ac).then((_res) => {
      meta.response = _res;
      done = true;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      done = true;
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = /* @__PURE__ */ __name(() => {
    if (!done) {
      ac?.abort();
    }
  }, "cancel");
  return {
    promise,
    cancel
  };
}
__name(httpRequest, "httpRequest");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/httpBatchLink-d0f9eac9.mjs
var throwFatalError = /* @__PURE__ */ __name(() => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
}, "throwFatalError");
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = /* @__PURE__ */ __name(() => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  }, "destroyTimerAndPendingItems");
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject?.(new Error("Aborted"));
        index++;
        continue;
      }
      const isValid2 = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid2) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject?.(new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  __name(groupItems, "groupItems");
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = /* @__PURE__ */ __name((index, value) => {
        const item = batch.items[index];
        item.resolve?.(value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      }, "unitResolver");
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise.then((result) => {
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          unitResolver(i, value);
        }
        for (const item of batch.items) {
          item.reject?.(new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject?.(cause);
          item.batch = null;
        }
      });
    }
  }
  __name(dispatch, "dispatch");
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = /* @__PURE__ */ __name(() => {
      item.aborted = true;
      if (item.batch?.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    }, "cancel");
    return {
      promise,
      cancel
    };
  }
  __name(load, "load");
  return {
    load
  };
}
__name(dataLoader, "dataLoader");
function createHTTPBatchLink(requester) {
  return /* @__PURE__ */ __name(function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = /* @__PURE__ */ __name((type) => {
        const validate = /* @__PURE__ */ __name((batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path,
            inputs
          });
          return url.length <= maxURLLength;
        }, "validate");
        const fetch = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts
        });
        return {
          validate,
          fetch
        };
      }, "batchLoader");
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise, cancel } = loader.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, {
              meta: _res?.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  }, "httpBatchLink");
}
__name(createHTTPBatchLink, "createHTTPBatchLink");
var batchRequester = /* @__PURE__ */ __name((requesterOpts) => {
  return (batchOps) => {
    const path = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
}, "batchRequester");
var httpBatchLink = createHTTPBatchLink(batchRequester);

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer) => {
      const { path, input, type } = op;
      const { promise, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type,
        path,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer.next({
          context: res.meta,
          result: transformed.result
        });
        observer.complete();
      }).catch((cause) => {
        observer.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
__name(httpLinkFactory, "httpLinkFactory");

// ../../node_modules/.pnpm/@trpc+client@10.45.2_@trpc+server@10.45.2/node_modules/@trpc/client/dist/index.mjs
var _TRPCUntypedClient = class _TRPCUntypedClient {
  $request({ type, input, path, context = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path,
        input,
        context
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      opts.signal?.addEventListener("abort", abort);
      promise.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  mutation(path, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path,
      input,
      context: opts?.context,
      signal: opts?.signal
    });
  }
  subscription(path, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path,
      input,
      context: opts?.context
    });
    return observable$.subscribe({
      next(envelope) {
        if (envelope.result.type === "started") {
          opts.onStarted?.();
        } else if (envelope.result.type === "stopped") {
          opts.onStopped?.();
        } else {
          opts.onData?.(envelope.result.data);
        }
      },
      error(err) {
        opts.onError?.(err);
      },
      complete() {
        opts.onComplete?.();
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: /* @__PURE__ */ __name((data) => data, "serialize"),
            deserialize: /* @__PURE__ */ __name((data) => data, "deserialize")
          },
          output: {
            serialize: /* @__PURE__ */ __name((data) => data, "serialize"),
            deserialize: /* @__PURE__ */ __name((data) => data, "deserialize")
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: /* @__PURE__ */ __name((data) => combinedTransformer.input.serialize(data), "serialize"),
        deserialize: /* @__PURE__ */ __name((data) => combinedTransformer.output.deserialize(data), "deserialize")
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
__name(_TRPCUntypedClient, "TRPCUntypedClient");
var TRPCUntypedClient = _TRPCUntypedClient;
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var clientCallTypeToProcedureType = /* @__PURE__ */ __name((clientCallType) => {
  return clientCallTypeMap[clientCallType];
}, "clientCallTypeToProcedureType");
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    if (key === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
__name(createTRPCClientProxy, "createTRPCClientProxy");
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
__name(createTRPCProxyClient, "createTRPCProxyClient");
function getTextDecoder(customTextDecoder) {
  if (customTextDecoder) {
    return customTextDecoder;
  }
  if (typeof window !== "undefined" && window.TextDecoder) {
    return new window.TextDecoder();
  }
  if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
    return new globalThis.TextDecoder();
  }
  throw new Error("No TextDecoder implementation found");
}
__name(getTextDecoder, "getTextDecoder");
async function parseJSONStream(opts) {
  const parse2 = opts.parse ?? JSON.parse;
  const onLine = /* @__PURE__ */ __name((line) => {
    if (opts.signal?.aborted) return;
    if (!line || line === "}") {
      return;
    }
    const indexOfColon = line.indexOf(":");
    const indexAsStr = line.substring(2, indexOfColon - 1);
    const text = line.substring(indexOfColon + 1);
    opts.onSingle(Number(indexAsStr), parse2(text));
  }, "onLine");
  await readLines(opts.readableStream, onLine, opts.textDecoder);
}
__name(parseJSONStream, "parseJSONStream");
async function readLines(readableStream, onLine, textDecoder) {
  let partOfLine = "";
  const onChunk = /* @__PURE__ */ __name((chunk) => {
    const chunkText = textDecoder.decode(chunk);
    const chunkLines = chunkText.split("\n");
    if (chunkLines.length === 1) {
      partOfLine += chunkLines[0];
    } else if (chunkLines.length > 1) {
      onLine(partOfLine + chunkLines[0]);
      for (let i = 1; i < chunkLines.length - 1; i++) {
        onLine(chunkLines[i]);
      }
      partOfLine = chunkLines[chunkLines.length - 1];
    }
  }, "onChunk");
  if ("getReader" in readableStream) {
    await readStandardChunks(readableStream, onChunk);
  } else {
    await readNodeChunks(readableStream, onChunk);
  }
  onLine(partOfLine);
}
__name(readLines, "readLines");
function readNodeChunks(stream, onChunk) {
  return new Promise((resolve) => {
    stream.on("data", onChunk);
    stream.on("end", resolve);
  });
}
__name(readNodeChunks, "readNodeChunks");
async function readStandardChunks(stream, onChunk) {
  const reader = stream.getReader();
  let readResult = await reader.read();
  while (!readResult.done) {
    onChunk(readResult.value);
    readResult = await reader.read();
  }
}
__name(readStandardChunks, "readStandardChunks");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/double-indexed-kv.js
var DoubleIndexedKV = (
  /** @class */
  function() {
    function DoubleIndexedKV2() {
      this.keyToValue = /* @__PURE__ */ new Map();
      this.valueToKey = /* @__PURE__ */ new Map();
    }
    __name(DoubleIndexedKV2, "DoubleIndexedKV");
    DoubleIndexedKV2.prototype.set = function(key, value) {
      this.keyToValue.set(key, value);
      this.valueToKey.set(value, key);
    };
    DoubleIndexedKV2.prototype.getByKey = function(key) {
      return this.keyToValue.get(key);
    };
    DoubleIndexedKV2.prototype.getByValue = function(value) {
      return this.valueToKey.get(value);
    };
    DoubleIndexedKV2.prototype.clear = function() {
      this.keyToValue.clear();
      this.valueToKey.clear();
    };
    return DoubleIndexedKV2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/registry.js
var Registry = (
  /** @class */
  function() {
    function Registry2(generateIdentifier) {
      this.generateIdentifier = generateIdentifier;
      this.kv = new DoubleIndexedKV();
    }
    __name(Registry2, "Registry");
    Registry2.prototype.register = function(value, identifier) {
      if (this.kv.getByValue(value)) {
        return;
      }
      if (!identifier) {
        identifier = this.generateIdentifier(value);
      }
      this.kv.set(identifier, value);
    };
    Registry2.prototype.clear = function() {
      this.kv.clear();
    };
    Registry2.prototype.getIdentifier = function(value) {
      return this.kv.getByValue(value);
    };
    Registry2.prototype.getValue = function(identifier) {
      return this.kv.getByKey(identifier);
    };
    return Registry2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/class-registry.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = /* @__PURE__ */ __name(function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  }, "extendStatics");
  return function(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    __name(__, "__");
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ClassRegistry = (
  /** @class */
  function(_super) {
    __extends(ClassRegistry2, _super);
    function ClassRegistry2() {
      var _this = _super.call(this, function(c) {
        return c.name;
      }) || this;
      _this.classToAllowedProps = /* @__PURE__ */ new Map();
      return _this;
    }
    __name(ClassRegistry2, "ClassRegistry");
    ClassRegistry2.prototype.register = function(value, options) {
      if (typeof options === "object") {
        if (options.allowProps) {
          this.classToAllowedProps.set(value, options.allowProps);
        }
        _super.prototype.register.call(this, value, options.identifier);
      } else {
        _super.prototype.register.call(this, value, options);
      }
    };
    ClassRegistry2.prototype.getAllowedProps = function(value) {
      return this.classToAllowedProps.get(value);
    };
    return ClassRegistry2;
  }(Registry)
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/util.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  var values = [];
  for (var key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
__name(valuesOfObj, "valuesOfObj");
function find(record, predicate) {
  var values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  var valuesNotNever = values;
  for (var i = 0; i < valuesNotNever.length; i++) {
    var value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
__name(find, "find");
function forEach(record, run) {
  Object.entries(record).forEach(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    return run(value, key);
  });
}
__name(forEach, "forEach");
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
__name(includes, "includes");
function findArr(record, predicate) {
  for (var i = 0; i < record.length; i++) {
    var value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
__name(findArr, "findArr");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/custom-transformer-registry.js
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function CustomTransformerRegistry2() {
      this.transfomers = {};
    }
    __name(CustomTransformerRegistry2, "CustomTransformerRegistry");
    CustomTransformerRegistry2.prototype.register = function(transformer) {
      this.transfomers[transformer.name] = transformer;
    };
    CustomTransformerRegistry2.prototype.findApplicable = function(v) {
      return find(this.transfomers, function(transformer) {
        return transformer.isApplicable(v);
      });
    };
    CustomTransformerRegistry2.prototype.findByName = function(name) {
      return this.transfomers[name];
    };
    return CustomTransformerRegistry2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/is.js
var getType = /* @__PURE__ */ __name(function(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}, "getType");
var isUndefined = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "undefined";
}, "isUndefined");
var isNull = /* @__PURE__ */ __name(function(payload) {
  return payload === null;
}, "isNull");
var isPlainObject = /* @__PURE__ */ __name(function(payload) {
  if (typeof payload !== "object" || payload === null) return false;
  if (payload === Object.prototype) return false;
  if (Object.getPrototypeOf(payload) === null) return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
}, "isPlainObject");
var isEmptyObject = /* @__PURE__ */ __name(function(payload) {
  return isPlainObject(payload) && Object.keys(payload).length === 0;
}, "isEmptyObject");
var isArray = /* @__PURE__ */ __name(function(payload) {
  return Array.isArray(payload);
}, "isArray");
var isString = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "string";
}, "isString");
var isNumber = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "number" && !isNaN(payload);
}, "isNumber");
var isBoolean = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "boolean";
}, "isBoolean");
var isRegExp = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof RegExp;
}, "isRegExp");
var isMap = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Map;
}, "isMap");
var isSet = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Set;
}, "isSet");
var isSymbol = /* @__PURE__ */ __name(function(payload) {
  return getType(payload) === "Symbol";
}, "isSymbol");
var isDate = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Date && !isNaN(payload.valueOf());
}, "isDate");
var isError = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof Error;
}, "isError");
var isNaNValue = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "number" && isNaN(payload);
}, "isNaNValue");
var isPrimitive = /* @__PURE__ */ __name(function(payload) {
  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
}, "isPrimitive");
var isBigint = /* @__PURE__ */ __name(function(payload) {
  return typeof payload === "bigint";
}, "isBigint");
var isInfinite = /* @__PURE__ */ __name(function(payload) {
  return payload === Infinity || payload === -Infinity;
}, "isInfinite");
var isTypedArray = /* @__PURE__ */ __name(function(payload) {
  return ArrayBuffer.isView(payload) && !(payload instanceof DataView);
}, "isTypedArray");
var isURL = /* @__PURE__ */ __name(function(payload) {
  return payload instanceof URL;
}, "isURL");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/pathstringifier.js
var escapeKey = /* @__PURE__ */ __name(function(key) {
  return key.replace(/\./g, "\\.");
}, "escapeKey");
var stringifyPath = /* @__PURE__ */ __name(function(path) {
  return path.map(String).map(escapeKey).join(".");
}, "stringifyPath");
var parsePath = /* @__PURE__ */ __name(function(string2) {
  var result = [];
  var segment = "";
  for (var i = 0; i < string2.length; i++) {
    var char = string2.charAt(i);
    var isEscapedDot = char === "\\" && string2.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    var isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  var lastSegment = segment;
  result.push(lastSegment);
  return result;
}, "parsePath");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/transformer.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
};
function simpleTransformation(isApplicable, annotation, transform2, untransform) {
  return {
    isApplicable,
    annotation,
    transform: transform2,
    untransform
  };
}
__name(simpleTransformation, "simpleTransformation");
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", function() {
    return null;
  }, function() {
    return void 0;
  }),
  simpleTransformation(isBigint, "bigint", function(v) {
    return v.toString();
  }, function(v) {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", function(v) {
    return v.toISOString();
  }, function(v) {
    return new Date(v);
  }),
  simpleTransformation(isError, "Error", function(v, superJson) {
    var baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach(function(prop) {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, function(v, superJson) {
    var e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach(function(prop) {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", function(v) {
    return "" + v;
  }, function(regex) {
    var body = regex.slice(1, regex.lastIndexOf("/"));
    var flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(v) {
      return __spreadArray([], __read2(v.values()));
    },
    function(v) {
      return new Set(v);
    }
  ),
  simpleTransformation(isMap, "map", function(v) {
    return __spreadArray([], __read2(v.entries()));
  }, function(v) {
    return new Map(v);
  }),
  simpleTransformation(function(v) {
    return isNaNValue(v) || isInfinite(v);
  }, "number", function(v) {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation(function(v) {
    return v === 0 && 1 / v === -Infinity;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(v) {
    return v.toString();
  }, function(v) {
    return new URL(v);
  })
];
function compositeTransformation(isApplicable, annotation, transform2, untransform) {
  return {
    isApplicable,
    annotation,
    transform: transform2,
    untransform
  };
}
__name(compositeTransformation, "compositeTransformation");
var symbolRule = compositeTransformation(function(s, superJson) {
  if (isSymbol(s)) {
    var isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, function(s, superJson) {
  var identifier = superJson.symbolRegistry.getIdentifier(s);
  return [
    "symbol",
    identifier
  ];
}, function(v) {
  return v.description;
}, function(_, a, superJson) {
  var value = superJson.symbolRegistry.getValue(a[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(obj, ctor) {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, function(v) {
  return [
    "typed-array",
    v.constructor.name
  ];
}, function(v) {
  return __spreadArray([], __read2(v));
}, function(v, a) {
  var ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {
    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
__name(isInstanceOfRegisteredClass, "isInstanceOfRegisteredClass");
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(clazz, superJson) {
  var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return [
    "class",
    identifier
  ];
}, function(clazz, superJson) {
  var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return __assign({}, clazz);
  }
  var result = {};
  allowedProps.forEach(function(prop) {
    result[prop] = clazz[prop];
  });
  return result;
}, function(v, a, superJson) {
  var clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation(function(value, superJson) {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return [
    "custom",
    transformer.name
  ];
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, function(v, a, superJson) {
  var transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [
  classRule,
  symbolRule,
  customRule,
  typedArrayRule
];
var transformValue = /* @__PURE__ */ __name(function(value, superJson) {
  var applicableCompositeRule = findArr(compositeRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  var applicableSimpleRule = findArr(simpleRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
}, "transformValue");
var simpleRulesByAnnotation = {};
simpleRules.forEach(function(rule) {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = /* @__PURE__ */ __name(function(json, type, superJson) {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    var transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
}, "untransformValue");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/accessDeep.js
var getNthKey = /* @__PURE__ */ __name(function(value, n) {
  var keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
}, "getNthKey");
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
__name(validatePath, "validatePath");
var getDeep = /* @__PURE__ */ __name(function(object, path) {
  validatePath(path);
  for (var i = 0; i < path.length; i++) {
    var key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      var row = +key;
      var type = +path[++i] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
}, "getDeep");
var setDeep = /* @__PURE__ */ __name(function(object, path, mapper) {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  var parent = object;
  for (var i = 0; i < path.length - 1; i++) {
    var key = path[i];
    if (isArray(parent)) {
      var index = +key;
      parent = parent[index];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      var row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      var isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      var row = +key;
      var type = +path[++i] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  var lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    var oldValue = getNthKey(parent, +lastKey);
    var newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent["delete"](oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    var row = +path[path.length - 2];
    var keyToRow = getNthKey(parent, row);
    var type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        var newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent["delete"](keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
}, "setDeep");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/plainer.js
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
};
function traverse(tree, walker2, origin) {
  if (origin === void 0) {
    origin = [];
  }
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, function(subtree, key) {
      return traverse(subtree, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
    return;
  }
  var _a = __read3(tree, 2), nodeValue = _a[0], children = _a[1];
  if (children) {
    forEach(children, function(child, key) {
      traverse(child, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
  }
  walker2(nodeValue, origin);
}
__name(traverse, "traverse");
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, function(type, path) {
    plain = setDeep(plain, path, function(v) {
      return untransformValue(v, type, superJson);
    });
  });
  return plain;
}
__name(applyValueAnnotations, "applyValueAnnotations");
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    var object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach(function(identicalObjectPath) {
      plain = setDeep(plain, identicalObjectPath, function() {
        return object;
      });
    });
  }
  __name(apply, "apply");
  if (isArray(annotations)) {
    var _a = __read3(annotations, 2), root = _a[0], other = _a[1];
    root.forEach(function(identicalPath) {
      plain = setDeep(plain, parsePath(identicalPath), function() {
        return plain;
      });
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
__name(applyReferentialEqualityAnnotations, "applyReferentialEqualityAnnotations");
var isDeep = /* @__PURE__ */ __name(function(object, superJson) {
  return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
}, "isDeep");
function addIdentity(object, path, identities) {
  var existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [
      path
    ]);
  }
}
__name(addIdentity, "addIdentity");
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  var result = {};
  var rootEqualityPaths = void 0;
  identitites.forEach(function(paths) {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map(function(path) {
        return path.map(String);
      }).sort(function(a, b) {
        return a.length - b.length;
      });
    }
    var _a = __read3(paths), representativePath = _a[0], identicalPaths = _a.slice(1);
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [
        rootEqualityPaths
      ];
    } else {
      return [
        rootEqualityPaths,
        result
      ];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
__name(generateReferentialEqualityAnnotations, "generateReferentialEqualityAnnotations");
var walker = /* @__PURE__ */ __name(function(object, identities, superJson, dedupe, path, objectsInThisPath, seenObjects) {
  var _a;
  if (path === void 0) {
    path = [];
  }
  if (objectsInThisPath === void 0) {
    objectsInThisPath = [];
  }
  if (seenObjects === void 0) {
    seenObjects = /* @__PURE__ */ new Map();
  }
  var primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    var seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    var transformed_1 = transformValue(object, superJson);
    var result_1 = transformed_1 ? {
      transformedValue: transformed_1.value,
      annotations: [
        transformed_1.type
      ]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result_1);
    }
    return result_1;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  var transformationResult = transformValue(object, superJson);
  var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;
  var transformedValue = isArray(transformed) ? [] : {};
  var innerAnnotations = {};
  forEach(transformed, function(value, index) {
    var recursiveResult = walker(value, identities, superJson, dedupe, __spreadArray2(__spreadArray2([], __read3(path)), [
      index
    ]), __spreadArray2(__spreadArray2([], __read3(objectsInThisPath)), [
      object
    ]), seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, function(tree, key) {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  var result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [
      transformationResult.type
    ] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [
      transformationResult.type,
      innerAnnotations
    ] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
}, "walker");

// ../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
__name(getType2, "getType");
function isArray2(payload) {
  return getType2(payload) === "Array";
}
__name(isArray2, "isArray");
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object") return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
__name(isPlainObject2, "isPlainObject");
function isNull2(payload) {
  return getType2(payload) === "Null";
}
__name(isNull2, "isNull");
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}
__name(isOneOf, "isOneOf");
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
__name(isUndefined2, "isUndefined");

// ../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable") carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
__name(assignProp, "assignProp");
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [
    ...props,
    ...symbols
  ].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}
__name(copy, "copy");

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];
  return to;
};
var SuperJSON = (
  /** @class */
  function() {
    function SuperJSON2(_a) {
      var _b = _a === void 0 ? {} : _a, _c = _b.dedupe, dedupe = _c === void 0 ? false : _c;
      this.classRegistry = new ClassRegistry();
      this.symbolRegistry = new Registry(function(s) {
        var _a2;
        return (_a2 = s.description) !== null && _a2 !== void 0 ? _a2 : "";
      });
      this.customTransformerRegistry = new CustomTransformerRegistry();
      this.allowedErrorProps = [];
      this.dedupe = dedupe;
    }
    __name(SuperJSON2, "SuperJSON");
    SuperJSON2.prototype.serialize = function(object) {
      var identities = /* @__PURE__ */ new Map();
      var output = walker(object, identities, this, this.dedupe);
      var res = {
        json: output.transformedValue
      };
      if (output.annotations) {
        res.meta = __assign2(__assign2({}, res.meta), {
          values: output.annotations
        });
      }
      var equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
      if (equalityAnnotations) {
        res.meta = __assign2(__assign2({}, res.meta), {
          referentialEqualities: equalityAnnotations
        });
      }
      return res;
    };
    SuperJSON2.prototype.deserialize = function(payload) {
      var json = payload.json, meta = payload.meta;
      var result = copy(json);
      if (meta === null || meta === void 0 ? void 0 : meta.values) {
        result = applyValueAnnotations(result, meta.values, this);
      }
      if (meta === null || meta === void 0 ? void 0 : meta.referentialEqualities) {
        result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
      }
      return result;
    };
    SuperJSON2.prototype.stringify = function(object) {
      return JSON.stringify(this.serialize(object));
    };
    SuperJSON2.prototype.parse = function(string2) {
      return this.deserialize(JSON.parse(string2));
    };
    SuperJSON2.prototype.registerClass = function(v, options) {
      this.classRegistry.register(v, options);
    };
    SuperJSON2.prototype.registerSymbol = function(v, identifier) {
      this.symbolRegistry.register(v, identifier);
    };
    SuperJSON2.prototype.registerCustom = function(transformer, name) {
      this.customTransformerRegistry.register(__assign2({
        name
      }, transformer));
    };
    SuperJSON2.prototype.allowErrorProps = function() {
      var _a;
      var props = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        props[_i] = arguments[_i];
      }
      (_a = this.allowedErrorProps).push.apply(_a, __spreadArray3([], __read4(props)));
    };
    SuperJSON2.defaultInstance = new SuperJSON2();
    SuperJSON2.serialize = SuperJSON2.defaultInstance.serialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.deserialize = SuperJSON2.defaultInstance.deserialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.stringify = SuperJSON2.defaultInstance.stringify.bind(SuperJSON2.defaultInstance);
    SuperJSON2.parse = SuperJSON2.defaultInstance.parse.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerClass = SuperJSON2.defaultInstance.registerClass.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerSymbol = SuperJSON2.defaultInstance.registerSymbol.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerCustom = SuperJSON2.defaultInstance.registerCustom.bind(SuperJSON2.defaultInstance);
    SuperJSON2.allowErrorProps = SuperJSON2.defaultInstance.allowErrorProps.bind(SuperJSON2.defaultInstance);
    return SuperJSON2;
  }()
);
var esm_default = SuperJSON;
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;

// src/swap/sdk.ts
init_enums();
init_guards();

// ../shared/src/rpc/index.ts
init_enums();
var camelCase = /* @__PURE__ */ __name((str) => str.replace(/_([a-z])/g, (_, char) => char.toUpperCase()), "camelCase");
var camelCaseKeys = /* @__PURE__ */ __name((obj) => {
  if (typeof obj !== "object" || obj === null) return obj;
  if (Array.isArray(obj)) return obj.map((item) => camelCaseKeys(item));
  return Object.fromEntries(Object.entries(obj).map(([key, value]) => [
    camelCase(key),
    camelCaseKeys(value)
  ]));
}, "camelCaseKeys");
var createRequest = /* @__PURE__ */ __name((method) => async (urlOrNetwork, ...params) => {
  const url = "network" in urlOrNetwork ? rpc.constants.PUBLIC_RPC_ENDPOINTS[urlOrNetwork.network] : urlOrNetwork.rpcUrl;
  const result = await new rpc.HttpClient(url).sendRequest(method, ...params);
  return camelCaseKeys(result);
}, "createRequest");
var transform = /* @__PURE__ */ __name((fn, cb) => (...args) => fn(...args).then(cb), "transform");
createRequest("cf_funding_environment");
createRequest("cf_swapping_environment");
createRequest("cf_ingress_egress_environment");
var getEnvironment = createRequest("cf_environment");
createRequest("cf_swap_rate");
createRequest("state_getMetadata");
var getSupportedAssets = createRequest("cf_supported_assets");
createRequest("state_getRuntimeVersion");
createRequest("chain_getBlockHash");
var getAllBoostPoolsDepth = transform(createRequest("cf_boost_pools_depth"), (result) => result.map(({ chain: chain2, asset: asset2, ...rest }) => ({
  asset: getInternalAsset({
    chain: chain2,
    asset: asset2
  }),
  ...rest
})));
createRequest("cf_swap_rate_v2");

// ../shared/src/rpc/utils.ts
init_enums();
var MAX_SWAP_AMOUNT = 2n ** 128n - 1n;
var validateSwapAmount = /* @__PURE__ */ __name((env, asset2, amount) => {
  const minimumAmount = readChainAssetValue(env.ingressEgress.minimumDepositAmounts, asset2);
  if (amount < minimumAmount) {
    return {
      success: false,
      reason: `expected amount is below minimum swap amount (${minimumAmount})`
    };
  }
  const maxAmount = readChainAssetValue(env.swapping.maximumSwapAmounts, asset2) ?? MAX_SWAP_AMOUNT;
  if (maxAmount != null && amount > maxAmount) {
    return {
      success: false,
      reason: `expected amount is above maximum swap amount (${maxAmount})`
    };
  }
  return {
    success: true
  };
}, "validateSwapAmount");
var _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var _ERC20__factory = class _ERC20__factory {
  static createInterface() {
    return new ethers.Interface(_abi);
  }
  static connect(address, runner) {
    return new ethers.Contract(address, _abi, runner);
  }
};
__name(_ERC20__factory, "ERC20__factory");
__publicField(_ERC20__factory, "abi", _abi);
var ERC20__factory = _ERC20__factory;
var _abi2 = [
  {
    inputs: [
      {
        internalType: "contract IKeyManager",
        name: "keyManager",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "swapID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "AddGasNative",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bytes32",
        name: "swapID",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      }
    ],
    name: "AddGasToken",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "communityGuardDisabled",
        type: "bool"
      }
    ],
    name: "CommunityGuardDisabled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address payable",
        name: "multicallAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "reason",
        type: "bytes"
      }
    ],
    name: "ExecuteActionsFailed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "suspended",
        type: "bool"
      }
    ],
    name: "Suspended",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "SwapNative",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "srcToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "SwapToken",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address payable",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "TransferNativeFailed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address payable",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "reason",
        type: "bytes"
      }
    ],
    name: "TransferTokenFailed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "keyManager",
        type: "address"
      }
    ],
    name: "UpdatedKeyManager",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "gasAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "XCallNative",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "srcToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "gasAmount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "XCallToken",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "swapID",
        type: "bytes32"
      }
    ],
    name: "addGasNative",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "swapID",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "contract IERC20",
        name: "token",
        type: "address"
      }
    ],
    name: "addGasToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "swapID",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        internalType: "struct IShared.DeployFetchParams[]",
        name: "deployFetchParamsArray",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "address payable",
            name: "fetchContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        internalType: "struct IShared.FetchParams[]",
        name: "fetchParamsArray",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IShared.TransferParams[]",
        name: "transferParamsArray",
        type: "tuple[]"
      }
    ],
    name: "allBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "swapID",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        internalType: "struct IShared.DeployFetchParams[]",
        name: "deployFetchParamsArray",
        type: "tuple[]"
      }
    ],
    name: "deployAndFetchBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "disableCommunityGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "enableCommunityGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IShared.TransferParams",
        name: "transferParams",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "enum IMulticall.CallType",
            name: "callType",
            type: "uint8"
          },
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "payload",
            type: "bytes"
          }
        ],
        internalType: "struct IMulticall.Call[]",
        name: "calls",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "gasMulticall",
        type: "uint256"
      }
    ],
    name: "executeActions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        internalType: "uint32",
        name: "srcChain",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "srcAddress",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "executexCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IShared.TransferParams",
        name: "transferParams",
        type: "tuple"
      },
      {
        internalType: "uint32",
        name: "srcChain",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "srcAddress",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      }
    ],
    name: "executexSwapAndCall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address payable",
            name: "fetchContract",
            type: "address"
          },
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        internalType: "struct IShared.FetchParams[]",
        name: "fetchParamsArray",
        type: "tuple[]"
      }
    ],
    name: "fetchBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getCommunityGuardDisabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCommunityKey",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getGovernor",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getKeyManager",
    outputs: [
      {
        internalType: "contract IKeyManager",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getSuspendedState",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "tokens",
        type: "address[]"
      }
    ],
    name: "govWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "resume",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "suspend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IShared.TransferParams",
        name: "transferParams",
        type: "tuple"
      }
    ],
    name: "transfer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        internalType: "struct IShared.TransferParams[]",
        name: "transferParamsArray",
        type: "tuple[]"
      }
    ],
    name: "transferBatch",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "sig",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "kTimesGAddress",
            type: "address"
          }
        ],
        internalType: "struct IShared.SigData",
        name: "sigData",
        type: "tuple"
      },
      {
        internalType: "contract IKeyManager",
        name: "keyManager",
        type: "address"
      },
      {
        internalType: "bool",
        name: "omitChecks",
        type: "bool"
      }
    ],
    name: "updateKeyManager",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "gasAmount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "xCallNative",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "message",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "gasAmount",
        type: "uint256"
      },
      {
        internalType: "contract IERC20",
        name: "srcToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "xCallToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "xSwapNative",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "dstChain",
        type: "uint32"
      },
      {
        internalType: "bytes",
        name: "dstAddress",
        type: "bytes"
      },
      {
        internalType: "uint32",
        name: "dstToken",
        type: "uint32"
      },
      {
        internalType: "contract IERC20",
        name: "srcToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "cfParameters",
        type: "bytes"
      }
    ],
    name: "xSwapToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
];
var _Vault__factory = class _Vault__factory {
  static createInterface() {
    return new ethers.Interface(_abi2);
  }
  static connect(address, runner) {
    return new ethers.Contract(address, _abi2, runner);
  }
};
__name(_Vault__factory, "Vault__factory");
__publicField(_Vault__factory, "abi", _abi2);
var Vault__factory = _Vault__factory;

// ../shared/src/consts.ts
init_enums();
({
  [exports.ChainflipNetworks.backspin]: 1e3,
  [exports.ChainflipNetworks.sisyphos]: 1e3,
  [exports.ChainflipNetworks.perseverance]: 1e3,
  [exports.ChainflipNetworks.mainnet]: 1e3
});
var ETHEREUM_EVM_CHAIN_ID = {
  [exports.ChainflipNetworks.backspin]: 10997,
  [exports.ChainflipNetworks.sisyphos]: 11155111,
  [exports.ChainflipNetworks.perseverance]: 11155111,
  [exports.ChainflipNetworks.mainnet]: 1
};
var ARBITRUM_EVM_CHAIN_ID = {
  [exports.ChainflipNetworks.backspin]: 412346,
  [exports.ChainflipNetworks.sisyphos]: 421614,
  [exports.ChainflipNetworks.perseverance]: 421614,
  [exports.ChainflipNetworks.mainnet]: 42161
};
var getEvmChainId = /* @__PURE__ */ __name((chain2, network) => {
  switch (chain2) {
    case exports.Chains.Ethereum:
      return ETHEREUM_EVM_CHAIN_ID[network];
    case exports.Chains.Arbitrum:
      return ARBITRUM_EVM_CHAIN_ID[network];
    default:
      return void 0;
  }
}, "getEvmChainId");
var SEPOLIA_USDC_CONTRACT_ADDRESS = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";
var SEPOLIA_USDT_CONTRACT_ADDRESS = "0x27CEA6Eb8a21Aae05Eb29C91c5CA10592892F584";
var ADDRESSES = {
  [exports.ChainflipNetworks.backspin]: {
    FLIP_CONTRACT_ADDRESS: "0x10C6E9530F1C1AF873a391030a1D9E8ed0630D26",
    USDC_CONTRACT_ADDRESS: "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    USDT_CONTRACT_ADDRESS: "0x0DCd1Bf9A1b36cE34237eEaFef220932846BCD82",
    ARBUSDC_CONTRACT_ADDRESS: "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    VAULT_CONTRACT_ADDRESS: "0xB7A5bd0345EF1Cc5E66bf61BdeC17D2461fBd968",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xeEBe00Ac0756308ac4AaBfD76c05c4F3088B8883",
    ARB_VAULT_CONTRACT_ADDRESS: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
  },
  [exports.ChainflipNetworks.sisyphos]: {
    FLIP_CONTRACT_ADDRESS: "0xcD079EAB6B5443b545788Fd210C8800FEADd87fa",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    VAULT_CONTRACT_ADDRESS: "0xa94d6b1853F3cb611Ed3cCb701b4fdA5a9DACe85",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x1F7fE41C798cc7b1D34BdC8de2dDDA4a4bE744D9",
    ARB_VAULT_CONTRACT_ADDRESS: "0x8155BdD48CD011e1118b51A1C82be020A3E5c2f2"
  },
  [exports.ChainflipNetworks.perseverance]: {
    FLIP_CONTRACT_ADDRESS: "0xdC27c60956cB065D19F08bb69a707E37b36d8086",
    USDC_CONTRACT_ADDRESS: SEPOLIA_USDC_CONTRACT_ADDRESS,
    USDT_CONTRACT_ADDRESS: SEPOLIA_USDT_CONTRACT_ADDRESS,
    ARBUSDC_CONTRACT_ADDRESS: "0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d",
    VAULT_CONTRACT_ADDRESS: "0x36eaD71325604DC15d35FAE584D7b50646D81753",
    STATE_CHAIN_GATEWAY_ADDRESS: "0xA34a967197Ee90BB7fb28e928388a573c5CFd099",
    ARB_VAULT_CONTRACT_ADDRESS: "0x2bb150e6d4366A1BDBC4275D1F35892CD63F27e3"
  },
  [exports.ChainflipNetworks.mainnet]: {
    FLIP_CONTRACT_ADDRESS: "0x826180541412D574cf1336d22c0C0a287822678A",
    USDC_CONTRACT_ADDRESS: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    USDT_CONTRACT_ADDRESS: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    ARBUSDC_CONTRACT_ADDRESS: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    VAULT_CONTRACT_ADDRESS: "0xF5e10380213880111522dd0efD3dbb45b9f62Bcc",
    STATE_CHAIN_GATEWAY_ADDRESS: "0x6995Ab7c4D7F4B03f467Cf4c8E920427d9621DBd",
    ARB_VAULT_CONTRACT_ADDRESS: "0x79001a5e762f3bEFC8e5871b42F6734e00498920"
  }
};

// ../shared/src/contracts.ts
init_enums();
var extractOverrides = /* @__PURE__ */ __name((transactionOverrides) => {
  const { wait, ...ethersOverrides } = transactionOverrides;
  return ethersOverrides;
}, "extractOverrides");
function getTokenContractAddress(asset2, network) {
  if (asset2 === exports.ChainflipIds.Flip) return ADDRESSES[network].FLIP_CONTRACT_ADDRESS;
  if (asset2 === exports.ChainflipIds.Usdc) return ADDRESSES[network].USDC_CONTRACT_ADDRESS;
  if (asset2 === exports.ChainflipIds.Usdt) return ADDRESSES[network].USDT_CONTRACT_ADDRESS;
  if (asset2 === exports.ChainflipIds.ArbUsdc) return ADDRESSES[network].ARBUSDC_CONTRACT_ADDRESS;
  throw new Error(`No contract address for ${asset2} on ${network}`);
}
__name(getTokenContractAddress, "getTokenContractAddress");
var checkAllowance = /* @__PURE__ */ __name(async (amount, spenderAddress, erc20Address, signer) => {
  const erc20 = ERC20__factory.connect(erc20Address, signer);
  const signerAddress = await signer.getAddress();
  const allowance = await erc20.allowance(signerAddress, spenderAddress);
  return {
    allowance,
    hasSufficientAllowance: allowance >= amount,
    erc20
  };
}, "checkAllowance");
var approve = /* @__PURE__ */ __name(async (amount, spenderAddress, erc20, allowance, txOpts) => {
  if (allowance >= amount) return null;
  const transaction = await erc20.approve(spenderAddress, amount - allowance, extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "approve");
var getVaultContractAddress = /* @__PURE__ */ __name((chain2, network) => {
  if (chain2 === exports.Chains.Ethereum) return ADDRESSES[network].VAULT_CONTRACT_ADDRESS;
  if (chain2 === exports.Chains.Arbitrum) return ADDRESSES[network].ARB_VAULT_CONTRACT_ADDRESS;
  throw new Error(`No vault contract address for ${chain2} on ${network}`);
}, "getVaultContractAddress");

// ../shared/src/vault/executeSwap.ts
init_enums();

// ../shared/src/evm.ts
init_enums();
init_guards();
var assertIsEvmChain = /* @__PURE__ */ __name((chain2) => {
  const evmChainId = getEvmChainId(chain2, exports.ChainflipNetworks.backspin);
  assert(evmChainId, `Chain ${chain2} is not an evm chain`);
}, "assertIsEvmChain");
var assertSignerIsConnectedToChain = /* @__PURE__ */ __name(async (opts, chain2) => {
  if (opts.network === "localnet") return;
  assert(opts.signer.provider, "Signer has no provider");
  const sourceChainId = getEvmChainId(chain2, opts.network);
  assert(sourceChainId, `Chain ${chain2} has no evm chain id`);
  const { chainId: signerChainId } = await opts.signer.provider.getNetwork();
  assert(signerChainId === BigInt(sourceChainId), `Signer is connected to unexpected evm chain (expected: ${sourceChainId}, got: ${signerChainId})`);
}, "assertSignerIsConnectedToChain");

// ../shared/src/vault/executeSwap.ts
init_guards();
init_parsers();
init_schemas();
init_addressValidation();
var encodeAddress = /* @__PURE__ */ __name((chain2, address) => {
  if (chain2 === exports.Chains.Polkadot) return bytes.bytesToHex(ss582__namespace.decode(dotAddress.parse(address)).data);
  if (chain2 === exports.Chains.Bitcoin) return `0x${Buffer.from(address).toString("hex")}`;
  if (chain2 === exports.Chains.Ethereum || chain2 === exports.Chains.Arbitrum) return address;
  throw new Error(`cannot encode address for chain ${chain2}`);
}, "encodeAddress");
var assertIsValidSwap = /* @__PURE__ */ __name((params) => {
  const { srcAsset, destAsset } = getInternalAssets(params);
  assert(srcAsset !== destAsset, "source asset and destination asset cannot be the same");
}, "assertIsValidSwap");
var getVaultContract = /* @__PURE__ */ __name((chain2, networkOpts) => {
  const vaultContractAddress = networkOpts.network === "localnet" ? networkOpts.vaultContractAddress : getVaultContractAddress(chain2, networkOpts.network);
  return {
    vaultContract: Vault__factory.connect(vaultContractAddress, networkOpts.signer),
    vaultAddress: vaultContractAddress
  };
}, "getVaultContract");
var getErc20Address = /* @__PURE__ */ __name((asset2, networkOpts) => {
  const erc20Address = networkOpts.network === "localnet" ? networkOpts.srcTokenContractAddress : getTokenContractAddress(asset2, networkOpts.network);
  assert(erc20Address !== void 0, `Missing ERC20 contract address for ${asset2}`);
  return erc20Address;
}, "getErc20Address");
var swapNative = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const destAsset = getInternalAsset({
    chain: params.destChain,
    asset: params.destAsset
  });
  const { vaultContract: vault } = getVaultContract(params.srcChain, networkOpts);
  const transaction = await vault.xSwapNative(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, "0x", {
    value: params.amount,
    ...extractOverrides(txOpts)
  });
  await transaction.wait(txOpts.wait);
  return transaction;
}, "swapNative");
var swapToken = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const { srcAsset, destAsset } = getInternalAssets(params);
  const { vaultContract: vault, vaultAddress } = getVaultContract(params.srcChain, networkOpts);
  const erc20Address = getErc20Address(srcAsset, networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(BigInt(params.amount), vaultAddress, erc20Address, networkOpts.signer);
  assert(hasSufficientAllowance, "Swap amount exceeds allowance");
  const transaction = await vault.xSwapToken(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, erc20Address, params.amount, "0x", extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "swapToken");
var callNative = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const destAsset = getInternalAsset({
    chain: params.destChain,
    asset: params.destAsset
  });
  const { vaultContract: vault } = getVaultContract(params.srcChain, networkOpts);
  const transaction = await vault.xCallNative(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, params.ccmMetadata.message, params.ccmMetadata.gasBudget, "0x", {
    value: params.amount,
    ...extractOverrides(txOpts)
  });
  await transaction.wait(txOpts.wait);
  return transaction;
}, "callNative");
var callToken = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  const { srcAsset, destAsset } = getInternalAssets(params);
  const { vaultContract: vault, vaultAddress } = getVaultContract(params.srcChain, networkOpts);
  const erc20Address = getErc20Address(srcAsset, networkOpts);
  const { hasSufficientAllowance } = await checkAllowance(BigInt(params.amount), vaultAddress, erc20Address, networkOpts.signer);
  assert(hasSufficientAllowance, "Swap amount exceeds allowance");
  const transaction = await vault.xCallToken(chainConstants[params.destChain].contractId, encodeAddress(params.destChain, params.destAddress), assetConstants[destAsset].contractId, params.ccmMetadata.message, params.ccmMetadata.gasBudget, erc20Address, params.amount, "0x", extractOverrides(txOpts));
  await transaction.wait(txOpts.wait);
  return transaction;
}, "callToken");
var executeSwap = /* @__PURE__ */ __name(async ({ ccmMetadata: unvalidatedCcmMetadata, ...params }, networkOpts, txOpts) => {
  assertIsValidSwap(params);
  assertIsEvmChain(params.srcChain);
  assertValidAddress(params.destChain, params.destAddress, networkOpts.network);
  await assertSignerIsConnectedToChain(networkOpts, params.srcChain);
  if (unvalidatedCcmMetadata) {
    assertIsEvmChain(params.destChain);
    const ccmMetadata = ccmMetadataSchema.parse(unvalidatedCcmMetadata);
    return params.srcAsset === chainConstants[params.srcChain].gasAsset ? callNative({
      ...params,
      ccmMetadata
    }, networkOpts, txOpts) : callToken({
      ...params,
      ccmMetadata
    }, networkOpts, txOpts);
  }
  return params.srcAsset === chainConstants[params.srcChain].gasAsset ? swapNative(params, networkOpts, txOpts) : swapToken(params, networkOpts, txOpts);
}, "executeSwap");
var executeSwap_default = executeSwap;

// ../shared/src/vault/approval.ts
init_enums();
init_guards();
var checkVaultAllowance = /* @__PURE__ */ __name((params, networkOpts) => {
  const erc20Address = networkOpts.network === "localnet" ? networkOpts.srcTokenContractAddress : getTokenContractAddress(getInternalAsset({
    chain: params.srcChain,
    asset: params.srcAsset
  }), networkOpts.network);
  assert(erc20Address !== void 0, "Missing ERC20 contract address");
  const vaultContractAddress = networkOpts.network === "localnet" ? networkOpts.vaultContractAddress : getVaultContractAddress(params.srcChain, networkOpts.network);
  return checkAllowance(BigInt(params.amount), vaultContractAddress, erc20Address, networkOpts.signer);
}, "checkVaultAllowance");
var approveVault = /* @__PURE__ */ __name(async (params, networkOpts, txOpts) => {
  await assertSignerIsConnectedToChain(networkOpts, params.srcChain);
  const { hasSufficientAllowance, erc20, allowance } = await checkVaultAllowance(params, networkOpts);
  if (hasSufficientAllowance) return null;
  const vaultContractAddress = networkOpts.network === "localnet" ? networkOpts.vaultContractAddress : getVaultContractAddress(params.srcChain, networkOpts.network);
  return approve(BigInt(params.amount), vaultContractAddress, erc20, allowance, txOpts);
}, "approveVault");

// src/swap/assets.ts
init_enums();
var isGasAsset = /* @__PURE__ */ __name((asset2) => {
  const { chain: chain2 } = assetConstants[asset2];
  return assetConstants[asset2].asset === chainConstants[chain2].gasAsset;
}, "isGasAsset");
var getAssetData = /* @__PURE__ */ __name((asset2, network, env) => {
  const assetConstant = assetConstants[asset2];
  return {
    chainflipId: asset2,
    asset: assetConstant.asset,
    chain: assetConstant.chain,
    contractAddress: !isGasAsset(asset2) ? getTokenContractAddress(asset2, network) : void 0,
    decimals: assetConstant.decimals,
    name: assetConstant.name,
    symbol: assetConstant.asset,
    isMainnet: !isTestnet(network),
    minimumSwapAmount: readChainAssetValue(env.ingressEgress.minimumDepositAmounts, asset2).toString(),
    maximumSwapAmount: readChainAssetValue(env.swapping.maximumSwapAmounts, asset2)?.toString() ?? null,
    minimumEgressAmount: readChainAssetValue(env.ingressEgress.minimumEgressAmounts, asset2).toString()
  };
}, "getAssetData");

// src/swap/chains.ts
init_enums();
init_guards();
var getChainData = /* @__PURE__ */ __name((chain2, network, env) => ({
  chain: chain2,
  name: chain2,
  evmChainId: getEvmChainId(chain2, network),
  isMainnet: !isTestnet(network),
  requiredBlockConfirmations: isNotNullish(env.ingressEgress.witnessSafetyMargins[chain2]) ? Number(env.ingressEgress.witnessSafetyMargins[chain2]) + 1 : void 0
}), "getChainData");

// src/swap/consts.ts
init_enums();
var BACKEND_SERVICE_URLS = {
  [exports.ChainflipNetworks.backspin]: "https://chainflip-swap-backspin.staging/",
  [exports.ChainflipNetworks.sisyphos]: "https://chainflip-swap.staging/",
  [exports.ChainflipNetworks.perseverance]: "https://chainflip-swap-perseverance.chainflip.io/",
  [exports.ChainflipNetworks.mainnet]: "https://chainflip-swap.chainflip.io/"
};
var getQuote = /* @__PURE__ */ __name(async (baseUrl, quoteRequest, { signal }) => {
  const { brokerCommissionBps, ...returnedRequestData } = quoteRequest;
  const params = {
    amount: returnedRequestData.amount,
    srcChain: returnedRequestData.srcChain,
    srcAsset: returnedRequestData.srcAsset,
    destChain: returnedRequestData.destChain,
    destAsset: returnedRequestData.destAsset,
    ...brokerCommissionBps && {
      brokerCommissionBps: String(brokerCommissionBps)
    }
  };
  const queryParams = new URLSearchParams(params);
  const url = new URL(`/quote?${queryParams.toString()}`, baseUrl).toString();
  const { data } = await axios__default.default.get(url, {
    signal
  });
  return {
    ...returnedRequestData,
    quote: data
  };
}, "getQuote");
var getStatus = /* @__PURE__ */ __name(async (baseUrl, { id }, { signal }) => {
  const url = new URL(`/swaps/${id}`, baseUrl).toString();
  const { data } = await axios__default.default.get(url, {
    signal
  });
  return data;
}, "getStatus");

// src/swap/sdk.ts
var _SwapSDK = class _SwapSDK {
  constructor(options = {}) {
    __publicField(this, "options");
    __publicField(this, "rpcConfig");
    __publicField(this, "trpc");
    __publicField(this, "stateChainEnvironment");
    __publicField(this, "supportedAssets");
    const network = options.network ?? exports.ChainflipNetworks.perseverance;
    this.options = {
      ...options,
      network,
      backendUrl: options.backendUrl ?? BACKEND_SERVICE_URLS[network]
    };
    this.rpcConfig = options.rpcUrl ? {
      rpcUrl: options.rpcUrl
    } : {
      network
    };
    this.trpc = createTRPCProxyClient({
      transformer: esm_default,
      links: [
        httpBatchLink({
          url: new URL("/trpc", this.options.backendUrl)
        })
      ]
    });
  }
  async getChains(sourceChain) {
    if (sourceChain && !(sourceChain in exports.Chains)) throw new Error(`unsupported source chain "${sourceChain}"`);
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets()
    ]);
    const supportedChains = [
      ...new Set(supportedAssets.map((a) => assetConstants[a].chain))
    ];
    return supportedChains.map((chain2) => getChainData(chain2, this.options.network, env)).filter((chain2) => chain2.chain !== sourceChain);
  }
  async getStateChainEnvironment() {
    this.stateChainEnvironment ?? (this.stateChainEnvironment = await getEnvironment(this.rpcConfig));
    return this.stateChainEnvironment;
  }
  async getSupportedAssets() {
    this.supportedAssets ?? (this.supportedAssets = (await getSupportedAssets(this.rpcConfig)).map((asset2) => getInternalAsset(asset2, false)).filter(isNotNullish));
    return this.supportedAssets;
  }
  async getBoostPoolsDepth() {
    return getAllBoostPoolsDepth(this.rpcConfig);
  }
  async getAssets(chain2) {
    if (chain2 && !(chain2 in exports.Chains)) throw new Error(`unsupported chain "${chain2}"`);
    const [env, supportedAssets] = await Promise.all([
      this.getStateChainEnvironment(),
      this.getSupportedAssets()
    ]);
    return supportedAssets.map((asset2) => getAssetData(asset2, this.options.network, env)).filter((asset2) => !chain2 || asset2.chain === chain2);
  }
  getQuote(quoteRequest, options = {}) {
    const { brokerCommissionBps, affiliateBrokers, ...remainingRequest } = quoteRequest;
    const submitterBrokerCommissionBps = brokerCommissionBps ?? this.options.broker?.commissionBps ?? 0;
    const affiliateBrokerCommissionBps = affiliateBrokers?.reduce((acc, affiliate) => acc + affiliate.commissionBps, 0) ?? 0;
    return getQuote(this.options.backendUrl, {
      ...remainingRequest,
      brokerCommissionBps: submitterBrokerCommissionBps + affiliateBrokerCommissionBps
    }, options);
  }
  async requestDepositAddress(depositAddressRequest) {
    const { srcChain, srcAsset, amount, brokerCommissionBps, affiliateBrokers } = depositAddressRequest;
    await this.validateSwapAmount({
      chain: srcChain,
      asset: srcAsset
    }, BigInt(amount));
    let response;
    if (this.options.broker !== void 0) {
      const { requestSwapDepositAddress: requestSwapDepositAddress2 } = await Promise.resolve().then(() => (init_broker(), broker_exports));
      const result = await requestSwapDepositAddress2({
        ...depositAddressRequest,
        commissionBps: brokerCommissionBps ?? this.options.broker.commissionBps,
        affiliates: affiliateBrokers
      }, {
        url: this.options.broker.url
      }, this.options.network);
      response = {
        id: `${result.issuedBlock}-${depositAddressRequest.srcChain}-${result.channelId}`,
        depositAddress: result.address,
        brokerCommissionBps: this.options.broker.commissionBps,
        srcChainExpiryBlock: result.sourceChainExpiryBlock,
        maxBoostFeeBps: depositAddressRequest.maxBoostFeeBps,
        channelOpeningFee: result.channelOpeningFee
      };
    } else {
      assert(!depositAddressRequest.brokerCommissionBps, "Broker commission is only supported only when initializing the SDK with a brokerUrl");
      assert(!depositAddressRequest.affiliateBrokers?.length, "Affiliate brokers are supported only when initializing the SDK with a brokerUrl");
      response = await this.trpc.openSwapDepositChannel.mutate(depositAddressRequest);
    }
    return {
      ...depositAddressRequest,
      depositChannelId: response.id,
      depositAddress: response.depositAddress,
      brokerCommissionBps: response.brokerCommissionBps,
      affiliateBrokers: depositAddressRequest.affiliateBrokers ?? [],
      maxBoostFeeBps: Number(response.maxBoostFeeBps) || 0,
      depositChannelExpiryBlock: response.srcChainExpiryBlock,
      estimatedDepositChannelExpiryTime: response.estimatedExpiryTime,
      channelOpeningFee: response.channelOpeningFee
    };
  }
  getStatus(swapStatusRequest, options = {}) {
    return getStatus(this.options.backendUrl, swapStatusRequest, options);
  }
  async executeSwap(params, txOpts = {}) {
    const { srcChain, srcAsset, amount } = params;
    const { signer: optsSigner, ...remainingTxOpts } = txOpts;
    const signer = optsSigner ?? this.options.signer;
    assert(signer, "No signer provided");
    await this.validateSwapAmount({
      chain: srcChain,
      asset: srcAsset
    }, BigInt(amount));
    const tx = await executeSwap_default(params, {
      network: this.options.network,
      signer
    }, remainingTxOpts);
    return tx.hash;
  }
  async approveVault(params, txOpts = {}) {
    const { signer: optsSigner, ...remainingTxOpts } = txOpts;
    const signer = optsSigner ?? this.options.signer;
    assert(signer, "No signer provided");
    const tx = await approveVault(params, {
      signer,
      network: this.options.network
    }, remainingTxOpts);
    return tx ? tx.hash : null;
  }
  async validateSwapAmount(asset2, amount) {
    const stateChainEnv = await this.getStateChainEnvironment();
    const internalAsset = getInternalAsset(asset2);
    const result = validateSwapAmount(stateChainEnv, internalAsset, amount);
    if (!result.success) throw new Error(result.reason);
  }
  async getSwapLimits() {
    const { swapping: { maximumSwapAmounts }, ingressEgress: { minimumDepositAmounts } } = await this.getStateChainEnvironment();
    return {
      minimumSwapAmounts: minimumDepositAmounts,
      maximumSwapAmounts
    };
  }
  async getRequiredBlockConfirmations() {
    const { ingressEgress: { witnessSafetyMargins } } = await this.getStateChainEnvironment();
    return Object.keys(exports.Chains).reduce((acc, chain2) => {
      acc[chain2] = witnessSafetyMargins[chain2] ? Number(witnessSafetyMargins[chain2]) + 1 : null;
      return acc;
    }, {});
  }
  async getChannelOpeningFees() {
    const { ingressEgress: { channelOpeningFees } } = await this.getStateChainEnvironment();
    return channelOpeningFees;
  }
  async getBoostLiquidity({ chainAsset, feeTierBps } = {}) {
    let poolsDepth = await this.getBoostPoolsDepth();
    if (chainAsset) {
      const internalAsset = getInternalAsset(chainAsset);
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.asset === internalAsset).sort((a, b) => b.tier - a.tier);
    }
    if (feeTierBps) {
      poolsDepth = poolsDepth.filter((boostPoolDepth) => boostPoolDepth.tier === feeTierBps);
    }
    return poolsDepth.map((depth) => ({
      availableAmount: depth.availableAmount,
      feeTierBps: depth.tier,
      ...getAssetAndChain(depth.asset)
    }));
  }
};
__name(_SwapSDK, "SwapSDK");
var SwapSDK = _SwapSDK;

// src/swap/index.ts
init_enums();
/*! Bundled license information:

@trpc/client/dist/httpUtils-b9d0cb48.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)
*/

exports.SwapSDK = SwapSDK;
exports.getChainflipId = getInternalAsset;
