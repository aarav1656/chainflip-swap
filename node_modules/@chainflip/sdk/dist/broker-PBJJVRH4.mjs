import { z, assetAndChain, numericString, hexString, btcAddress, ccmMetadataSchema, affiliateBroker, dotAddress, ethereumAddress } from './chunk-JHVSTX24.mjs';
import { __name, Chains } from './chunk-3V7QJANN.mjs';
import { HttpClient } from '@chainflip/rpc';
import { bytesToHex } from '@chainflip/utils/bytes';
import * as ss58 from '@chainflip/utils/ss58';

var submitAddress = /* @__PURE__ */ __name((chain, address) => {
  if (chain === Chains.Polkadot) {
    return address.startsWith("0x") ? z.string().length(66).parse(address) : bytesToHex(ss58.decode(address).data);
  }
  return address;
}, "submitAddress");
var validateRequest = /* @__PURE__ */ __name((network, params) => z.tuple([
  assetAndChain,
  assetAndChain,
  z.union([
    numericString,
    hexString,
    btcAddress(network)
  ]),
  z.number(),
  ccmMetadataSchema.merge(z.object({
    cfParameters: z.union([
      hexString,
      z.string()
    ]).optional()
  })).transform(({ message, ...rest }) => ({
    message,
    cf_parameters: rest.cfParameters,
    gas_budget: `0x${BigInt(rest.gasBudget).toString(16)}`
  })).optional(),
  z.number().optional(),
  z.array(affiliateBroker).optional()
]).parse(params), "validateRequest");
var validateResponse = /* @__PURE__ */ __name((network, response) => z.object({
  address: z.union([
    dotAddress,
    ethereumAddress,
    btcAddress(network)
  ]),
  issued_block: z.number(),
  channel_id: z.number(),
  source_chain_expiry_block: z.bigint(),
  channel_opening_fee: z.bigint()
}).transform(({ address, issued_block, channel_id, source_chain_expiry_block, channel_opening_fee }) => ({
  address,
  issuedBlock: issued_block,
  channelId: BigInt(channel_id),
  sourceChainExpiryBlock: source_chain_expiry_block,
  channelOpeningFee: channel_opening_fee
})).parse(response), "validateResponse");
async function requestSwapDepositAddress(swapRequest, opts, chainflipNetwork) {
  const { srcAsset, srcChain, destAsset, destChain, destAddress, maxBoostFeeBps } = swapRequest;
  const client = new HttpClient(opts.url);
  const params = validateRequest(chainflipNetwork, [
    {
      asset: srcAsset,
      chain: srcChain
    },
    {
      asset: destAsset,
      chain: destChain
    },
    submitAddress(destChain, destAddress),
    swapRequest.commissionBps ?? 0,
    swapRequest.ccmMetadata && {
      ...swapRequest.ccmMetadata,
      cfParameters: void 0
    },
    maxBoostFeeBps,
    swapRequest.affiliates
  ]);
  const response = await client.sendRequest("broker_requestSwapDepositAddress", ...params);
  return validateResponse(chainflipNetwork, response);
}
__name(requestSwapDepositAddress, "requestSwapDepositAddress");

export { requestSwapDepositAddress };
