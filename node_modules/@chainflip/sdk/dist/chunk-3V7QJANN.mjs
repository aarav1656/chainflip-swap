var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../shared/src/enums.ts
var arrayToMap = /* @__PURE__ */ __name((array) => Object.fromEntries(array.map((key) => [
  key,
  key
])), "arrayToMap");
var InternalAssets = arrayToMap([
  "Flip",
  "Usdc",
  "Dot",
  "Eth",
  "Btc",
  "Usdt",
  "ArbUsdc",
  "ArbEth"
]);
var Chains = arrayToMap([
  "Bitcoin",
  "Ethereum",
  "Polkadot",
  "Arbitrum"
]);
var Assets = arrayToMap([
  "FLIP",
  "USDC",
  "DOT",
  "ETH",
  "BTC",
  "USDT"
]);
var ChainflipNetworks = arrayToMap([
  "backspin",
  "sisyphos",
  "perseverance",
  "mainnet"
]);
var isTestnet = /* @__PURE__ */ __name((network) => network !== ChainflipNetworks.mainnet, "isTestnet");
var assetConstants = {
  [InternalAssets.Eth]: {
    chain: Chains.Ethereum,
    asset: Assets.ETH,
    name: "Ether",
    decimals: 18,
    contractId: 1
  },
  [InternalAssets.Flip]: {
    chain: Chains.Ethereum,
    asset: Assets.FLIP,
    name: "FLIP",
    decimals: 18,
    contractId: 2
  },
  [InternalAssets.Usdc]: {
    chain: Chains.Ethereum,
    asset: Assets.USDC,
    name: "USDC",
    decimals: 6,
    contractId: 3
  },
  [InternalAssets.Usdt]: {
    chain: Chains.Ethereum,
    asset: Assets.USDT,
    name: "USDT",
    decimals: 6,
    contractId: 8
  },
  [InternalAssets.Dot]: {
    chain: Chains.Polkadot,
    asset: Assets.DOT,
    name: "Polkadot",
    decimals: 10,
    contractId: 4
  },
  [InternalAssets.Btc]: {
    chain: Chains.Bitcoin,
    asset: Assets.BTC,
    name: "Bitcoin",
    decimals: 8,
    contractId: 5
  },
  [InternalAssets.ArbEth]: {
    chain: Chains.Arbitrum,
    asset: Assets.ETH,
    name: "Arbitrum Ether",
    decimals: 18,
    contractId: 6
  },
  [InternalAssets.ArbUsdc]: {
    chain: Chains.Arbitrum,
    asset: Assets.USDC,
    name: "Arbitrum USDC",
    decimals: 6,
    contractId: 7
  }
};
var chainConstants = {
  [Chains.Ethereum]: {
    assets: [
      Assets.ETH,
      Assets.FLIP,
      Assets.USDC,
      Assets.USDT
    ],
    gasAsset: Assets.ETH,
    contractId: 1,
    blockTimeSeconds: 12
  },
  [Chains.Polkadot]: {
    assets: [
      Assets.DOT
    ],
    gasAsset: Assets.DOT,
    contractId: 2,
    blockTimeSeconds: 6
  },
  [Chains.Bitcoin]: {
    assets: [
      Assets.BTC
    ],
    gasAsset: Assets.BTC,
    contractId: 3,
    blockTimeSeconds: 10 * 60
  },
  [Chains.Arbitrum]: {
    assets: [
      Assets.ETH,
      Assets.USDC
    ],
    gasAsset: Assets.ETH,
    contractId: 4,
    blockTimeSeconds: 0.26
  }
};
function isValidAssetAndChain(assetAndChain) {
  const { asset, chain } = assetAndChain;
  if (!(chain in Chains)) return false;
  const validAssets = chainConstants[chain].assets;
  return validAssets.includes(asset);
}
__name(isValidAssetAndChain, "isValidAssetAndChain");
var readChainAssetValue = /* @__PURE__ */ __name((map, asset) => {
  const { chain, asset: symbol } = assetConstants[asset];
  const chainValues = map[chain];
  return chainValues[symbol];
}, "readChainAssetValue");
function getInternalAsset(asset, assert2 = true) {
  if (!isValidAssetAndChain(asset)) {
    if (assert2) {
      throw new Error(`invalid asset and chain combination: ${JSON.stringify(asset)}`);
    }
    return null;
  }
  const map = {
    [Chains.Ethereum]: {
      [Assets.USDC]: InternalAssets.Usdc,
      [Assets.FLIP]: InternalAssets.Flip,
      [Assets.ETH]: InternalAssets.Eth,
      [Assets.USDT]: InternalAssets.Usdt
    },
    [Chains.Bitcoin]: {
      [Assets.BTC]: InternalAssets.Btc
    },
    [Chains.Polkadot]: {
      [Assets.DOT]: InternalAssets.Dot
    },
    [Chains.Arbitrum]: {
      [Assets.USDC]: InternalAssets.ArbUsdc,
      [Assets.ETH]: InternalAssets.ArbEth
    }
  };
  const chain = map[asset.chain];
  return chain[asset.asset];
}
__name(getInternalAsset, "getInternalAsset");
function getInternalAssets({ srcAsset, srcChain, destAsset, destChain }, assert2 = true) {
  return {
    srcAsset: getInternalAsset({
      asset: srcAsset,
      chain: srcChain
    }, assert2),
    destAsset: getInternalAsset({
      asset: destAsset,
      chain: destChain
    }, assert2)
  };
}
__name(getInternalAssets, "getInternalAssets");
function getAssetAndChain(internalAsset, prefix) {
  const { chain, asset } = assetConstants[internalAsset];
  if (prefix) {
    return {
      [`${prefix}Asset`]: asset,
      [`${prefix}Chain`]: chain
    };
  }
  return {
    chain,
    asset
  };
}
__name(getAssetAndChain, "getAssetAndChain");

// ../shared/src/guards.ts
var isString = /* @__PURE__ */ __name((value) => typeof value === "string", "isString");
var isNotNullish = /* @__PURE__ */ __name((value) => value !== null && value !== void 0, "isNotNullish");
function assert(condition, message) {
  if (condition) return;
  const error = new Error(message);
  if (error.stack) {
    error.stack = error.stack.replace(/\n.+/, "\n");
  }
  throw error;
}
__name(assert, "assert");

export { Assets, ChainflipNetworks, Chains, InternalAssets, __name, __publicField, assert, assetConstants, chainConstants, getAssetAndChain, getInternalAsset, getInternalAssets, isNotNullish, isString, isTestnet, isValidAssetAndChain, readChainAssetValue };
